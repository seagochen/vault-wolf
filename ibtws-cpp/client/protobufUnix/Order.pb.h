// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Order.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Order_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_Order_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "OrderCondition.pb.h"
#include "SoftDollarTier.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_Order_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Order_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_Order_2eproto;
namespace protobuf {
class Order;
struct OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class Order_AlgoParamsEntry_DoNotUse;
struct Order_AlgoParamsEntry_DoNotUseDefaultTypeInternal;
extern Order_AlgoParamsEntry_DoNotUseDefaultTypeInternal _Order_AlgoParamsEntry_DoNotUse_default_instance_;
class Order_OrderMiscOptionsEntry_DoNotUse;
struct Order_OrderMiscOptionsEntry_DoNotUseDefaultTypeInternal;
extern Order_OrderMiscOptionsEntry_DoNotUseDefaultTypeInternal _Order_OrderMiscOptionsEntry_DoNotUse_default_instance_;
class Order_SmartComboRoutingParamsEntry_DoNotUse;
struct Order_SmartComboRoutingParamsEntry_DoNotUseDefaultTypeInternal;
extern Order_SmartComboRoutingParamsEntry_DoNotUseDefaultTypeInternal _Order_SmartComboRoutingParamsEntry_DoNotUse_default_instance_;
}  // namespace protobuf
PROTOBUF_NAMESPACE_OPEN
template <>
::protobuf::Order* Arena::CreateMaybeMessage<::protobuf::Order>(Arena*);
template <>
::protobuf::Order_AlgoParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::protobuf::Order_AlgoParamsEntry_DoNotUse>(Arena*);
template <>
::protobuf::Order_OrderMiscOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::protobuf::Order_OrderMiscOptionsEntry_DoNotUse>(Arena*);
template <>
::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace protobuf {

// ===================================================================


// -------------------------------------------------------------------

class Order_AlgoParamsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Order_AlgoParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Order_AlgoParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Order_AlgoParamsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Order_AlgoParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Order_AlgoParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Order_AlgoParamsEntry_DoNotUse& other);
  static const Order_AlgoParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Order_AlgoParamsEntry_DoNotUse*>(&_Order_AlgoParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.Order.AlgoParamsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.Order.AlgoParamsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Order_2eproto;
};
// -------------------------------------------------------------------

class Order_SmartComboRoutingParamsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Order_SmartComboRoutingParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Order_SmartComboRoutingParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Order_SmartComboRoutingParamsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Order_SmartComboRoutingParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Order_SmartComboRoutingParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Order_SmartComboRoutingParamsEntry_DoNotUse& other);
  static const Order_SmartComboRoutingParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Order_SmartComboRoutingParamsEntry_DoNotUse*>(&_Order_SmartComboRoutingParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.Order.SmartComboRoutingParamsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.Order.SmartComboRoutingParamsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Order_2eproto;
};
// -------------------------------------------------------------------

class Order_OrderMiscOptionsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Order_OrderMiscOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Order_OrderMiscOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Order_OrderMiscOptionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Order_OrderMiscOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Order_OrderMiscOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Order_OrderMiscOptionsEntry_DoNotUse& other);
  static const Order_OrderMiscOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Order_OrderMiscOptionsEntry_DoNotUse*>(&_Order_OrderMiscOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.Order.OrderMiscOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.Order.OrderMiscOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Order_2eproto;
};
// -------------------------------------------------------------------

class Order final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.Order) */ {
 public:
  inline Order() : Order(nullptr) {}
  ~Order() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Order(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Order(const Order& from);
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  inline Order& operator=(Order&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Order& default_instance() {
    return *internal_default_instance();
  }
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }
  inline void Swap(Order* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Order* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Order* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Order& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Order& from) {
    Order::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Order";
  }
  protected:
  explicit Order(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAlgoParamsFieldNumber = 62,
    kSmartComboRoutingParamsFieldNumber = 64,
    kOrderMiscOptionsFieldNumber = 84,
    kConditionsFieldNumber = 100,
    kActionFieldNumber = 5,
    kTotalQuantityFieldNumber = 6,
    kOrderTypeFieldNumber = 8,
    kTifFieldNumber = 11,
    kAccountFieldNumber = 12,
    kSettlingFirmFieldNumber = 13,
    kClearingAccountFieldNumber = 14,
    kClearingIntentFieldNumber = 15,
    kGoodAfterTimeFieldNumber = 25,
    kGoodTillDateFieldNumber = 26,
    kOcaGroupFieldNumber = 27,
    kOrderRefFieldNumber = 28,
    kRule80AFieldNumber = 29,
    kActiveStartTimeFieldNumber = 32,
    kActiveStopTimeFieldNumber = 33,
    kFaGroupFieldNumber = 34,
    kFaMethodFieldNumber = 35,
    kFaPercentageFieldNumber = 36,
    kDeltaNeutralOrderTypeFieldNumber = 41,
    kDeltaNeutralOpenCloseFieldNumber = 44,
    kDeltaNeutralDesignatedLocationFieldNumber = 47,
    kScaleTableFieldNumber = 58,
    kHedgeTypeFieldNumber = 59,
    kHedgeParamFieldNumber = 60,
    kAlgoStrategyFieldNumber = 61,
    kAlgoIdFieldNumber = 63,
    kOpenCloseFieldNumber = 68,
    kDesignatedLocationFieldNumber = 71,
    kDeltaNeutralSettlingFirmFieldNumber = 73,
    kDeltaNeutralClearingAccountFieldNumber = 74,
    kDeltaNeutralClearingIntentFieldNumber = 75,
    kReferenceExchangeIdFieldNumber = 92,
    kAdjustedOrderTypeFieldNumber = 93,
    kModelCodeFieldNumber = 103,
    kExtOperatorFieldNumber = 104,
    kMifid2DecisionMakerFieldNumber = 107,
    kMifid2DecisionAlgoFieldNumber = 108,
    kMifid2ExecutionTraderFieldNumber = 109,
    kMifid2ExecutionAlgoFieldNumber = 110,
    kAutoCancelDateFieldNumber = 114,
    kFilledQuantityFieldNumber = 115,
    kShareholderFieldNumber = 118,
    kAdvancedErrorOverrideFieldNumber = 125,
    kManualOrderTimeFieldNumber = 126,
    kCustomerAccountFieldNumber = 132,
    kBondAccruedInterestFieldNumber = 134,
    kSubmitterFieldNumber = 137,
    kSoftDollarTierFieldNumber = 105,
    kClientIdFieldNumber = 1,
    kOrderIdFieldNumber = 2,
    kPermIdFieldNumber = 3,
    kParentIdFieldNumber = 4,
    kDisplaySizeFieldNumber = 7,
    kLmtPriceFieldNumber = 9,
    kAuxPriceFieldNumber = 10,
    kAllOrNoneFieldNumber = 16,
    kBlockOrderFieldNumber = 17,
    kHiddenFieldNumber = 18,
    kOutsideRthFieldNumber = 19,
    kMinQtyFieldNumber = 24,
    kPercentOffsetFieldNumber = 21,
    kTrailingPercentFieldNumber = 22,
    kTrailStopPriceFieldNumber = 23,
    kOcaTypeFieldNumber = 30,
    kTriggerMethodFieldNumber = 31,
    kVolatilityFieldNumber = 37,
    kVolatilityTypeFieldNumber = 38,
    kSweepToFillFieldNumber = 20,
    kContinuousUpdateFieldNumber = 39,
    kDeltaNeutralShortSaleFieldNumber = 45,
    kScaleAutoResetFieldNumber = 54,
    kReferencePriceTypeFieldNumber = 40,
    kDeltaNeutralConIdFieldNumber = 43,
    kDeltaNeutralAuxPriceFieldNumber = 42,
    kDeltaNeutralShortSaleSlotFieldNumber = 46,
    kScaleInitLevelSizeFieldNumber = 48,
    kScalePriceIncrementFieldNumber = 50,
    kScaleSubsLevelSizeFieldNumber = 49,
    kScalePriceAdjustIntervalFieldNumber = 52,
    kScalePriceAdjustValueFieldNumber = 51,
    kScaleProfitOffsetFieldNumber = 53,
    kScaleInitPositionFieldNumber = 55,
    kScaleInitFillQtyFieldNumber = 56,
    kScaleRandomPercentFieldNumber = 57,
    kWhatIfFieldNumber = 65,
    kTransmitFieldNumber = 66,
    kOverridePercentageConstraintsFieldNumber = 67,
    kOriginFieldNumber = 69,
    kShortSaleSlotFieldNumber = 70,
    kExemptCodeFieldNumber = 72,
    kDiscretionaryAmtFieldNumber = 76,
    kStartingPriceFieldNumber = 78,
    kStockRefPriceFieldNumber = 79,
    kDeltaFieldNumber = 80,
    kStockRangeLowerFieldNumber = 81,
    kStockRangeUpperFieldNumber = 82,
    kOptOutSmartRoutingFieldNumber = 77,
    kNotHeldFieldNumber = 83,
    kSolicitedFieldNumber = 85,
    kRandomizeSizeFieldNumber = 86,
    kReferenceContractIdFieldNumber = 88,
    kPeggedChangeAmountFieldNumber = 89,
    kReferenceChangeAmountFieldNumber = 91,
    kTriggerPriceFieldNumber = 94,
    kAdjustedStopPriceFieldNumber = 95,
    kRandomizePriceFieldNumber = 87,
    kIsPeggedChangeAmountDecreaseFieldNumber = 90,
    kConditionsCancelOrderFieldNumber = 101,
    kConditionsIgnoreRthFieldNumber = 102,
    kAdjustableTrailingUnitFieldNumber = 98,
    kAdjustedStopLimitPriceFieldNumber = 96,
    kAdjustedTrailingAmountFieldNumber = 97,
    kLmtPriceOffsetFieldNumber = 99,
    kCashQtyFieldNumber = 106,
    kDontUseAutoPriceForHedgeFieldNumber = 111,
    kIsOmsContainerFieldNumber = 112,
    kDiscretionaryUpToLimitPriceFieldNumber = 113,
    kAutoCancelParentFieldNumber = 117,
    kRefFuturesConIdFieldNumber = 116,
    kParentPermIdFieldNumber = 121,
    kUsePriceMgmtAlgoFieldNumber = 122,
    kDurationFieldNumber = 123,
    kPostToAtsFieldNumber = 124,
    kImbalanceOnlyFieldNumber = 119,
    kRouteMarketableToBboFieldNumber = 120,
    kProfessionalCustomerFieldNumber = 133,
    kIncludeOvernightFieldNumber = 135,
    kMinTradeQtyFieldNumber = 127,
    kMinCompeteSizeFieldNumber = 128,
    kCompeteAgainstBestOffsetFieldNumber = 129,
    kMidOffsetAtWholeFieldNumber = 130,
    kMidOffsetAtHalfFieldNumber = 131,
    kManualOrderIndicatorFieldNumber = 136,
  };
  // map<string, string> algoParams = 62;
  int algoparams_size() const;
  private:
  int _internal_algoparams_size() const;

  public:
  void clear_algoparams() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_algoparams() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_algoparams();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      algoparams() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_algoparams();
  // map<string, string> smartComboRoutingParams = 64;
  int smartcomboroutingparams_size() const;
  private:
  int _internal_smartcomboroutingparams_size() const;

  public:
  void clear_smartcomboroutingparams() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_smartcomboroutingparams() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_smartcomboroutingparams();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      smartcomboroutingparams() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_smartcomboroutingparams();
  // map<string, string> orderMiscOptions = 84;
  int ordermiscoptions_size() const;
  private:
  int _internal_ordermiscoptions_size() const;

  public:
  void clear_ordermiscoptions() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_ordermiscoptions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_ordermiscoptions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      ordermiscoptions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_ordermiscoptions();
  // repeated .protobuf.OrderCondition conditions = 100;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;

  public:
  void clear_conditions() ;
  ::protobuf::OrderCondition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::OrderCondition >*
      mutable_conditions();
  private:
  const ::protobuf::OrderCondition& _internal_conditions(int index) const;
  ::protobuf::OrderCondition* _internal_add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protobuf::OrderCondition>& _internal_conditions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protobuf::OrderCondition>* _internal_mutable_conditions();
  public:
  const ::protobuf::OrderCondition& conditions(int index) const;
  ::protobuf::OrderCondition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::OrderCondition >&
      conditions() const;
  // optional string action = 5;
  bool has_action() const;
  void clear_action() ;
  const std::string& action() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* ptr);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // optional string totalQuantity = 6;
  bool has_totalquantity() const;
  void clear_totalquantity() ;
  const std::string& totalquantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_totalquantity(Arg_&& arg, Args_... args);
  std::string* mutable_totalquantity();
  PROTOBUF_NODISCARD std::string* release_totalquantity();
  void set_allocated_totalquantity(std::string* ptr);

  private:
  const std::string& _internal_totalquantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_totalquantity(
      const std::string& value);
  std::string* _internal_mutable_totalquantity();

  public:
  // optional string orderType = 8;
  bool has_ordertype() const;
  void clear_ordertype() ;
  const std::string& ordertype() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ordertype(Arg_&& arg, Args_... args);
  std::string* mutable_ordertype();
  PROTOBUF_NODISCARD std::string* release_ordertype();
  void set_allocated_ordertype(std::string* ptr);

  private:
  const std::string& _internal_ordertype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordertype(
      const std::string& value);
  std::string* _internal_mutable_ordertype();

  public:
  // optional string tif = 11;
  bool has_tif() const;
  void clear_tif() ;
  const std::string& tif() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tif(Arg_&& arg, Args_... args);
  std::string* mutable_tif();
  PROTOBUF_NODISCARD std::string* release_tif();
  void set_allocated_tif(std::string* ptr);

  private:
  const std::string& _internal_tif() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tif(
      const std::string& value);
  std::string* _internal_mutable_tif();

  public:
  // optional string account = 12;
  bool has_account() const;
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // optional string settlingFirm = 13;
  bool has_settlingfirm() const;
  void clear_settlingfirm() ;
  const std::string& settlingfirm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlingfirm(Arg_&& arg, Args_... args);
  std::string* mutable_settlingfirm();
  PROTOBUF_NODISCARD std::string* release_settlingfirm();
  void set_allocated_settlingfirm(std::string* ptr);

  private:
  const std::string& _internal_settlingfirm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlingfirm(
      const std::string& value);
  std::string* _internal_mutable_settlingfirm();

  public:
  // optional string clearingAccount = 14;
  bool has_clearingaccount() const;
  void clear_clearingaccount() ;
  const std::string& clearingaccount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clearingaccount(Arg_&& arg, Args_... args);
  std::string* mutable_clearingaccount();
  PROTOBUF_NODISCARD std::string* release_clearingaccount();
  void set_allocated_clearingaccount(std::string* ptr);

  private:
  const std::string& _internal_clearingaccount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clearingaccount(
      const std::string& value);
  std::string* _internal_mutable_clearingaccount();

  public:
  // optional string clearingIntent = 15;
  bool has_clearingintent() const;
  void clear_clearingintent() ;
  const std::string& clearingintent() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clearingintent(Arg_&& arg, Args_... args);
  std::string* mutable_clearingintent();
  PROTOBUF_NODISCARD std::string* release_clearingintent();
  void set_allocated_clearingintent(std::string* ptr);

  private:
  const std::string& _internal_clearingintent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clearingintent(
      const std::string& value);
  std::string* _internal_mutable_clearingintent();

  public:
  // optional string goodAfterTime = 25;
  bool has_goodaftertime() const;
  void clear_goodaftertime() ;
  const std::string& goodaftertime() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_goodaftertime(Arg_&& arg, Args_... args);
  std::string* mutable_goodaftertime();
  PROTOBUF_NODISCARD std::string* release_goodaftertime();
  void set_allocated_goodaftertime(std::string* ptr);

  private:
  const std::string& _internal_goodaftertime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_goodaftertime(
      const std::string& value);
  std::string* _internal_mutable_goodaftertime();

  public:
  // optional string goodTillDate = 26;
  bool has_goodtilldate() const;
  void clear_goodtilldate() ;
  const std::string& goodtilldate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_goodtilldate(Arg_&& arg, Args_... args);
  std::string* mutable_goodtilldate();
  PROTOBUF_NODISCARD std::string* release_goodtilldate();
  void set_allocated_goodtilldate(std::string* ptr);

  private:
  const std::string& _internal_goodtilldate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_goodtilldate(
      const std::string& value);
  std::string* _internal_mutable_goodtilldate();

  public:
  // optional string ocaGroup = 27;
  bool has_ocagroup() const;
  void clear_ocagroup() ;
  const std::string& ocagroup() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ocagroup(Arg_&& arg, Args_... args);
  std::string* mutable_ocagroup();
  PROTOBUF_NODISCARD std::string* release_ocagroup();
  void set_allocated_ocagroup(std::string* ptr);

  private:
  const std::string& _internal_ocagroup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ocagroup(
      const std::string& value);
  std::string* _internal_mutable_ocagroup();

  public:
  // optional string orderRef = 28;
  bool has_orderref() const;
  void clear_orderref() ;
  const std::string& orderref() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orderref(Arg_&& arg, Args_... args);
  std::string* mutable_orderref();
  PROTOBUF_NODISCARD std::string* release_orderref();
  void set_allocated_orderref(std::string* ptr);

  private:
  const std::string& _internal_orderref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orderref(
      const std::string& value);
  std::string* _internal_mutable_orderref();

  public:
  // optional string rule80A = 29;
  bool has_rule80a() const;
  void clear_rule80a() ;
  const std::string& rule80a() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule80a(Arg_&& arg, Args_... args);
  std::string* mutable_rule80a();
  PROTOBUF_NODISCARD std::string* release_rule80a();
  void set_allocated_rule80a(std::string* ptr);

  private:
  const std::string& _internal_rule80a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule80a(
      const std::string& value);
  std::string* _internal_mutable_rule80a();

  public:
  // optional string activeStartTime = 32;
  bool has_activestarttime() const;
  void clear_activestarttime() ;
  const std::string& activestarttime() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_activestarttime(Arg_&& arg, Args_... args);
  std::string* mutable_activestarttime();
  PROTOBUF_NODISCARD std::string* release_activestarttime();
  void set_allocated_activestarttime(std::string* ptr);

  private:
  const std::string& _internal_activestarttime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activestarttime(
      const std::string& value);
  std::string* _internal_mutable_activestarttime();

  public:
  // optional string activeStopTime = 33;
  bool has_activestoptime() const;
  void clear_activestoptime() ;
  const std::string& activestoptime() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_activestoptime(Arg_&& arg, Args_... args);
  std::string* mutable_activestoptime();
  PROTOBUF_NODISCARD std::string* release_activestoptime();
  void set_allocated_activestoptime(std::string* ptr);

  private:
  const std::string& _internal_activestoptime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activestoptime(
      const std::string& value);
  std::string* _internal_mutable_activestoptime();

  public:
  // optional string faGroup = 34;
  bool has_fagroup() const;
  void clear_fagroup() ;
  const std::string& fagroup() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fagroup(Arg_&& arg, Args_... args);
  std::string* mutable_fagroup();
  PROTOBUF_NODISCARD std::string* release_fagroup();
  void set_allocated_fagroup(std::string* ptr);

  private:
  const std::string& _internal_fagroup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fagroup(
      const std::string& value);
  std::string* _internal_mutable_fagroup();

  public:
  // optional string faMethod = 35;
  bool has_famethod() const;
  void clear_famethod() ;
  const std::string& famethod() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_famethod(Arg_&& arg, Args_... args);
  std::string* mutable_famethod();
  PROTOBUF_NODISCARD std::string* release_famethod();
  void set_allocated_famethod(std::string* ptr);

  private:
  const std::string& _internal_famethod() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_famethod(
      const std::string& value);
  std::string* _internal_mutable_famethod();

  public:
  // optional string faPercentage = 36;
  bool has_fapercentage() const;
  void clear_fapercentage() ;
  const std::string& fapercentage() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fapercentage(Arg_&& arg, Args_... args);
  std::string* mutable_fapercentage();
  PROTOBUF_NODISCARD std::string* release_fapercentage();
  void set_allocated_fapercentage(std::string* ptr);

  private:
  const std::string& _internal_fapercentage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fapercentage(
      const std::string& value);
  std::string* _internal_mutable_fapercentage();

  public:
  // optional string deltaNeutralOrderType = 41;
  bool has_deltaneutralordertype() const;
  void clear_deltaneutralordertype() ;
  const std::string& deltaneutralordertype() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deltaneutralordertype(Arg_&& arg, Args_... args);
  std::string* mutable_deltaneutralordertype();
  PROTOBUF_NODISCARD std::string* release_deltaneutralordertype();
  void set_allocated_deltaneutralordertype(std::string* ptr);

  private:
  const std::string& _internal_deltaneutralordertype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deltaneutralordertype(
      const std::string& value);
  std::string* _internal_mutable_deltaneutralordertype();

  public:
  // optional string deltaNeutralOpenClose = 44;
  bool has_deltaneutralopenclose() const;
  void clear_deltaneutralopenclose() ;
  const std::string& deltaneutralopenclose() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deltaneutralopenclose(Arg_&& arg, Args_... args);
  std::string* mutable_deltaneutralopenclose();
  PROTOBUF_NODISCARD std::string* release_deltaneutralopenclose();
  void set_allocated_deltaneutralopenclose(std::string* ptr);

  private:
  const std::string& _internal_deltaneutralopenclose() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deltaneutralopenclose(
      const std::string& value);
  std::string* _internal_mutable_deltaneutralopenclose();

  public:
  // optional string deltaNeutralDesignatedLocation = 47;
  bool has_deltaneutraldesignatedlocation() const;
  void clear_deltaneutraldesignatedlocation() ;
  const std::string& deltaneutraldesignatedlocation() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deltaneutraldesignatedlocation(Arg_&& arg, Args_... args);
  std::string* mutable_deltaneutraldesignatedlocation();
  PROTOBUF_NODISCARD std::string* release_deltaneutraldesignatedlocation();
  void set_allocated_deltaneutraldesignatedlocation(std::string* ptr);

  private:
  const std::string& _internal_deltaneutraldesignatedlocation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deltaneutraldesignatedlocation(
      const std::string& value);
  std::string* _internal_mutable_deltaneutraldesignatedlocation();

  public:
  // optional string scaleTable = 58;
  bool has_scaletable() const;
  void clear_scaletable() ;
  const std::string& scaletable() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_scaletable(Arg_&& arg, Args_... args);
  std::string* mutable_scaletable();
  PROTOBUF_NODISCARD std::string* release_scaletable();
  void set_allocated_scaletable(std::string* ptr);

  private:
  const std::string& _internal_scaletable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scaletable(
      const std::string& value);
  std::string* _internal_mutable_scaletable();

  public:
  // optional string hedgeType = 59;
  bool has_hedgetype() const;
  void clear_hedgetype() ;
  const std::string& hedgetype() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hedgetype(Arg_&& arg, Args_... args);
  std::string* mutable_hedgetype();
  PROTOBUF_NODISCARD std::string* release_hedgetype();
  void set_allocated_hedgetype(std::string* ptr);

  private:
  const std::string& _internal_hedgetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hedgetype(
      const std::string& value);
  std::string* _internal_mutable_hedgetype();

  public:
  // optional string hedgeParam = 60;
  bool has_hedgeparam() const;
  void clear_hedgeparam() ;
  const std::string& hedgeparam() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hedgeparam(Arg_&& arg, Args_... args);
  std::string* mutable_hedgeparam();
  PROTOBUF_NODISCARD std::string* release_hedgeparam();
  void set_allocated_hedgeparam(std::string* ptr);

  private:
  const std::string& _internal_hedgeparam() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hedgeparam(
      const std::string& value);
  std::string* _internal_mutable_hedgeparam();

  public:
  // optional string algoStrategy = 61;
  bool has_algostrategy() const;
  void clear_algostrategy() ;
  const std::string& algostrategy() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algostrategy(Arg_&& arg, Args_... args);
  std::string* mutable_algostrategy();
  PROTOBUF_NODISCARD std::string* release_algostrategy();
  void set_allocated_algostrategy(std::string* ptr);

  private:
  const std::string& _internal_algostrategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algostrategy(
      const std::string& value);
  std::string* _internal_mutable_algostrategy();

  public:
  // optional string algoId = 63;
  bool has_algoid() const;
  void clear_algoid() ;
  const std::string& algoid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algoid(Arg_&& arg, Args_... args);
  std::string* mutable_algoid();
  PROTOBUF_NODISCARD std::string* release_algoid();
  void set_allocated_algoid(std::string* ptr);

  private:
  const std::string& _internal_algoid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algoid(
      const std::string& value);
  std::string* _internal_mutable_algoid();

  public:
  // optional string openClose = 68;
  bool has_openclose() const;
  void clear_openclose() ;
  const std::string& openclose() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_openclose(Arg_&& arg, Args_... args);
  std::string* mutable_openclose();
  PROTOBUF_NODISCARD std::string* release_openclose();
  void set_allocated_openclose(std::string* ptr);

  private:
  const std::string& _internal_openclose() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_openclose(
      const std::string& value);
  std::string* _internal_mutable_openclose();

  public:
  // optional string designatedLocation = 71;
  bool has_designatedlocation() const;
  void clear_designatedlocation() ;
  const std::string& designatedlocation() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_designatedlocation(Arg_&& arg, Args_... args);
  std::string* mutable_designatedlocation();
  PROTOBUF_NODISCARD std::string* release_designatedlocation();
  void set_allocated_designatedlocation(std::string* ptr);

  private:
  const std::string& _internal_designatedlocation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_designatedlocation(
      const std::string& value);
  std::string* _internal_mutable_designatedlocation();

  public:
  // optional string deltaNeutralSettlingFirm = 73;
  bool has_deltaneutralsettlingfirm() const;
  void clear_deltaneutralsettlingfirm() ;
  const std::string& deltaneutralsettlingfirm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deltaneutralsettlingfirm(Arg_&& arg, Args_... args);
  std::string* mutable_deltaneutralsettlingfirm();
  PROTOBUF_NODISCARD std::string* release_deltaneutralsettlingfirm();
  void set_allocated_deltaneutralsettlingfirm(std::string* ptr);

  private:
  const std::string& _internal_deltaneutralsettlingfirm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deltaneutralsettlingfirm(
      const std::string& value);
  std::string* _internal_mutable_deltaneutralsettlingfirm();

  public:
  // optional string deltaNeutralClearingAccount = 74;
  bool has_deltaneutralclearingaccount() const;
  void clear_deltaneutralclearingaccount() ;
  const std::string& deltaneutralclearingaccount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deltaneutralclearingaccount(Arg_&& arg, Args_... args);
  std::string* mutable_deltaneutralclearingaccount();
  PROTOBUF_NODISCARD std::string* release_deltaneutralclearingaccount();
  void set_allocated_deltaneutralclearingaccount(std::string* ptr);

  private:
  const std::string& _internal_deltaneutralclearingaccount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deltaneutralclearingaccount(
      const std::string& value);
  std::string* _internal_mutable_deltaneutralclearingaccount();

  public:
  // optional string deltaNeutralClearingIntent = 75;
  bool has_deltaneutralclearingintent() const;
  void clear_deltaneutralclearingintent() ;
  const std::string& deltaneutralclearingintent() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deltaneutralclearingintent(Arg_&& arg, Args_... args);
  std::string* mutable_deltaneutralclearingintent();
  PROTOBUF_NODISCARD std::string* release_deltaneutralclearingintent();
  void set_allocated_deltaneutralclearingintent(std::string* ptr);

  private:
  const std::string& _internal_deltaneutralclearingintent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deltaneutralclearingintent(
      const std::string& value);
  std::string* _internal_mutable_deltaneutralclearingintent();

  public:
  // optional string referenceExchangeId = 92;
  bool has_referenceexchangeid() const;
  void clear_referenceexchangeid() ;
  const std::string& referenceexchangeid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_referenceexchangeid(Arg_&& arg, Args_... args);
  std::string* mutable_referenceexchangeid();
  PROTOBUF_NODISCARD std::string* release_referenceexchangeid();
  void set_allocated_referenceexchangeid(std::string* ptr);

  private:
  const std::string& _internal_referenceexchangeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referenceexchangeid(
      const std::string& value);
  std::string* _internal_mutable_referenceexchangeid();

  public:
  // optional string adjustedOrderType = 93;
  bool has_adjustedordertype() const;
  void clear_adjustedordertype() ;
  const std::string& adjustedordertype() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adjustedordertype(Arg_&& arg, Args_... args);
  std::string* mutable_adjustedordertype();
  PROTOBUF_NODISCARD std::string* release_adjustedordertype();
  void set_allocated_adjustedordertype(std::string* ptr);

  private:
  const std::string& _internal_adjustedordertype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adjustedordertype(
      const std::string& value);
  std::string* _internal_mutable_adjustedordertype();

  public:
  // optional string modelCode = 103;
  bool has_modelcode() const;
  void clear_modelcode() ;
  const std::string& modelcode() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelcode(Arg_&& arg, Args_... args);
  std::string* mutable_modelcode();
  PROTOBUF_NODISCARD std::string* release_modelcode();
  void set_allocated_modelcode(std::string* ptr);

  private:
  const std::string& _internal_modelcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelcode(
      const std::string& value);
  std::string* _internal_mutable_modelcode();

  public:
  // optional string extOperator = 104;
  bool has_extoperator() const;
  void clear_extoperator() ;
  const std::string& extoperator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extoperator(Arg_&& arg, Args_... args);
  std::string* mutable_extoperator();
  PROTOBUF_NODISCARD std::string* release_extoperator();
  void set_allocated_extoperator(std::string* ptr);

  private:
  const std::string& _internal_extoperator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extoperator(
      const std::string& value);
  std::string* _internal_mutable_extoperator();

  public:
  // optional string mifid2DecisionMaker = 107;
  bool has_mifid2decisionmaker() const;
  void clear_mifid2decisionmaker() ;
  const std::string& mifid2decisionmaker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mifid2decisionmaker(Arg_&& arg, Args_... args);
  std::string* mutable_mifid2decisionmaker();
  PROTOBUF_NODISCARD std::string* release_mifid2decisionmaker();
  void set_allocated_mifid2decisionmaker(std::string* ptr);

  private:
  const std::string& _internal_mifid2decisionmaker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mifid2decisionmaker(
      const std::string& value);
  std::string* _internal_mutable_mifid2decisionmaker();

  public:
  // optional string mifid2DecisionAlgo = 108;
  bool has_mifid2decisionalgo() const;
  void clear_mifid2decisionalgo() ;
  const std::string& mifid2decisionalgo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mifid2decisionalgo(Arg_&& arg, Args_... args);
  std::string* mutable_mifid2decisionalgo();
  PROTOBUF_NODISCARD std::string* release_mifid2decisionalgo();
  void set_allocated_mifid2decisionalgo(std::string* ptr);

  private:
  const std::string& _internal_mifid2decisionalgo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mifid2decisionalgo(
      const std::string& value);
  std::string* _internal_mutable_mifid2decisionalgo();

  public:
  // optional string mifid2ExecutionTrader = 109;
  bool has_mifid2executiontrader() const;
  void clear_mifid2executiontrader() ;
  const std::string& mifid2executiontrader() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mifid2executiontrader(Arg_&& arg, Args_... args);
  std::string* mutable_mifid2executiontrader();
  PROTOBUF_NODISCARD std::string* release_mifid2executiontrader();
  void set_allocated_mifid2executiontrader(std::string* ptr);

  private:
  const std::string& _internal_mifid2executiontrader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mifid2executiontrader(
      const std::string& value);
  std::string* _internal_mutable_mifid2executiontrader();

  public:
  // optional string mifid2ExecutionAlgo = 110;
  bool has_mifid2executionalgo() const;
  void clear_mifid2executionalgo() ;
  const std::string& mifid2executionalgo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mifid2executionalgo(Arg_&& arg, Args_... args);
  std::string* mutable_mifid2executionalgo();
  PROTOBUF_NODISCARD std::string* release_mifid2executionalgo();
  void set_allocated_mifid2executionalgo(std::string* ptr);

  private:
  const std::string& _internal_mifid2executionalgo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mifid2executionalgo(
      const std::string& value);
  std::string* _internal_mutable_mifid2executionalgo();

  public:
  // optional string autoCancelDate = 114;
  bool has_autocanceldate() const;
  void clear_autocanceldate() ;
  const std::string& autocanceldate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_autocanceldate(Arg_&& arg, Args_... args);
  std::string* mutable_autocanceldate();
  PROTOBUF_NODISCARD std::string* release_autocanceldate();
  void set_allocated_autocanceldate(std::string* ptr);

  private:
  const std::string& _internal_autocanceldate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_autocanceldate(
      const std::string& value);
  std::string* _internal_mutable_autocanceldate();

  public:
  // optional string filledQuantity = 115;
  bool has_filledquantity() const;
  void clear_filledquantity() ;
  const std::string& filledquantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filledquantity(Arg_&& arg, Args_... args);
  std::string* mutable_filledquantity();
  PROTOBUF_NODISCARD std::string* release_filledquantity();
  void set_allocated_filledquantity(std::string* ptr);

  private:
  const std::string& _internal_filledquantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filledquantity(
      const std::string& value);
  std::string* _internal_mutable_filledquantity();

  public:
  // optional string shareholder = 118;
  bool has_shareholder() const;
  void clear_shareholder() ;
  const std::string& shareholder() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shareholder(Arg_&& arg, Args_... args);
  std::string* mutable_shareholder();
  PROTOBUF_NODISCARD std::string* release_shareholder();
  void set_allocated_shareholder(std::string* ptr);

  private:
  const std::string& _internal_shareholder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shareholder(
      const std::string& value);
  std::string* _internal_mutable_shareholder();

  public:
  // optional string advancedErrorOverride = 125;
  bool has_advancederroroverride() const;
  void clear_advancederroroverride() ;
  const std::string& advancederroroverride() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_advancederroroverride(Arg_&& arg, Args_... args);
  std::string* mutable_advancederroroverride();
  PROTOBUF_NODISCARD std::string* release_advancederroroverride();
  void set_allocated_advancederroroverride(std::string* ptr);

  private:
  const std::string& _internal_advancederroroverride() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_advancederroroverride(
      const std::string& value);
  std::string* _internal_mutable_advancederroroverride();

  public:
  // optional string manualOrderTime = 126;
  bool has_manualordertime() const;
  void clear_manualordertime() ;
  const std::string& manualordertime() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_manualordertime(Arg_&& arg, Args_... args);
  std::string* mutable_manualordertime();
  PROTOBUF_NODISCARD std::string* release_manualordertime();
  void set_allocated_manualordertime(std::string* ptr);

  private:
  const std::string& _internal_manualordertime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manualordertime(
      const std::string& value);
  std::string* _internal_mutable_manualordertime();

  public:
  // optional string customerAccount = 132;
  bool has_customeraccount() const;
  void clear_customeraccount() ;
  const std::string& customeraccount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_customeraccount(Arg_&& arg, Args_... args);
  std::string* mutable_customeraccount();
  PROTOBUF_NODISCARD std::string* release_customeraccount();
  void set_allocated_customeraccount(std::string* ptr);

  private:
  const std::string& _internal_customeraccount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customeraccount(
      const std::string& value);
  std::string* _internal_mutable_customeraccount();

  public:
  // optional string bondAccruedInterest = 134;
  bool has_bondaccruedinterest() const;
  void clear_bondaccruedinterest() ;
  const std::string& bondaccruedinterest() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bondaccruedinterest(Arg_&& arg, Args_... args);
  std::string* mutable_bondaccruedinterest();
  PROTOBUF_NODISCARD std::string* release_bondaccruedinterest();
  void set_allocated_bondaccruedinterest(std::string* ptr);

  private:
  const std::string& _internal_bondaccruedinterest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bondaccruedinterest(
      const std::string& value);
  std::string* _internal_mutable_bondaccruedinterest();

  public:
  // optional string submitter = 137;
  bool has_submitter() const;
  void clear_submitter() ;
  const std::string& submitter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_submitter(Arg_&& arg, Args_... args);
  std::string* mutable_submitter();
  PROTOBUF_NODISCARD std::string* release_submitter();
  void set_allocated_submitter(std::string* ptr);

  private:
  const std::string& _internal_submitter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_submitter(
      const std::string& value);
  std::string* _internal_mutable_submitter();

  public:
  // optional .protobuf.SoftDollarTier softDollarTier = 105;
  bool has_softdollartier() const;
  void clear_softdollartier() ;
  const ::protobuf::SoftDollarTier& softdollartier() const;
  PROTOBUF_NODISCARD ::protobuf::SoftDollarTier* release_softdollartier();
  ::protobuf::SoftDollarTier* mutable_softdollartier();
  void set_allocated_softdollartier(::protobuf::SoftDollarTier* softdollartier);
  private:
  const ::protobuf::SoftDollarTier& _internal_softdollartier() const;
  ::protobuf::SoftDollarTier* _internal_mutable_softdollartier();
  public:
  void unsafe_arena_set_allocated_softdollartier(
      ::protobuf::SoftDollarTier* softdollartier);
  ::protobuf::SoftDollarTier* unsafe_arena_release_softdollartier();
  // optional int32 clientId = 1;
  bool has_clientid() const;
  void clear_clientid() ;
  ::int32_t clientid() const;
  void set_clientid(::int32_t value);

  private:
  ::int32_t _internal_clientid() const;
  void _internal_set_clientid(::int32_t value);

  public:
  // optional int32 orderId = 2;
  bool has_orderid() const;
  void clear_orderid() ;
  ::int32_t orderid() const;
  void set_orderid(::int32_t value);

  private:
  ::int32_t _internal_orderid() const;
  void _internal_set_orderid(::int32_t value);

  public:
  // optional int64 permId = 3;
  bool has_permid() const;
  void clear_permid() ;
  ::int64_t permid() const;
  void set_permid(::int64_t value);

  private:
  ::int64_t _internal_permid() const;
  void _internal_set_permid(::int64_t value);

  public:
  // optional int32 parentId = 4;
  bool has_parentid() const;
  void clear_parentid() ;
  ::int32_t parentid() const;
  void set_parentid(::int32_t value);

  private:
  ::int32_t _internal_parentid() const;
  void _internal_set_parentid(::int32_t value);

  public:
  // optional int32 displaySize = 7;
  bool has_displaysize() const;
  void clear_displaysize() ;
  ::int32_t displaysize() const;
  void set_displaysize(::int32_t value);

  private:
  ::int32_t _internal_displaysize() const;
  void _internal_set_displaysize(::int32_t value);

  public:
  // optional double lmtPrice = 9;
  bool has_lmtprice() const;
  void clear_lmtprice() ;
  double lmtprice() const;
  void set_lmtprice(double value);

  private:
  double _internal_lmtprice() const;
  void _internal_set_lmtprice(double value);

  public:
  // optional double auxPrice = 10;
  bool has_auxprice() const;
  void clear_auxprice() ;
  double auxprice() const;
  void set_auxprice(double value);

  private:
  double _internal_auxprice() const;
  void _internal_set_auxprice(double value);

  public:
  // optional bool allOrNone = 16;
  bool has_allornone() const;
  void clear_allornone() ;
  bool allornone() const;
  void set_allornone(bool value);

  private:
  bool _internal_allornone() const;
  void _internal_set_allornone(bool value);

  public:
  // optional bool blockOrder = 17;
  bool has_blockorder() const;
  void clear_blockorder() ;
  bool blockorder() const;
  void set_blockorder(bool value);

  private:
  bool _internal_blockorder() const;
  void _internal_set_blockorder(bool value);

  public:
  // optional bool hidden = 18;
  bool has_hidden() const;
  void clear_hidden() ;
  bool hidden() const;
  void set_hidden(bool value);

  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);

  public:
  // optional bool outsideRth = 19;
  bool has_outsiderth() const;
  void clear_outsiderth() ;
  bool outsiderth() const;
  void set_outsiderth(bool value);

  private:
  bool _internal_outsiderth() const;
  void _internal_set_outsiderth(bool value);

  public:
  // optional int32 minQty = 24;
  bool has_minqty() const;
  void clear_minqty() ;
  ::int32_t minqty() const;
  void set_minqty(::int32_t value);

  private:
  ::int32_t _internal_minqty() const;
  void _internal_set_minqty(::int32_t value);

  public:
  // optional double percentOffset = 21;
  bool has_percentoffset() const;
  void clear_percentoffset() ;
  double percentoffset() const;
  void set_percentoffset(double value);

  private:
  double _internal_percentoffset() const;
  void _internal_set_percentoffset(double value);

  public:
  // optional double trailingPercent = 22;
  bool has_trailingpercent() const;
  void clear_trailingpercent() ;
  double trailingpercent() const;
  void set_trailingpercent(double value);

  private:
  double _internal_trailingpercent() const;
  void _internal_set_trailingpercent(double value);

  public:
  // optional double trailStopPrice = 23;
  bool has_trailstopprice() const;
  void clear_trailstopprice() ;
  double trailstopprice() const;
  void set_trailstopprice(double value);

  private:
  double _internal_trailstopprice() const;
  void _internal_set_trailstopprice(double value);

  public:
  // optional int32 ocaType = 30;
  bool has_ocatype() const;
  void clear_ocatype() ;
  ::int32_t ocatype() const;
  void set_ocatype(::int32_t value);

  private:
  ::int32_t _internal_ocatype() const;
  void _internal_set_ocatype(::int32_t value);

  public:
  // optional int32 triggerMethod = 31;
  bool has_triggermethod() const;
  void clear_triggermethod() ;
  ::int32_t triggermethod() const;
  void set_triggermethod(::int32_t value);

  private:
  ::int32_t _internal_triggermethod() const;
  void _internal_set_triggermethod(::int32_t value);

  public:
  // optional double volatility = 37;
  bool has_volatility() const;
  void clear_volatility() ;
  double volatility() const;
  void set_volatility(double value);

  private:
  double _internal_volatility() const;
  void _internal_set_volatility(double value);

  public:
  // optional int32 volatilityType = 38;
  bool has_volatilitytype() const;
  void clear_volatilitytype() ;
  ::int32_t volatilitytype() const;
  void set_volatilitytype(::int32_t value);

  private:
  ::int32_t _internal_volatilitytype() const;
  void _internal_set_volatilitytype(::int32_t value);

  public:
  // optional bool sweepToFill = 20;
  bool has_sweeptofill() const;
  void clear_sweeptofill() ;
  bool sweeptofill() const;
  void set_sweeptofill(bool value);

  private:
  bool _internal_sweeptofill() const;
  void _internal_set_sweeptofill(bool value);

  public:
  // optional bool continuousUpdate = 39;
  bool has_continuousupdate() const;
  void clear_continuousupdate() ;
  bool continuousupdate() const;
  void set_continuousupdate(bool value);

  private:
  bool _internal_continuousupdate() const;
  void _internal_set_continuousupdate(bool value);

  public:
  // optional bool deltaNeutralShortSale = 45;
  bool has_deltaneutralshortsale() const;
  void clear_deltaneutralshortsale() ;
  bool deltaneutralshortsale() const;
  void set_deltaneutralshortsale(bool value);

  private:
  bool _internal_deltaneutralshortsale() const;
  void _internal_set_deltaneutralshortsale(bool value);

  public:
  // optional bool scaleAutoReset = 54;
  bool has_scaleautoreset() const;
  void clear_scaleautoreset() ;
  bool scaleautoreset() const;
  void set_scaleautoreset(bool value);

  private:
  bool _internal_scaleautoreset() const;
  void _internal_set_scaleautoreset(bool value);

  public:
  // optional int32 referencePriceType = 40;
  bool has_referencepricetype() const;
  void clear_referencepricetype() ;
  ::int32_t referencepricetype() const;
  void set_referencepricetype(::int32_t value);

  private:
  ::int32_t _internal_referencepricetype() const;
  void _internal_set_referencepricetype(::int32_t value);

  public:
  // optional int32 deltaNeutralConId = 43;
  bool has_deltaneutralconid() const;
  void clear_deltaneutralconid() ;
  ::int32_t deltaneutralconid() const;
  void set_deltaneutralconid(::int32_t value);

  private:
  ::int32_t _internal_deltaneutralconid() const;
  void _internal_set_deltaneutralconid(::int32_t value);

  public:
  // optional double deltaNeutralAuxPrice = 42;
  bool has_deltaneutralauxprice() const;
  void clear_deltaneutralauxprice() ;
  double deltaneutralauxprice() const;
  void set_deltaneutralauxprice(double value);

  private:
  double _internal_deltaneutralauxprice() const;
  void _internal_set_deltaneutralauxprice(double value);

  public:
  // optional int32 deltaNeutralShortSaleSlot = 46;
  bool has_deltaneutralshortsaleslot() const;
  void clear_deltaneutralshortsaleslot() ;
  ::int32_t deltaneutralshortsaleslot() const;
  void set_deltaneutralshortsaleslot(::int32_t value);

  private:
  ::int32_t _internal_deltaneutralshortsaleslot() const;
  void _internal_set_deltaneutralshortsaleslot(::int32_t value);

  public:
  // optional int32 scaleInitLevelSize = 48;
  bool has_scaleinitlevelsize() const;
  void clear_scaleinitlevelsize() ;
  ::int32_t scaleinitlevelsize() const;
  void set_scaleinitlevelsize(::int32_t value);

  private:
  ::int32_t _internal_scaleinitlevelsize() const;
  void _internal_set_scaleinitlevelsize(::int32_t value);

  public:
  // optional double scalePriceIncrement = 50;
  bool has_scalepriceincrement() const;
  void clear_scalepriceincrement() ;
  double scalepriceincrement() const;
  void set_scalepriceincrement(double value);

  private:
  double _internal_scalepriceincrement() const;
  void _internal_set_scalepriceincrement(double value);

  public:
  // optional int32 scaleSubsLevelSize = 49;
  bool has_scalesubslevelsize() const;
  void clear_scalesubslevelsize() ;
  ::int32_t scalesubslevelsize() const;
  void set_scalesubslevelsize(::int32_t value);

  private:
  ::int32_t _internal_scalesubslevelsize() const;
  void _internal_set_scalesubslevelsize(::int32_t value);

  public:
  // optional int32 scalePriceAdjustInterval = 52;
  bool has_scalepriceadjustinterval() const;
  void clear_scalepriceadjustinterval() ;
  ::int32_t scalepriceadjustinterval() const;
  void set_scalepriceadjustinterval(::int32_t value);

  private:
  ::int32_t _internal_scalepriceadjustinterval() const;
  void _internal_set_scalepriceadjustinterval(::int32_t value);

  public:
  // optional double scalePriceAdjustValue = 51;
  bool has_scalepriceadjustvalue() const;
  void clear_scalepriceadjustvalue() ;
  double scalepriceadjustvalue() const;
  void set_scalepriceadjustvalue(double value);

  private:
  double _internal_scalepriceadjustvalue() const;
  void _internal_set_scalepriceadjustvalue(double value);

  public:
  // optional double scaleProfitOffset = 53;
  bool has_scaleprofitoffset() const;
  void clear_scaleprofitoffset() ;
  double scaleprofitoffset() const;
  void set_scaleprofitoffset(double value);

  private:
  double _internal_scaleprofitoffset() const;
  void _internal_set_scaleprofitoffset(double value);

  public:
  // optional int32 scaleInitPosition = 55;
  bool has_scaleinitposition() const;
  void clear_scaleinitposition() ;
  ::int32_t scaleinitposition() const;
  void set_scaleinitposition(::int32_t value);

  private:
  ::int32_t _internal_scaleinitposition() const;
  void _internal_set_scaleinitposition(::int32_t value);

  public:
  // optional int32 scaleInitFillQty = 56;
  bool has_scaleinitfillqty() const;
  void clear_scaleinitfillqty() ;
  ::int32_t scaleinitfillqty() const;
  void set_scaleinitfillqty(::int32_t value);

  private:
  ::int32_t _internal_scaleinitfillqty() const;
  void _internal_set_scaleinitfillqty(::int32_t value);

  public:
  // optional bool scaleRandomPercent = 57;
  bool has_scalerandompercent() const;
  void clear_scalerandompercent() ;
  bool scalerandompercent() const;
  void set_scalerandompercent(bool value);

  private:
  bool _internal_scalerandompercent() const;
  void _internal_set_scalerandompercent(bool value);

  public:
  // optional bool whatIf = 65;
  bool has_whatif() const;
  void clear_whatif() ;
  bool whatif() const;
  void set_whatif(bool value);

  private:
  bool _internal_whatif() const;
  void _internal_set_whatif(bool value);

  public:
  // optional bool transmit = 66;
  bool has_transmit() const;
  void clear_transmit() ;
  bool transmit() const;
  void set_transmit(bool value);

  private:
  bool _internal_transmit() const;
  void _internal_set_transmit(bool value);

  public:
  // optional bool overridePercentageConstraints = 67;
  bool has_overridepercentageconstraints() const;
  void clear_overridepercentageconstraints() ;
  bool overridepercentageconstraints() const;
  void set_overridepercentageconstraints(bool value);

  private:
  bool _internal_overridepercentageconstraints() const;
  void _internal_set_overridepercentageconstraints(bool value);

  public:
  // optional int32 origin = 69;
  bool has_origin() const;
  void clear_origin() ;
  ::int32_t origin() const;
  void set_origin(::int32_t value);

  private:
  ::int32_t _internal_origin() const;
  void _internal_set_origin(::int32_t value);

  public:
  // optional int32 shortSaleSlot = 70;
  bool has_shortsaleslot() const;
  void clear_shortsaleslot() ;
  ::int32_t shortsaleslot() const;
  void set_shortsaleslot(::int32_t value);

  private:
  ::int32_t _internal_shortsaleslot() const;
  void _internal_set_shortsaleslot(::int32_t value);

  public:
  // optional int32 exemptCode = 72;
  bool has_exemptcode() const;
  void clear_exemptcode() ;
  ::int32_t exemptcode() const;
  void set_exemptcode(::int32_t value);

  private:
  ::int32_t _internal_exemptcode() const;
  void _internal_set_exemptcode(::int32_t value);

  public:
  // optional double discretionaryAmt = 76;
  bool has_discretionaryamt() const;
  void clear_discretionaryamt() ;
  double discretionaryamt() const;
  void set_discretionaryamt(double value);

  private:
  double _internal_discretionaryamt() const;
  void _internal_set_discretionaryamt(double value);

  public:
  // optional double startingPrice = 78;
  bool has_startingprice() const;
  void clear_startingprice() ;
  double startingprice() const;
  void set_startingprice(double value);

  private:
  double _internal_startingprice() const;
  void _internal_set_startingprice(double value);

  public:
  // optional double stockRefPrice = 79;
  bool has_stockrefprice() const;
  void clear_stockrefprice() ;
  double stockrefprice() const;
  void set_stockrefprice(double value);

  private:
  double _internal_stockrefprice() const;
  void _internal_set_stockrefprice(double value);

  public:
  // optional double delta = 80;
  bool has_delta() const;
  void clear_delta() ;
  double delta() const;
  void set_delta(double value);

  private:
  double _internal_delta() const;
  void _internal_set_delta(double value);

  public:
  // optional double stockRangeLower = 81;
  bool has_stockrangelower() const;
  void clear_stockrangelower() ;
  double stockrangelower() const;
  void set_stockrangelower(double value);

  private:
  double _internal_stockrangelower() const;
  void _internal_set_stockrangelower(double value);

  public:
  // optional double stockRangeUpper = 82;
  bool has_stockrangeupper() const;
  void clear_stockrangeupper() ;
  double stockrangeupper() const;
  void set_stockrangeupper(double value);

  private:
  double _internal_stockrangeupper() const;
  void _internal_set_stockrangeupper(double value);

  public:
  // optional bool optOutSmartRouting = 77;
  bool has_optoutsmartrouting() const;
  void clear_optoutsmartrouting() ;
  bool optoutsmartrouting() const;
  void set_optoutsmartrouting(bool value);

  private:
  bool _internal_optoutsmartrouting() const;
  void _internal_set_optoutsmartrouting(bool value);

  public:
  // optional bool notHeld = 83;
  bool has_notheld() const;
  void clear_notheld() ;
  bool notheld() const;
  void set_notheld(bool value);

  private:
  bool _internal_notheld() const;
  void _internal_set_notheld(bool value);

  public:
  // optional bool solicited = 85;
  bool has_solicited() const;
  void clear_solicited() ;
  bool solicited() const;
  void set_solicited(bool value);

  private:
  bool _internal_solicited() const;
  void _internal_set_solicited(bool value);

  public:
  // optional bool randomizeSize = 86;
  bool has_randomizesize() const;
  void clear_randomizesize() ;
  bool randomizesize() const;
  void set_randomizesize(bool value);

  private:
  bool _internal_randomizesize() const;
  void _internal_set_randomizesize(bool value);

  public:
  // optional int32 referenceContractId = 88;
  bool has_referencecontractid() const;
  void clear_referencecontractid() ;
  ::int32_t referencecontractid() const;
  void set_referencecontractid(::int32_t value);

  private:
  ::int32_t _internal_referencecontractid() const;
  void _internal_set_referencecontractid(::int32_t value);

  public:
  // optional double peggedChangeAmount = 89;
  bool has_peggedchangeamount() const;
  void clear_peggedchangeamount() ;
  double peggedchangeamount() const;
  void set_peggedchangeamount(double value);

  private:
  double _internal_peggedchangeamount() const;
  void _internal_set_peggedchangeamount(double value);

  public:
  // optional double referenceChangeAmount = 91;
  bool has_referencechangeamount() const;
  void clear_referencechangeamount() ;
  double referencechangeamount() const;
  void set_referencechangeamount(double value);

  private:
  double _internal_referencechangeamount() const;
  void _internal_set_referencechangeamount(double value);

  public:
  // optional double triggerPrice = 94;
  bool has_triggerprice() const;
  void clear_triggerprice() ;
  double triggerprice() const;
  void set_triggerprice(double value);

  private:
  double _internal_triggerprice() const;
  void _internal_set_triggerprice(double value);

  public:
  // optional double adjustedStopPrice = 95;
  bool has_adjustedstopprice() const;
  void clear_adjustedstopprice() ;
  double adjustedstopprice() const;
  void set_adjustedstopprice(double value);

  private:
  double _internal_adjustedstopprice() const;
  void _internal_set_adjustedstopprice(double value);

  public:
  // optional bool randomizePrice = 87;
  bool has_randomizeprice() const;
  void clear_randomizeprice() ;
  bool randomizeprice() const;
  void set_randomizeprice(bool value);

  private:
  bool _internal_randomizeprice() const;
  void _internal_set_randomizeprice(bool value);

  public:
  // optional bool isPeggedChangeAmountDecrease = 90;
  bool has_ispeggedchangeamountdecrease() const;
  void clear_ispeggedchangeamountdecrease() ;
  bool ispeggedchangeamountdecrease() const;
  void set_ispeggedchangeamountdecrease(bool value);

  private:
  bool _internal_ispeggedchangeamountdecrease() const;
  void _internal_set_ispeggedchangeamountdecrease(bool value);

  public:
  // optional bool conditionsCancelOrder = 101;
  bool has_conditionscancelorder() const;
  void clear_conditionscancelorder() ;
  bool conditionscancelorder() const;
  void set_conditionscancelorder(bool value);

  private:
  bool _internal_conditionscancelorder() const;
  void _internal_set_conditionscancelorder(bool value);

  public:
  // optional bool conditionsIgnoreRth = 102;
  bool has_conditionsignorerth() const;
  void clear_conditionsignorerth() ;
  bool conditionsignorerth() const;
  void set_conditionsignorerth(bool value);

  private:
  bool _internal_conditionsignorerth() const;
  void _internal_set_conditionsignorerth(bool value);

  public:
  // optional int32 adjustableTrailingUnit = 98;
  bool has_adjustabletrailingunit() const;
  void clear_adjustabletrailingunit() ;
  ::int32_t adjustabletrailingunit() const;
  void set_adjustabletrailingunit(::int32_t value);

  private:
  ::int32_t _internal_adjustabletrailingunit() const;
  void _internal_set_adjustabletrailingunit(::int32_t value);

  public:
  // optional double adjustedStopLimitPrice = 96;
  bool has_adjustedstoplimitprice() const;
  void clear_adjustedstoplimitprice() ;
  double adjustedstoplimitprice() const;
  void set_adjustedstoplimitprice(double value);

  private:
  double _internal_adjustedstoplimitprice() const;
  void _internal_set_adjustedstoplimitprice(double value);

  public:
  // optional double adjustedTrailingAmount = 97;
  bool has_adjustedtrailingamount() const;
  void clear_adjustedtrailingamount() ;
  double adjustedtrailingamount() const;
  void set_adjustedtrailingamount(double value);

  private:
  double _internal_adjustedtrailingamount() const;
  void _internal_set_adjustedtrailingamount(double value);

  public:
  // optional double lmtPriceOffset = 99;
  bool has_lmtpriceoffset() const;
  void clear_lmtpriceoffset() ;
  double lmtpriceoffset() const;
  void set_lmtpriceoffset(double value);

  private:
  double _internal_lmtpriceoffset() const;
  void _internal_set_lmtpriceoffset(double value);

  public:
  // optional double cashQty = 106;
  bool has_cashqty() const;
  void clear_cashqty() ;
  double cashqty() const;
  void set_cashqty(double value);

  private:
  double _internal_cashqty() const;
  void _internal_set_cashqty(double value);

  public:
  // optional bool dontUseAutoPriceForHedge = 111;
  bool has_dontuseautopriceforhedge() const;
  void clear_dontuseautopriceforhedge() ;
  bool dontuseautopriceforhedge() const;
  void set_dontuseautopriceforhedge(bool value);

  private:
  bool _internal_dontuseautopriceforhedge() const;
  void _internal_set_dontuseautopriceforhedge(bool value);

  public:
  // optional bool isOmsContainer = 112;
  bool has_isomscontainer() const;
  void clear_isomscontainer() ;
  bool isomscontainer() const;
  void set_isomscontainer(bool value);

  private:
  bool _internal_isomscontainer() const;
  void _internal_set_isomscontainer(bool value);

  public:
  // optional bool discretionaryUpToLimitPrice = 113;
  bool has_discretionaryuptolimitprice() const;
  void clear_discretionaryuptolimitprice() ;
  bool discretionaryuptolimitprice() const;
  void set_discretionaryuptolimitprice(bool value);

  private:
  bool _internal_discretionaryuptolimitprice() const;
  void _internal_set_discretionaryuptolimitprice(bool value);

  public:
  // optional bool autoCancelParent = 117;
  bool has_autocancelparent() const;
  void clear_autocancelparent() ;
  bool autocancelparent() const;
  void set_autocancelparent(bool value);

  private:
  bool _internal_autocancelparent() const;
  void _internal_set_autocancelparent(bool value);

  public:
  // optional int32 refFuturesConId = 116;
  bool has_reffuturesconid() const;
  void clear_reffuturesconid() ;
  ::int32_t reffuturesconid() const;
  void set_reffuturesconid(::int32_t value);

  private:
  ::int32_t _internal_reffuturesconid() const;
  void _internal_set_reffuturesconid(::int32_t value);

  public:
  // optional int64 parentPermId = 121;
  bool has_parentpermid() const;
  void clear_parentpermid() ;
  ::int64_t parentpermid() const;
  void set_parentpermid(::int64_t value);

  private:
  ::int64_t _internal_parentpermid() const;
  void _internal_set_parentpermid(::int64_t value);

  public:
  // optional int32 usePriceMgmtAlgo = 122;
  bool has_usepricemgmtalgo() const;
  void clear_usepricemgmtalgo() ;
  ::int32_t usepricemgmtalgo() const;
  void set_usepricemgmtalgo(::int32_t value);

  private:
  ::int32_t _internal_usepricemgmtalgo() const;
  void _internal_set_usepricemgmtalgo(::int32_t value);

  public:
  // optional int32 duration = 123;
  bool has_duration() const;
  void clear_duration() ;
  ::int32_t duration() const;
  void set_duration(::int32_t value);

  private:
  ::int32_t _internal_duration() const;
  void _internal_set_duration(::int32_t value);

  public:
  // optional int32 postToAts = 124;
  bool has_posttoats() const;
  void clear_posttoats() ;
  ::int32_t posttoats() const;
  void set_posttoats(::int32_t value);

  private:
  ::int32_t _internal_posttoats() const;
  void _internal_set_posttoats(::int32_t value);

  public:
  // optional bool imbalanceOnly = 119;
  bool has_imbalanceonly() const;
  void clear_imbalanceonly() ;
  bool imbalanceonly() const;
  void set_imbalanceonly(bool value);

  private:
  bool _internal_imbalanceonly() const;
  void _internal_set_imbalanceonly(bool value);

  public:
  // optional bool routeMarketableToBbo = 120;
  bool has_routemarketabletobbo() const;
  void clear_routemarketabletobbo() ;
  bool routemarketabletobbo() const;
  void set_routemarketabletobbo(bool value);

  private:
  bool _internal_routemarketabletobbo() const;
  void _internal_set_routemarketabletobbo(bool value);

  public:
  // optional bool professionalCustomer = 133;
  bool has_professionalcustomer() const;
  void clear_professionalcustomer() ;
  bool professionalcustomer() const;
  void set_professionalcustomer(bool value);

  private:
  bool _internal_professionalcustomer() const;
  void _internal_set_professionalcustomer(bool value);

  public:
  // optional bool includeOvernight = 135;
  bool has_includeovernight() const;
  void clear_includeovernight() ;
  bool includeovernight() const;
  void set_includeovernight(bool value);

  private:
  bool _internal_includeovernight() const;
  void _internal_set_includeovernight(bool value);

  public:
  // optional int32 minTradeQty = 127;
  bool has_mintradeqty() const;
  void clear_mintradeqty() ;
  ::int32_t mintradeqty() const;
  void set_mintradeqty(::int32_t value);

  private:
  ::int32_t _internal_mintradeqty() const;
  void _internal_set_mintradeqty(::int32_t value);

  public:
  // optional int32 minCompeteSize = 128;
  bool has_mincompetesize() const;
  void clear_mincompetesize() ;
  ::int32_t mincompetesize() const;
  void set_mincompetesize(::int32_t value);

  private:
  ::int32_t _internal_mincompetesize() const;
  void _internal_set_mincompetesize(::int32_t value);

  public:
  // optional double competeAgainstBestOffset = 129;
  bool has_competeagainstbestoffset() const;
  void clear_competeagainstbestoffset() ;
  double competeagainstbestoffset() const;
  void set_competeagainstbestoffset(double value);

  private:
  double _internal_competeagainstbestoffset() const;
  void _internal_set_competeagainstbestoffset(double value);

  public:
  // optional double midOffsetAtWhole = 130;
  bool has_midoffsetatwhole() const;
  void clear_midoffsetatwhole() ;
  double midoffsetatwhole() const;
  void set_midoffsetatwhole(double value);

  private:
  double _internal_midoffsetatwhole() const;
  void _internal_set_midoffsetatwhole(double value);

  public:
  // optional double midOffsetAtHalf = 131;
  bool has_midoffsetathalf() const;
  void clear_midoffsetathalf() ;
  double midoffsetathalf() const;
  void set_midoffsetathalf(double value);

  private:
  double _internal_midoffsetathalf() const;
  void _internal_set_midoffsetathalf(double value);

  public:
  // optional int32 manualOrderIndicator = 136;
  bool has_manualorderindicator() const;
  void clear_manualorderindicator() ;
  ::int32_t manualorderindicator() const;
  void set_manualorderindicator(::int32_t value);

  private:
  ::int32_t _internal_manualorderindicator() const;
  void _internal_set_manualorderindicator(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Order)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<5> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Order_AlgoParamsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> algoparams_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Order_SmartComboRoutingParamsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> smartcomboroutingparams_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Order_OrderMiscOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> ordermiscoptions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::OrderCondition > conditions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr totalquantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ordertype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tif_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlingfirm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clearingaccount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clearingintent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr goodaftertime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr goodtilldate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ocagroup_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule80a_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr activestarttime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr activestoptime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fagroup_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr famethod_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fapercentage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deltaneutralordertype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deltaneutralopenclose_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deltaneutraldesignatedlocation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scaletable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hedgetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hedgeparam_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algostrategy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algoid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr openclose_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr designatedlocation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deltaneutralsettlingfirm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deltaneutralclearingaccount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deltaneutralclearingintent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referenceexchangeid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adjustedordertype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extoperator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mifid2decisionmaker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mifid2decisionalgo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mifid2executiontrader_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mifid2executionalgo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr autocanceldate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filledquantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shareholder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr advancederroroverride_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manualordertime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customeraccount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bondaccruedinterest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr submitter_;
    ::protobuf::SoftDollarTier* softdollartier_;
    ::int32_t clientid_;
    ::int32_t orderid_;
    ::int64_t permid_;
    ::int32_t parentid_;
    ::int32_t displaysize_;
    double lmtprice_;
    double auxprice_;
    bool allornone_;
    bool blockorder_;
    bool hidden_;
    bool outsiderth_;
    ::int32_t minqty_;
    double percentoffset_;
    double trailingpercent_;
    double trailstopprice_;
    ::int32_t ocatype_;
    ::int32_t triggermethod_;
    double volatility_;
    ::int32_t volatilitytype_;
    bool sweeptofill_;
    bool continuousupdate_;
    bool deltaneutralshortsale_;
    bool scaleautoreset_;
    ::int32_t referencepricetype_;
    ::int32_t deltaneutralconid_;
    double deltaneutralauxprice_;
    ::int32_t deltaneutralshortsaleslot_;
    ::int32_t scaleinitlevelsize_;
    double scalepriceincrement_;
    ::int32_t scalesubslevelsize_;
    ::int32_t scalepriceadjustinterval_;
    double scalepriceadjustvalue_;
    double scaleprofitoffset_;
    ::int32_t scaleinitposition_;
    ::int32_t scaleinitfillqty_;
    bool scalerandompercent_;
    bool whatif_;
    bool transmit_;
    bool overridepercentageconstraints_;
    ::int32_t origin_;
    ::int32_t shortsaleslot_;
    ::int32_t exemptcode_;
    double discretionaryamt_;
    double startingprice_;
    double stockrefprice_;
    double delta_;
    double stockrangelower_;
    double stockrangeupper_;
    bool optoutsmartrouting_;
    bool notheld_;
    bool solicited_;
    bool randomizesize_;
    ::int32_t referencecontractid_;
    double peggedchangeamount_;
    double referencechangeamount_;
    double triggerprice_;
    double adjustedstopprice_;
    bool randomizeprice_;
    bool ispeggedchangeamountdecrease_;
    bool conditionscancelorder_;
    bool conditionsignorerth_;
    ::int32_t adjustabletrailingunit_;
    double adjustedstoplimitprice_;
    double adjustedtrailingamount_;
    double lmtpriceoffset_;
    double cashqty_;
    bool dontuseautopriceforhedge_;
    bool isomscontainer_;
    bool discretionaryuptolimitprice_;
    bool autocancelparent_;
    ::int32_t reffuturesconid_;
    ::int64_t parentpermid_;
    ::int32_t usepricemgmtalgo_;
    ::int32_t duration_;
    ::int32_t posttoats_;
    bool imbalanceonly_;
    bool routemarketabletobbo_;
    bool professionalcustomer_;
    bool includeovernight_;
    ::int32_t mintradeqty_;
    ::int32_t mincompetesize_;
    double competeagainstbestoffset_;
    double midoffsetatwhole_;
    double midoffsetathalf_;
    ::int32_t manualorderindicator_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Order_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Order

// optional int32 clientId = 1;
inline bool Order::has_clientid() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline void Order::clear_clientid() {
  _impl_.clientid_ = 0;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline ::int32_t Order::clientid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.clientId)
  return _internal_clientid();
}
inline void Order::set_clientid(::int32_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.clientId)
}
inline ::int32_t Order::_internal_clientid() const {
  return _impl_.clientid_;
}
inline void Order::_internal_set_clientid(::int32_t value) {
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.clientid_ = value;
}

// optional int32 orderId = 2;
inline bool Order::has_orderid() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline void Order::clear_orderid() {
  _impl_.orderid_ = 0;
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline ::int32_t Order::orderid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.orderId)
  return _internal_orderid();
}
inline void Order::set_orderid(::int32_t value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.orderId)
}
inline ::int32_t Order::_internal_orderid() const {
  return _impl_.orderid_;
}
inline void Order::_internal_set_orderid(::int32_t value) {
  _impl_._has_bits_[1] |= 0x00020000u;
  _impl_.orderid_ = value;
}

// optional int64 permId = 3;
inline bool Order::has_permid() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline void Order::clear_permid() {
  _impl_.permid_ = ::int64_t{0};
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline ::int64_t Order::permid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.permId)
  return _internal_permid();
}
inline void Order::set_permid(::int64_t value) {
  _internal_set_permid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.permId)
}
inline ::int64_t Order::_internal_permid() const {
  return _impl_.permid_;
}
inline void Order::_internal_set_permid(::int64_t value) {
  _impl_._has_bits_[1] |= 0x00040000u;
  _impl_.permid_ = value;
}

// optional int32 parentId = 4;
inline bool Order::has_parentid() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline void Order::clear_parentid() {
  _impl_.parentid_ = 0;
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline ::int32_t Order::parentid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.parentId)
  return _internal_parentid();
}
inline void Order::set_parentid(::int32_t value) {
  _internal_set_parentid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.parentId)
}
inline ::int32_t Order::_internal_parentid() const {
  return _impl_.parentid_;
}
inline void Order::_internal_set_parentid(::int32_t value) {
  _impl_._has_bits_[1] |= 0x00080000u;
  _impl_.parentid_ = value;
}

// optional string action = 5;
inline bool Order::has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Order::clear_action() {
  _impl_.action_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Order::action() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_action(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.action)
}
inline std::string* Order::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.action)
  return _s;
}
inline const std::string& Order::_internal_action() const {
  return _impl_.action_.Get();
}
inline void Order::_internal_set_action(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_action() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.action_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_action() {
  // @@protoc_insertion_point(field_release:protobuf.Order.action)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.action_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.action_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_action(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.action_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_.IsDefault()) {
          _impl_.action_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.action)
}

// optional string totalQuantity = 6;
inline bool Order::has_totalquantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Order::clear_totalquantity() {
  _impl_.totalquantity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Order::totalquantity() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.totalQuantity)
  return _internal_totalquantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_totalquantity(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.totalquantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.totalQuantity)
}
inline std::string* Order::mutable_totalquantity() {
  std::string* _s = _internal_mutable_totalquantity();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.totalQuantity)
  return _s;
}
inline const std::string& Order::_internal_totalquantity() const {
  return _impl_.totalquantity_.Get();
}
inline void Order::_internal_set_totalquantity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.totalquantity_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_totalquantity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.totalquantity_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_totalquantity() {
  // @@protoc_insertion_point(field_release:protobuf.Order.totalQuantity)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.totalquantity_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.totalquantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_totalquantity(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.totalquantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.totalquantity_.IsDefault()) {
          _impl_.totalquantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.totalQuantity)
}

// optional int32 displaySize = 7;
inline bool Order::has_displaysize() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline void Order::clear_displaysize() {
  _impl_.displaysize_ = 0;
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline ::int32_t Order::displaysize() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.displaySize)
  return _internal_displaysize();
}
inline void Order::set_displaysize(::int32_t value) {
  _internal_set_displaysize(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.displaySize)
}
inline ::int32_t Order::_internal_displaysize() const {
  return _impl_.displaysize_;
}
inline void Order::_internal_set_displaysize(::int32_t value) {
  _impl_._has_bits_[1] |= 0x00100000u;
  _impl_.displaysize_ = value;
}

// optional string orderType = 8;
inline bool Order::has_ordertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Order::clear_ordertype() {
  _impl_.ordertype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Order::ordertype() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.orderType)
  return _internal_ordertype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_ordertype(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ordertype_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.orderType)
}
inline std::string* Order::mutable_ordertype() {
  std::string* _s = _internal_mutable_ordertype();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.orderType)
  return _s;
}
inline const std::string& Order::_internal_ordertype() const {
  return _impl_.ordertype_.Get();
}
inline void Order::_internal_set_ordertype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.ordertype_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_ordertype() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ordertype_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_ordertype() {
  // @@protoc_insertion_point(field_release:protobuf.Order.orderType)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ordertype_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_ordertype(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ordertype_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ordertype_.IsDefault()) {
          _impl_.ordertype_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.orderType)
}

// optional double lmtPrice = 9;
inline bool Order::has_lmtprice() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline void Order::clear_lmtprice() {
  _impl_.lmtprice_ = 0;
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline double Order::lmtprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.lmtPrice)
  return _internal_lmtprice();
}
inline void Order::set_lmtprice(double value) {
  _internal_set_lmtprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.lmtPrice)
}
inline double Order::_internal_lmtprice() const {
  return _impl_.lmtprice_;
}
inline void Order::_internal_set_lmtprice(double value) {
  _impl_._has_bits_[1] |= 0x00200000u;
  _impl_.lmtprice_ = value;
}

// optional double auxPrice = 10;
inline bool Order::has_auxprice() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline void Order::clear_auxprice() {
  _impl_.auxprice_ = 0;
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline double Order::auxprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.auxPrice)
  return _internal_auxprice();
}
inline void Order::set_auxprice(double value) {
  _internal_set_auxprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.auxPrice)
}
inline double Order::_internal_auxprice() const {
  return _impl_.auxprice_;
}
inline void Order::_internal_set_auxprice(double value) {
  _impl_._has_bits_[1] |= 0x00400000u;
  _impl_.auxprice_ = value;
}

// optional string tif = 11;
inline bool Order::has_tif() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Order::clear_tif() {
  _impl_.tif_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Order::tif() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.tif)
  return _internal_tif();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_tif(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tif_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.tif)
}
inline std::string* Order::mutable_tif() {
  std::string* _s = _internal_mutable_tif();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.tif)
  return _s;
}
inline const std::string& Order::_internal_tif() const {
  return _impl_.tif_.Get();
}
inline void Order::_internal_set_tif(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.tif_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_tif() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tif_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_tif() {
  // @@protoc_insertion_point(field_release:protobuf.Order.tif)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.tif_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tif_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_tif(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tif_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tif_.IsDefault()) {
          _impl_.tif_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.tif)
}

// optional string account = 12;
inline bool Order::has_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Order::clear_account() {
  _impl_.account_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Order::account() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_account(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.account)
}
inline std::string* Order::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.account)
  return _s;
}
inline const std::string& Order::_internal_account() const {
  return _impl_.account_.Get();
}
inline void Order::_internal_set_account(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_account() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_account() {
  // @@protoc_insertion_point(field_release:protobuf.Order.account)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.account_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_account(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.account)
}

// optional string settlingFirm = 13;
inline bool Order::has_settlingfirm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Order::clear_settlingfirm() {
  _impl_.settlingfirm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Order::settlingfirm() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.settlingFirm)
  return _internal_settlingfirm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_settlingfirm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.settlingfirm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.settlingFirm)
}
inline std::string* Order::mutable_settlingfirm() {
  std::string* _s = _internal_mutable_settlingfirm();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.settlingFirm)
  return _s;
}
inline const std::string& Order::_internal_settlingfirm() const {
  return _impl_.settlingfirm_.Get();
}
inline void Order::_internal_set_settlingfirm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;


  _impl_.settlingfirm_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_settlingfirm() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.settlingfirm_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_settlingfirm() {
  // @@protoc_insertion_point(field_release:protobuf.Order.settlingFirm)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.settlingfirm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settlingfirm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_settlingfirm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.settlingfirm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlingfirm_.IsDefault()) {
          _impl_.settlingfirm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.settlingFirm)
}

// optional string clearingAccount = 14;
inline bool Order::has_clearingaccount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Order::clear_clearingaccount() {
  _impl_.clearingaccount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Order::clearingaccount() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.clearingAccount)
  return _internal_clearingaccount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_clearingaccount(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.clearingaccount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.clearingAccount)
}
inline std::string* Order::mutable_clearingaccount() {
  std::string* _s = _internal_mutable_clearingaccount();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.clearingAccount)
  return _s;
}
inline const std::string& Order::_internal_clearingaccount() const {
  return _impl_.clearingaccount_.Get();
}
inline void Order::_internal_set_clearingaccount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;


  _impl_.clearingaccount_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_clearingaccount() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.clearingaccount_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_clearingaccount() {
  // @@protoc_insertion_point(field_release:protobuf.Order.clearingAccount)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.clearingaccount_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.clearingaccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_clearingaccount(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.clearingaccount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clearingaccount_.IsDefault()) {
          _impl_.clearingaccount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.clearingAccount)
}

// optional string clearingIntent = 15;
inline bool Order::has_clearingintent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Order::clear_clearingintent() {
  _impl_.clearingintent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& Order::clearingintent() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.clearingIntent)
  return _internal_clearingintent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_clearingintent(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.clearingintent_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.clearingIntent)
}
inline std::string* Order::mutable_clearingintent() {
  std::string* _s = _internal_mutable_clearingintent();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.clearingIntent)
  return _s;
}
inline const std::string& Order::_internal_clearingintent() const {
  return _impl_.clearingintent_.Get();
}
inline void Order::_internal_set_clearingintent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;


  _impl_.clearingintent_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_clearingintent() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.clearingintent_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_clearingintent() {
  // @@protoc_insertion_point(field_release:protobuf.Order.clearingIntent)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.clearingintent_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.clearingintent_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_clearingintent(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.clearingintent_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clearingintent_.IsDefault()) {
          _impl_.clearingintent_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.clearingIntent)
}

// optional bool allOrNone = 16;
inline bool Order::has_allornone() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline void Order::clear_allornone() {
  _impl_.allornone_ = false;
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline bool Order::allornone() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.allOrNone)
  return _internal_allornone();
}
inline void Order::set_allornone(bool value) {
  _internal_set_allornone(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.allOrNone)
}
inline bool Order::_internal_allornone() const {
  return _impl_.allornone_;
}
inline void Order::_internal_set_allornone(bool value) {
  _impl_._has_bits_[1] |= 0x00800000u;
  _impl_.allornone_ = value;
}

// optional bool blockOrder = 17;
inline bool Order::has_blockorder() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline void Order::clear_blockorder() {
  _impl_.blockorder_ = false;
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline bool Order::blockorder() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.blockOrder)
  return _internal_blockorder();
}
inline void Order::set_blockorder(bool value) {
  _internal_set_blockorder(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.blockOrder)
}
inline bool Order::_internal_blockorder() const {
  return _impl_.blockorder_;
}
inline void Order::_internal_set_blockorder(bool value) {
  _impl_._has_bits_[1] |= 0x01000000u;
  _impl_.blockorder_ = value;
}

// optional bool hidden = 18;
inline bool Order::has_hidden() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline void Order::clear_hidden() {
  _impl_.hidden_ = false;
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline bool Order::hidden() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.hidden)
  return _internal_hidden();
}
inline void Order::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.hidden)
}
inline bool Order::_internal_hidden() const {
  return _impl_.hidden_;
}
inline void Order::_internal_set_hidden(bool value) {
  _impl_._has_bits_[1] |= 0x02000000u;
  _impl_.hidden_ = value;
}

// optional bool outsideRth = 19;
inline bool Order::has_outsiderth() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline void Order::clear_outsiderth() {
  _impl_.outsiderth_ = false;
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline bool Order::outsiderth() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.outsideRth)
  return _internal_outsiderth();
}
inline void Order::set_outsiderth(bool value) {
  _internal_set_outsiderth(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.outsideRth)
}
inline bool Order::_internal_outsiderth() const {
  return _impl_.outsiderth_;
}
inline void Order::_internal_set_outsiderth(bool value) {
  _impl_._has_bits_[1] |= 0x04000000u;
  _impl_.outsiderth_ = value;
}

// optional bool sweepToFill = 20;
inline bool Order::has_sweeptofill() const {
  bool value = (_impl_._has_bits_[2] & 0x00000008u) != 0;
  return value;
}
inline void Order::clear_sweeptofill() {
  _impl_.sweeptofill_ = false;
  _impl_._has_bits_[2] &= ~0x00000008u;
}
inline bool Order::sweeptofill() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.sweepToFill)
  return _internal_sweeptofill();
}
inline void Order::set_sweeptofill(bool value) {
  _internal_set_sweeptofill(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.sweepToFill)
}
inline bool Order::_internal_sweeptofill() const {
  return _impl_.sweeptofill_;
}
inline void Order::_internal_set_sweeptofill(bool value) {
  _impl_._has_bits_[2] |= 0x00000008u;
  _impl_.sweeptofill_ = value;
}

// optional double percentOffset = 21;
inline bool Order::has_percentoffset() const {
  bool value = (_impl_._has_bits_[1] & 0x10000000u) != 0;
  return value;
}
inline void Order::clear_percentoffset() {
  _impl_.percentoffset_ = 0;
  _impl_._has_bits_[1] &= ~0x10000000u;
}
inline double Order::percentoffset() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.percentOffset)
  return _internal_percentoffset();
}
inline void Order::set_percentoffset(double value) {
  _internal_set_percentoffset(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.percentOffset)
}
inline double Order::_internal_percentoffset() const {
  return _impl_.percentoffset_;
}
inline void Order::_internal_set_percentoffset(double value) {
  _impl_._has_bits_[1] |= 0x10000000u;
  _impl_.percentoffset_ = value;
}

// optional double trailingPercent = 22;
inline bool Order::has_trailingpercent() const {
  bool value = (_impl_._has_bits_[1] & 0x20000000u) != 0;
  return value;
}
inline void Order::clear_trailingpercent() {
  _impl_.trailingpercent_ = 0;
  _impl_._has_bits_[1] &= ~0x20000000u;
}
inline double Order::trailingpercent() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.trailingPercent)
  return _internal_trailingpercent();
}
inline void Order::set_trailingpercent(double value) {
  _internal_set_trailingpercent(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.trailingPercent)
}
inline double Order::_internal_trailingpercent() const {
  return _impl_.trailingpercent_;
}
inline void Order::_internal_set_trailingpercent(double value) {
  _impl_._has_bits_[1] |= 0x20000000u;
  _impl_.trailingpercent_ = value;
}

// optional double trailStopPrice = 23;
inline bool Order::has_trailstopprice() const {
  bool value = (_impl_._has_bits_[1] & 0x40000000u) != 0;
  return value;
}
inline void Order::clear_trailstopprice() {
  _impl_.trailstopprice_ = 0;
  _impl_._has_bits_[1] &= ~0x40000000u;
}
inline double Order::trailstopprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.trailStopPrice)
  return _internal_trailstopprice();
}
inline void Order::set_trailstopprice(double value) {
  _internal_set_trailstopprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.trailStopPrice)
}
inline double Order::_internal_trailstopprice() const {
  return _impl_.trailstopprice_;
}
inline void Order::_internal_set_trailstopprice(double value) {
  _impl_._has_bits_[1] |= 0x40000000u;
  _impl_.trailstopprice_ = value;
}

// optional int32 minQty = 24;
inline bool Order::has_minqty() const {
  bool value = (_impl_._has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline void Order::clear_minqty() {
  _impl_.minqty_ = 0;
  _impl_._has_bits_[1] &= ~0x08000000u;
}
inline ::int32_t Order::minqty() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.minQty)
  return _internal_minqty();
}
inline void Order::set_minqty(::int32_t value) {
  _internal_set_minqty(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.minQty)
}
inline ::int32_t Order::_internal_minqty() const {
  return _impl_.minqty_;
}
inline void Order::_internal_set_minqty(::int32_t value) {
  _impl_._has_bits_[1] |= 0x08000000u;
  _impl_.minqty_ = value;
}

// optional string goodAfterTime = 25;
inline bool Order::has_goodaftertime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void Order::clear_goodaftertime() {
  _impl_.goodaftertime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& Order::goodaftertime() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.goodAfterTime)
  return _internal_goodaftertime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_goodaftertime(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.goodaftertime_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.goodAfterTime)
}
inline std::string* Order::mutable_goodaftertime() {
  std::string* _s = _internal_mutable_goodaftertime();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.goodAfterTime)
  return _s;
}
inline const std::string& Order::_internal_goodaftertime() const {
  return _impl_.goodaftertime_.Get();
}
inline void Order::_internal_set_goodaftertime(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;


  _impl_.goodaftertime_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_goodaftertime() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.goodaftertime_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_goodaftertime() {
  // @@protoc_insertion_point(field_release:protobuf.Order.goodAfterTime)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.goodaftertime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.goodaftertime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_goodaftertime(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.goodaftertime_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.goodaftertime_.IsDefault()) {
          _impl_.goodaftertime_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.goodAfterTime)
}

// optional string goodTillDate = 26;
inline bool Order::has_goodtilldate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void Order::clear_goodtilldate() {
  _impl_.goodtilldate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& Order::goodtilldate() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.goodTillDate)
  return _internal_goodtilldate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_goodtilldate(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.goodtilldate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.goodTillDate)
}
inline std::string* Order::mutable_goodtilldate() {
  std::string* _s = _internal_mutable_goodtilldate();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.goodTillDate)
  return _s;
}
inline const std::string& Order::_internal_goodtilldate() const {
  return _impl_.goodtilldate_.Get();
}
inline void Order::_internal_set_goodtilldate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;


  _impl_.goodtilldate_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_goodtilldate() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.goodtilldate_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_goodtilldate() {
  // @@protoc_insertion_point(field_release:protobuf.Order.goodTillDate)
  if ((_impl_._has_bits_[0] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* released = _impl_.goodtilldate_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.goodtilldate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_goodtilldate(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.goodtilldate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.goodtilldate_.IsDefault()) {
          _impl_.goodtilldate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.goodTillDate)
}

// optional string ocaGroup = 27;
inline bool Order::has_ocagroup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void Order::clear_ocagroup() {
  _impl_.ocagroup_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& Order::ocagroup() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.ocaGroup)
  return _internal_ocagroup();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_ocagroup(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ocagroup_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.ocaGroup)
}
inline std::string* Order::mutable_ocagroup() {
  std::string* _s = _internal_mutable_ocagroup();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.ocaGroup)
  return _s;
}
inline const std::string& Order::_internal_ocagroup() const {
  return _impl_.ocagroup_.Get();
}
inline void Order::_internal_set_ocagroup(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;


  _impl_.ocagroup_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_ocagroup() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.ocagroup_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_ocagroup() {
  // @@protoc_insertion_point(field_release:protobuf.Order.ocaGroup)
  if ((_impl_._has_bits_[0] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* released = _impl_.ocagroup_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ocagroup_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_ocagroup(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.ocagroup_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ocagroup_.IsDefault()) {
          _impl_.ocagroup_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.ocaGroup)
}

// optional string orderRef = 28;
inline bool Order::has_orderref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void Order::clear_orderref() {
  _impl_.orderref_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& Order::orderref() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.orderRef)
  return _internal_orderref();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_orderref(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.orderref_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.orderRef)
}
inline std::string* Order::mutable_orderref() {
  std::string* _s = _internal_mutable_orderref();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.orderRef)
  return _s;
}
inline const std::string& Order::_internal_orderref() const {
  return _impl_.orderref_.Get();
}
inline void Order::_internal_set_orderref(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;


  _impl_.orderref_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_orderref() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.orderref_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_orderref() {
  // @@protoc_insertion_point(field_release:protobuf.Order.orderRef)
  if ((_impl_._has_bits_[0] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* released = _impl_.orderref_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.orderref_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_orderref(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.orderref_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orderref_.IsDefault()) {
          _impl_.orderref_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.orderRef)
}

// optional string rule80A = 29;
inline bool Order::has_rule80a() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void Order::clear_rule80a() {
  _impl_.rule80a_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& Order::rule80a() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.rule80A)
  return _internal_rule80a();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_rule80a(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.rule80a_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.rule80A)
}
inline std::string* Order::mutable_rule80a() {
  std::string* _s = _internal_mutable_rule80a();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.rule80A)
  return _s;
}
inline const std::string& Order::_internal_rule80a() const {
  return _impl_.rule80a_.Get();
}
inline void Order::_internal_set_rule80a(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;


  _impl_.rule80a_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_rule80a() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.rule80a_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_rule80a() {
  // @@protoc_insertion_point(field_release:protobuf.Order.rule80A)
  if ((_impl_._has_bits_[0] & 0x00001000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* released = _impl_.rule80a_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rule80a_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_rule80a(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.rule80a_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule80a_.IsDefault()) {
          _impl_.rule80a_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.rule80A)
}

// optional int32 ocaType = 30;
inline bool Order::has_ocatype() const {
  bool value = (_impl_._has_bits_[1] & 0x80000000u) != 0;
  return value;
}
inline void Order::clear_ocatype() {
  _impl_.ocatype_ = 0;
  _impl_._has_bits_[1] &= ~0x80000000u;
}
inline ::int32_t Order::ocatype() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.ocaType)
  return _internal_ocatype();
}
inline void Order::set_ocatype(::int32_t value) {
  _internal_set_ocatype(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.ocaType)
}
inline ::int32_t Order::_internal_ocatype() const {
  return _impl_.ocatype_;
}
inline void Order::_internal_set_ocatype(::int32_t value) {
  _impl_._has_bits_[1] |= 0x80000000u;
  _impl_.ocatype_ = value;
}

// optional int32 triggerMethod = 31;
inline bool Order::has_triggermethod() const {
  bool value = (_impl_._has_bits_[2] & 0x00000001u) != 0;
  return value;
}
inline void Order::clear_triggermethod() {
  _impl_.triggermethod_ = 0;
  _impl_._has_bits_[2] &= ~0x00000001u;
}
inline ::int32_t Order::triggermethod() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.triggerMethod)
  return _internal_triggermethod();
}
inline void Order::set_triggermethod(::int32_t value) {
  _internal_set_triggermethod(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.triggerMethod)
}
inline ::int32_t Order::_internal_triggermethod() const {
  return _impl_.triggermethod_;
}
inline void Order::_internal_set_triggermethod(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00000001u;
  _impl_.triggermethod_ = value;
}

// optional string activeStartTime = 32;
inline bool Order::has_activestarttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void Order::clear_activestarttime() {
  _impl_.activestarttime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& Order::activestarttime() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.activeStartTime)
  return _internal_activestarttime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_activestarttime(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.activestarttime_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.activeStartTime)
}
inline std::string* Order::mutable_activestarttime() {
  std::string* _s = _internal_mutable_activestarttime();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.activeStartTime)
  return _s;
}
inline const std::string& Order::_internal_activestarttime() const {
  return _impl_.activestarttime_.Get();
}
inline void Order::_internal_set_activestarttime(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;


  _impl_.activestarttime_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_activestarttime() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.activestarttime_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_activestarttime() {
  // @@protoc_insertion_point(field_release:protobuf.Order.activeStartTime)
  if ((_impl_._has_bits_[0] & 0x00002000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* released = _impl_.activestarttime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.activestarttime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_activestarttime(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.activestarttime_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.activestarttime_.IsDefault()) {
          _impl_.activestarttime_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.activeStartTime)
}

// optional string activeStopTime = 33;
inline bool Order::has_activestoptime() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void Order::clear_activestoptime() {
  _impl_.activestoptime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& Order::activestoptime() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.activeStopTime)
  return _internal_activestoptime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_activestoptime(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.activestoptime_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.activeStopTime)
}
inline std::string* Order::mutable_activestoptime() {
  std::string* _s = _internal_mutable_activestoptime();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.activeStopTime)
  return _s;
}
inline const std::string& Order::_internal_activestoptime() const {
  return _impl_.activestoptime_.Get();
}
inline void Order::_internal_set_activestoptime(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;


  _impl_.activestoptime_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_activestoptime() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.activestoptime_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_activestoptime() {
  // @@protoc_insertion_point(field_release:protobuf.Order.activeStopTime)
  if ((_impl_._has_bits_[0] & 0x00004000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* released = _impl_.activestoptime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.activestoptime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_activestoptime(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.activestoptime_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.activestoptime_.IsDefault()) {
          _impl_.activestoptime_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.activeStopTime)
}

// optional string faGroup = 34;
inline bool Order::has_fagroup() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void Order::clear_fagroup() {
  _impl_.fagroup_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& Order::fagroup() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.faGroup)
  return _internal_fagroup();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_fagroup(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.fagroup_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.faGroup)
}
inline std::string* Order::mutable_fagroup() {
  std::string* _s = _internal_mutable_fagroup();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.faGroup)
  return _s;
}
inline const std::string& Order::_internal_fagroup() const {
  return _impl_.fagroup_.Get();
}
inline void Order::_internal_set_fagroup(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00008000u;


  _impl_.fagroup_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_fagroup() {
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.fagroup_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_fagroup() {
  // @@protoc_insertion_point(field_release:protobuf.Order.faGroup)
  if ((_impl_._has_bits_[0] & 0x00008000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* released = _impl_.fagroup_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fagroup_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_fagroup(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.fagroup_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fagroup_.IsDefault()) {
          _impl_.fagroup_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.faGroup)
}

// optional string faMethod = 35;
inline bool Order::has_famethod() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void Order::clear_famethod() {
  _impl_.famethod_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& Order::famethod() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.faMethod)
  return _internal_famethod();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_famethod(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.famethod_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.faMethod)
}
inline std::string* Order::mutable_famethod() {
  std::string* _s = _internal_mutable_famethod();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.faMethod)
  return _s;
}
inline const std::string& Order::_internal_famethod() const {
  return _impl_.famethod_.Get();
}
inline void Order::_internal_set_famethod(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00010000u;


  _impl_.famethod_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_famethod() {
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.famethod_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_famethod() {
  // @@protoc_insertion_point(field_release:protobuf.Order.faMethod)
  if ((_impl_._has_bits_[0] & 0x00010000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* released = _impl_.famethod_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.famethod_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_famethod(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.famethod_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.famethod_.IsDefault()) {
          _impl_.famethod_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.faMethod)
}

// optional string faPercentage = 36;
inline bool Order::has_fapercentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void Order::clear_fapercentage() {
  _impl_.fapercentage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& Order::fapercentage() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.faPercentage)
  return _internal_fapercentage();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_fapercentage(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.fapercentage_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.faPercentage)
}
inline std::string* Order::mutable_fapercentage() {
  std::string* _s = _internal_mutable_fapercentage();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.faPercentage)
  return _s;
}
inline const std::string& Order::_internal_fapercentage() const {
  return _impl_.fapercentage_.Get();
}
inline void Order::_internal_set_fapercentage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00020000u;


  _impl_.fapercentage_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_fapercentage() {
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.fapercentage_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_fapercentage() {
  // @@protoc_insertion_point(field_release:protobuf.Order.faPercentage)
  if ((_impl_._has_bits_[0] & 0x00020000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* released = _impl_.fapercentage_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fapercentage_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_fapercentage(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.fapercentage_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fapercentage_.IsDefault()) {
          _impl_.fapercentage_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.faPercentage)
}

// optional double volatility = 37;
inline bool Order::has_volatility() const {
  bool value = (_impl_._has_bits_[2] & 0x00000002u) != 0;
  return value;
}
inline void Order::clear_volatility() {
  _impl_.volatility_ = 0;
  _impl_._has_bits_[2] &= ~0x00000002u;
}
inline double Order::volatility() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.volatility)
  return _internal_volatility();
}
inline void Order::set_volatility(double value) {
  _internal_set_volatility(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.volatility)
}
inline double Order::_internal_volatility() const {
  return _impl_.volatility_;
}
inline void Order::_internal_set_volatility(double value) {
  _impl_._has_bits_[2] |= 0x00000002u;
  _impl_.volatility_ = value;
}

// optional int32 volatilityType = 38;
inline bool Order::has_volatilitytype() const {
  bool value = (_impl_._has_bits_[2] & 0x00000004u) != 0;
  return value;
}
inline void Order::clear_volatilitytype() {
  _impl_.volatilitytype_ = 0;
  _impl_._has_bits_[2] &= ~0x00000004u;
}
inline ::int32_t Order::volatilitytype() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.volatilityType)
  return _internal_volatilitytype();
}
inline void Order::set_volatilitytype(::int32_t value) {
  _internal_set_volatilitytype(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.volatilityType)
}
inline ::int32_t Order::_internal_volatilitytype() const {
  return _impl_.volatilitytype_;
}
inline void Order::_internal_set_volatilitytype(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00000004u;
  _impl_.volatilitytype_ = value;
}

// optional bool continuousUpdate = 39;
inline bool Order::has_continuousupdate() const {
  bool value = (_impl_._has_bits_[2] & 0x00000010u) != 0;
  return value;
}
inline void Order::clear_continuousupdate() {
  _impl_.continuousupdate_ = false;
  _impl_._has_bits_[2] &= ~0x00000010u;
}
inline bool Order::continuousupdate() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.continuousUpdate)
  return _internal_continuousupdate();
}
inline void Order::set_continuousupdate(bool value) {
  _internal_set_continuousupdate(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.continuousUpdate)
}
inline bool Order::_internal_continuousupdate() const {
  return _impl_.continuousupdate_;
}
inline void Order::_internal_set_continuousupdate(bool value) {
  _impl_._has_bits_[2] |= 0x00000010u;
  _impl_.continuousupdate_ = value;
}

// optional int32 referencePriceType = 40;
inline bool Order::has_referencepricetype() const {
  bool value = (_impl_._has_bits_[2] & 0x00000080u) != 0;
  return value;
}
inline void Order::clear_referencepricetype() {
  _impl_.referencepricetype_ = 0;
  _impl_._has_bits_[2] &= ~0x00000080u;
}
inline ::int32_t Order::referencepricetype() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.referencePriceType)
  return _internal_referencepricetype();
}
inline void Order::set_referencepricetype(::int32_t value) {
  _internal_set_referencepricetype(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.referencePriceType)
}
inline ::int32_t Order::_internal_referencepricetype() const {
  return _impl_.referencepricetype_;
}
inline void Order::_internal_set_referencepricetype(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00000080u;
  _impl_.referencepricetype_ = value;
}

// optional string deltaNeutralOrderType = 41;
inline bool Order::has_deltaneutralordertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void Order::clear_deltaneutralordertype() {
  _impl_.deltaneutralordertype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const std::string& Order::deltaneutralordertype() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralOrderType)
  return _internal_deltaneutralordertype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_deltaneutralordertype(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.deltaneutralordertype_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralOrderType)
}
inline std::string* Order::mutable_deltaneutralordertype() {
  std::string* _s = _internal_mutable_deltaneutralordertype();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.deltaNeutralOrderType)
  return _s;
}
inline const std::string& Order::_internal_deltaneutralordertype() const {
  return _impl_.deltaneutralordertype_.Get();
}
inline void Order::_internal_set_deltaneutralordertype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00040000u;


  _impl_.deltaneutralordertype_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_deltaneutralordertype() {
  _impl_._has_bits_[0] |= 0x00040000u;
  return _impl_.deltaneutralordertype_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_deltaneutralordertype() {
  // @@protoc_insertion_point(field_release:protobuf.Order.deltaNeutralOrderType)
  if ((_impl_._has_bits_[0] & 0x00040000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00040000u;
  auto* released = _impl_.deltaneutralordertype_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_deltaneutralordertype(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.deltaneutralordertype_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deltaneutralordertype_.IsDefault()) {
          _impl_.deltaneutralordertype_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.deltaNeutralOrderType)
}

// optional double deltaNeutralAuxPrice = 42;
inline bool Order::has_deltaneutralauxprice() const {
  bool value = (_impl_._has_bits_[2] & 0x00000200u) != 0;
  return value;
}
inline void Order::clear_deltaneutralauxprice() {
  _impl_.deltaneutralauxprice_ = 0;
  _impl_._has_bits_[2] &= ~0x00000200u;
}
inline double Order::deltaneutralauxprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralAuxPrice)
  return _internal_deltaneutralauxprice();
}
inline void Order::set_deltaneutralauxprice(double value) {
  _internal_set_deltaneutralauxprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralAuxPrice)
}
inline double Order::_internal_deltaneutralauxprice() const {
  return _impl_.deltaneutralauxprice_;
}
inline void Order::_internal_set_deltaneutralauxprice(double value) {
  _impl_._has_bits_[2] |= 0x00000200u;
  _impl_.deltaneutralauxprice_ = value;
}

// optional int32 deltaNeutralConId = 43;
inline bool Order::has_deltaneutralconid() const {
  bool value = (_impl_._has_bits_[2] & 0x00000100u) != 0;
  return value;
}
inline void Order::clear_deltaneutralconid() {
  _impl_.deltaneutralconid_ = 0;
  _impl_._has_bits_[2] &= ~0x00000100u;
}
inline ::int32_t Order::deltaneutralconid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralConId)
  return _internal_deltaneutralconid();
}
inline void Order::set_deltaneutralconid(::int32_t value) {
  _internal_set_deltaneutralconid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralConId)
}
inline ::int32_t Order::_internal_deltaneutralconid() const {
  return _impl_.deltaneutralconid_;
}
inline void Order::_internal_set_deltaneutralconid(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00000100u;
  _impl_.deltaneutralconid_ = value;
}

// optional string deltaNeutralOpenClose = 44;
inline bool Order::has_deltaneutralopenclose() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void Order::clear_deltaneutralopenclose() {
  _impl_.deltaneutralopenclose_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const std::string& Order::deltaneutralopenclose() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralOpenClose)
  return _internal_deltaneutralopenclose();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_deltaneutralopenclose(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.deltaneutralopenclose_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralOpenClose)
}
inline std::string* Order::mutable_deltaneutralopenclose() {
  std::string* _s = _internal_mutable_deltaneutralopenclose();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.deltaNeutralOpenClose)
  return _s;
}
inline const std::string& Order::_internal_deltaneutralopenclose() const {
  return _impl_.deltaneutralopenclose_.Get();
}
inline void Order::_internal_set_deltaneutralopenclose(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00080000u;


  _impl_.deltaneutralopenclose_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_deltaneutralopenclose() {
  _impl_._has_bits_[0] |= 0x00080000u;
  return _impl_.deltaneutralopenclose_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_deltaneutralopenclose() {
  // @@protoc_insertion_point(field_release:protobuf.Order.deltaNeutralOpenClose)
  if ((_impl_._has_bits_[0] & 0x00080000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00080000u;
  auto* released = _impl_.deltaneutralopenclose_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralopenclose_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_deltaneutralopenclose(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.deltaneutralopenclose_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deltaneutralopenclose_.IsDefault()) {
          _impl_.deltaneutralopenclose_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.deltaNeutralOpenClose)
}

// optional bool deltaNeutralShortSale = 45;
inline bool Order::has_deltaneutralshortsale() const {
  bool value = (_impl_._has_bits_[2] & 0x00000020u) != 0;
  return value;
}
inline void Order::clear_deltaneutralshortsale() {
  _impl_.deltaneutralshortsale_ = false;
  _impl_._has_bits_[2] &= ~0x00000020u;
}
inline bool Order::deltaneutralshortsale() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralShortSale)
  return _internal_deltaneutralshortsale();
}
inline void Order::set_deltaneutralshortsale(bool value) {
  _internal_set_deltaneutralshortsale(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralShortSale)
}
inline bool Order::_internal_deltaneutralshortsale() const {
  return _impl_.deltaneutralshortsale_;
}
inline void Order::_internal_set_deltaneutralshortsale(bool value) {
  _impl_._has_bits_[2] |= 0x00000020u;
  _impl_.deltaneutralshortsale_ = value;
}

// optional int32 deltaNeutralShortSaleSlot = 46;
inline bool Order::has_deltaneutralshortsaleslot() const {
  bool value = (_impl_._has_bits_[2] & 0x00000400u) != 0;
  return value;
}
inline void Order::clear_deltaneutralshortsaleslot() {
  _impl_.deltaneutralshortsaleslot_ = 0;
  _impl_._has_bits_[2] &= ~0x00000400u;
}
inline ::int32_t Order::deltaneutralshortsaleslot() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralShortSaleSlot)
  return _internal_deltaneutralshortsaleslot();
}
inline void Order::set_deltaneutralshortsaleslot(::int32_t value) {
  _internal_set_deltaneutralshortsaleslot(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralShortSaleSlot)
}
inline ::int32_t Order::_internal_deltaneutralshortsaleslot() const {
  return _impl_.deltaneutralshortsaleslot_;
}
inline void Order::_internal_set_deltaneutralshortsaleslot(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00000400u;
  _impl_.deltaneutralshortsaleslot_ = value;
}

// optional string deltaNeutralDesignatedLocation = 47;
inline bool Order::has_deltaneutraldesignatedlocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void Order::clear_deltaneutraldesignatedlocation() {
  _impl_.deltaneutraldesignatedlocation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const std::string& Order::deltaneutraldesignatedlocation() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralDesignatedLocation)
  return _internal_deltaneutraldesignatedlocation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_deltaneutraldesignatedlocation(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.deltaneutraldesignatedlocation_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralDesignatedLocation)
}
inline std::string* Order::mutable_deltaneutraldesignatedlocation() {
  std::string* _s = _internal_mutable_deltaneutraldesignatedlocation();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.deltaNeutralDesignatedLocation)
  return _s;
}
inline const std::string& Order::_internal_deltaneutraldesignatedlocation() const {
  return _impl_.deltaneutraldesignatedlocation_.Get();
}
inline void Order::_internal_set_deltaneutraldesignatedlocation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00100000u;


  _impl_.deltaneutraldesignatedlocation_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_deltaneutraldesignatedlocation() {
  _impl_._has_bits_[0] |= 0x00100000u;
  return _impl_.deltaneutraldesignatedlocation_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_deltaneutraldesignatedlocation() {
  // @@protoc_insertion_point(field_release:protobuf.Order.deltaNeutralDesignatedLocation)
  if ((_impl_._has_bits_[0] & 0x00100000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00100000u;
  auto* released = _impl_.deltaneutraldesignatedlocation_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutraldesignatedlocation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_deltaneutraldesignatedlocation(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.deltaneutraldesignatedlocation_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deltaneutraldesignatedlocation_.IsDefault()) {
          _impl_.deltaneutraldesignatedlocation_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.deltaNeutralDesignatedLocation)
}

// optional int32 scaleInitLevelSize = 48;
inline bool Order::has_scaleinitlevelsize() const {
  bool value = (_impl_._has_bits_[2] & 0x00000800u) != 0;
  return value;
}
inline void Order::clear_scaleinitlevelsize() {
  _impl_.scaleinitlevelsize_ = 0;
  _impl_._has_bits_[2] &= ~0x00000800u;
}
inline ::int32_t Order::scaleinitlevelsize() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleInitLevelSize)
  return _internal_scaleinitlevelsize();
}
inline void Order::set_scaleinitlevelsize(::int32_t value) {
  _internal_set_scaleinitlevelsize(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleInitLevelSize)
}
inline ::int32_t Order::_internal_scaleinitlevelsize() const {
  return _impl_.scaleinitlevelsize_;
}
inline void Order::_internal_set_scaleinitlevelsize(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00000800u;
  _impl_.scaleinitlevelsize_ = value;
}

// optional int32 scaleSubsLevelSize = 49;
inline bool Order::has_scalesubslevelsize() const {
  bool value = (_impl_._has_bits_[2] & 0x00002000u) != 0;
  return value;
}
inline void Order::clear_scalesubslevelsize() {
  _impl_.scalesubslevelsize_ = 0;
  _impl_._has_bits_[2] &= ~0x00002000u;
}
inline ::int32_t Order::scalesubslevelsize() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleSubsLevelSize)
  return _internal_scalesubslevelsize();
}
inline void Order::set_scalesubslevelsize(::int32_t value) {
  _internal_set_scalesubslevelsize(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleSubsLevelSize)
}
inline ::int32_t Order::_internal_scalesubslevelsize() const {
  return _impl_.scalesubslevelsize_;
}
inline void Order::_internal_set_scalesubslevelsize(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00002000u;
  _impl_.scalesubslevelsize_ = value;
}

// optional double scalePriceIncrement = 50;
inline bool Order::has_scalepriceincrement() const {
  bool value = (_impl_._has_bits_[2] & 0x00001000u) != 0;
  return value;
}
inline void Order::clear_scalepriceincrement() {
  _impl_.scalepriceincrement_ = 0;
  _impl_._has_bits_[2] &= ~0x00001000u;
}
inline double Order::scalepriceincrement() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scalePriceIncrement)
  return _internal_scalepriceincrement();
}
inline void Order::set_scalepriceincrement(double value) {
  _internal_set_scalepriceincrement(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scalePriceIncrement)
}
inline double Order::_internal_scalepriceincrement() const {
  return _impl_.scalepriceincrement_;
}
inline void Order::_internal_set_scalepriceincrement(double value) {
  _impl_._has_bits_[2] |= 0x00001000u;
  _impl_.scalepriceincrement_ = value;
}

// optional double scalePriceAdjustValue = 51;
inline bool Order::has_scalepriceadjustvalue() const {
  bool value = (_impl_._has_bits_[2] & 0x00008000u) != 0;
  return value;
}
inline void Order::clear_scalepriceadjustvalue() {
  _impl_.scalepriceadjustvalue_ = 0;
  _impl_._has_bits_[2] &= ~0x00008000u;
}
inline double Order::scalepriceadjustvalue() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scalePriceAdjustValue)
  return _internal_scalepriceadjustvalue();
}
inline void Order::set_scalepriceadjustvalue(double value) {
  _internal_set_scalepriceadjustvalue(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scalePriceAdjustValue)
}
inline double Order::_internal_scalepriceadjustvalue() const {
  return _impl_.scalepriceadjustvalue_;
}
inline void Order::_internal_set_scalepriceadjustvalue(double value) {
  _impl_._has_bits_[2] |= 0x00008000u;
  _impl_.scalepriceadjustvalue_ = value;
}

// optional int32 scalePriceAdjustInterval = 52;
inline bool Order::has_scalepriceadjustinterval() const {
  bool value = (_impl_._has_bits_[2] & 0x00004000u) != 0;
  return value;
}
inline void Order::clear_scalepriceadjustinterval() {
  _impl_.scalepriceadjustinterval_ = 0;
  _impl_._has_bits_[2] &= ~0x00004000u;
}
inline ::int32_t Order::scalepriceadjustinterval() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scalePriceAdjustInterval)
  return _internal_scalepriceadjustinterval();
}
inline void Order::set_scalepriceadjustinterval(::int32_t value) {
  _internal_set_scalepriceadjustinterval(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scalePriceAdjustInterval)
}
inline ::int32_t Order::_internal_scalepriceadjustinterval() const {
  return _impl_.scalepriceadjustinterval_;
}
inline void Order::_internal_set_scalepriceadjustinterval(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00004000u;
  _impl_.scalepriceadjustinterval_ = value;
}

// optional double scaleProfitOffset = 53;
inline bool Order::has_scaleprofitoffset() const {
  bool value = (_impl_._has_bits_[2] & 0x00010000u) != 0;
  return value;
}
inline void Order::clear_scaleprofitoffset() {
  _impl_.scaleprofitoffset_ = 0;
  _impl_._has_bits_[2] &= ~0x00010000u;
}
inline double Order::scaleprofitoffset() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleProfitOffset)
  return _internal_scaleprofitoffset();
}
inline void Order::set_scaleprofitoffset(double value) {
  _internal_set_scaleprofitoffset(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleProfitOffset)
}
inline double Order::_internal_scaleprofitoffset() const {
  return _impl_.scaleprofitoffset_;
}
inline void Order::_internal_set_scaleprofitoffset(double value) {
  _impl_._has_bits_[2] |= 0x00010000u;
  _impl_.scaleprofitoffset_ = value;
}

// optional bool scaleAutoReset = 54;
inline bool Order::has_scaleautoreset() const {
  bool value = (_impl_._has_bits_[2] & 0x00000040u) != 0;
  return value;
}
inline void Order::clear_scaleautoreset() {
  _impl_.scaleautoreset_ = false;
  _impl_._has_bits_[2] &= ~0x00000040u;
}
inline bool Order::scaleautoreset() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleAutoReset)
  return _internal_scaleautoreset();
}
inline void Order::set_scaleautoreset(bool value) {
  _internal_set_scaleautoreset(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleAutoReset)
}
inline bool Order::_internal_scaleautoreset() const {
  return _impl_.scaleautoreset_;
}
inline void Order::_internal_set_scaleautoreset(bool value) {
  _impl_._has_bits_[2] |= 0x00000040u;
  _impl_.scaleautoreset_ = value;
}

// optional int32 scaleInitPosition = 55;
inline bool Order::has_scaleinitposition() const {
  bool value = (_impl_._has_bits_[2] & 0x00020000u) != 0;
  return value;
}
inline void Order::clear_scaleinitposition() {
  _impl_.scaleinitposition_ = 0;
  _impl_._has_bits_[2] &= ~0x00020000u;
}
inline ::int32_t Order::scaleinitposition() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleInitPosition)
  return _internal_scaleinitposition();
}
inline void Order::set_scaleinitposition(::int32_t value) {
  _internal_set_scaleinitposition(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleInitPosition)
}
inline ::int32_t Order::_internal_scaleinitposition() const {
  return _impl_.scaleinitposition_;
}
inline void Order::_internal_set_scaleinitposition(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00020000u;
  _impl_.scaleinitposition_ = value;
}

// optional int32 scaleInitFillQty = 56;
inline bool Order::has_scaleinitfillqty() const {
  bool value = (_impl_._has_bits_[2] & 0x00040000u) != 0;
  return value;
}
inline void Order::clear_scaleinitfillqty() {
  _impl_.scaleinitfillqty_ = 0;
  _impl_._has_bits_[2] &= ~0x00040000u;
}
inline ::int32_t Order::scaleinitfillqty() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleInitFillQty)
  return _internal_scaleinitfillqty();
}
inline void Order::set_scaleinitfillqty(::int32_t value) {
  _internal_set_scaleinitfillqty(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleInitFillQty)
}
inline ::int32_t Order::_internal_scaleinitfillqty() const {
  return _impl_.scaleinitfillqty_;
}
inline void Order::_internal_set_scaleinitfillqty(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00040000u;
  _impl_.scaleinitfillqty_ = value;
}

// optional bool scaleRandomPercent = 57;
inline bool Order::has_scalerandompercent() const {
  bool value = (_impl_._has_bits_[2] & 0x00080000u) != 0;
  return value;
}
inline void Order::clear_scalerandompercent() {
  _impl_.scalerandompercent_ = false;
  _impl_._has_bits_[2] &= ~0x00080000u;
}
inline bool Order::scalerandompercent() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleRandomPercent)
  return _internal_scalerandompercent();
}
inline void Order::set_scalerandompercent(bool value) {
  _internal_set_scalerandompercent(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleRandomPercent)
}
inline bool Order::_internal_scalerandompercent() const {
  return _impl_.scalerandompercent_;
}
inline void Order::_internal_set_scalerandompercent(bool value) {
  _impl_._has_bits_[2] |= 0x00080000u;
  _impl_.scalerandompercent_ = value;
}

// optional string scaleTable = 58;
inline bool Order::has_scaletable() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void Order::clear_scaletable() {
  _impl_.scaletable_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const std::string& Order::scaletable() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.scaleTable)
  return _internal_scaletable();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_scaletable(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.scaletable_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.scaleTable)
}
inline std::string* Order::mutable_scaletable() {
  std::string* _s = _internal_mutable_scaletable();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.scaleTable)
  return _s;
}
inline const std::string& Order::_internal_scaletable() const {
  return _impl_.scaletable_.Get();
}
inline void Order::_internal_set_scaletable(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00200000u;


  _impl_.scaletable_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_scaletable() {
  _impl_._has_bits_[0] |= 0x00200000u;
  return _impl_.scaletable_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_scaletable() {
  // @@protoc_insertion_point(field_release:protobuf.Order.scaleTable)
  if ((_impl_._has_bits_[0] & 0x00200000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00200000u;
  auto* released = _impl_.scaletable_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scaletable_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_scaletable(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.scaletable_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.scaletable_.IsDefault()) {
          _impl_.scaletable_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.scaleTable)
}

// optional string hedgeType = 59;
inline bool Order::has_hedgetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void Order::clear_hedgetype() {
  _impl_.hedgetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const std::string& Order::hedgetype() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.hedgeType)
  return _internal_hedgetype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_hedgetype(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.hedgetype_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.hedgeType)
}
inline std::string* Order::mutable_hedgetype() {
  std::string* _s = _internal_mutable_hedgetype();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.hedgeType)
  return _s;
}
inline const std::string& Order::_internal_hedgetype() const {
  return _impl_.hedgetype_.Get();
}
inline void Order::_internal_set_hedgetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00400000u;


  _impl_.hedgetype_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_hedgetype() {
  _impl_._has_bits_[0] |= 0x00400000u;
  return _impl_.hedgetype_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_hedgetype() {
  // @@protoc_insertion_point(field_release:protobuf.Order.hedgeType)
  if ((_impl_._has_bits_[0] & 0x00400000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00400000u;
  auto* released = _impl_.hedgetype_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hedgetype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_hedgetype(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.hedgetype_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hedgetype_.IsDefault()) {
          _impl_.hedgetype_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.hedgeType)
}

// optional string hedgeParam = 60;
inline bool Order::has_hedgeparam() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void Order::clear_hedgeparam() {
  _impl_.hedgeparam_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const std::string& Order::hedgeparam() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.hedgeParam)
  return _internal_hedgeparam();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_hedgeparam(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.hedgeparam_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.hedgeParam)
}
inline std::string* Order::mutable_hedgeparam() {
  std::string* _s = _internal_mutable_hedgeparam();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.hedgeParam)
  return _s;
}
inline const std::string& Order::_internal_hedgeparam() const {
  return _impl_.hedgeparam_.Get();
}
inline void Order::_internal_set_hedgeparam(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00800000u;


  _impl_.hedgeparam_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_hedgeparam() {
  _impl_._has_bits_[0] |= 0x00800000u;
  return _impl_.hedgeparam_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_hedgeparam() {
  // @@protoc_insertion_point(field_release:protobuf.Order.hedgeParam)
  if ((_impl_._has_bits_[0] & 0x00800000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00800000u;
  auto* released = _impl_.hedgeparam_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hedgeparam_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_hedgeparam(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.hedgeparam_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hedgeparam_.IsDefault()) {
          _impl_.hedgeparam_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.hedgeParam)
}

// optional string algoStrategy = 61;
inline bool Order::has_algostrategy() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void Order::clear_algostrategy() {
  _impl_.algostrategy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const std::string& Order::algostrategy() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.algoStrategy)
  return _internal_algostrategy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_algostrategy(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.algostrategy_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.algoStrategy)
}
inline std::string* Order::mutable_algostrategy() {
  std::string* _s = _internal_mutable_algostrategy();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.algoStrategy)
  return _s;
}
inline const std::string& Order::_internal_algostrategy() const {
  return _impl_.algostrategy_.Get();
}
inline void Order::_internal_set_algostrategy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x01000000u;


  _impl_.algostrategy_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_algostrategy() {
  _impl_._has_bits_[0] |= 0x01000000u;
  return _impl_.algostrategy_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_algostrategy() {
  // @@protoc_insertion_point(field_release:protobuf.Order.algoStrategy)
  if ((_impl_._has_bits_[0] & 0x01000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x01000000u;
  auto* released = _impl_.algostrategy_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.algostrategy_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_algostrategy(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.algostrategy_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.algostrategy_.IsDefault()) {
          _impl_.algostrategy_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.algoStrategy)
}

// map<string, string> algoParams = 62;
inline int Order::_internal_algoparams_size() const {
  return _impl_.algoparams_.size();
}
inline int Order::algoparams_size() const {
  return _internal_algoparams_size();
}
inline void Order::clear_algoparams() {
  _impl_.algoparams_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Order::_internal_algoparams() const {
  return _impl_.algoparams_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Order::algoparams() const {
  // @@protoc_insertion_point(field_map:protobuf.Order.algoParams)
  return _internal_algoparams();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Order::_internal_mutable_algoparams() {
  return _impl_.algoparams_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Order::mutable_algoparams() {
  // @@protoc_insertion_point(field_mutable_map:protobuf.Order.algoParams)
  return _internal_mutable_algoparams();
}

// optional string algoId = 63;
inline bool Order::has_algoid() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void Order::clear_algoid() {
  _impl_.algoid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const std::string& Order::algoid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.algoId)
  return _internal_algoid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_algoid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.algoid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.algoId)
}
inline std::string* Order::mutable_algoid() {
  std::string* _s = _internal_mutable_algoid();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.algoId)
  return _s;
}
inline const std::string& Order::_internal_algoid() const {
  return _impl_.algoid_.Get();
}
inline void Order::_internal_set_algoid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x02000000u;


  _impl_.algoid_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_algoid() {
  _impl_._has_bits_[0] |= 0x02000000u;
  return _impl_.algoid_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_algoid() {
  // @@protoc_insertion_point(field_release:protobuf.Order.algoId)
  if ((_impl_._has_bits_[0] & 0x02000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x02000000u;
  auto* released = _impl_.algoid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.algoid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_algoid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.algoid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.algoid_.IsDefault()) {
          _impl_.algoid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.algoId)
}

// map<string, string> smartComboRoutingParams = 64;
inline int Order::_internal_smartcomboroutingparams_size() const {
  return _impl_.smartcomboroutingparams_.size();
}
inline int Order::smartcomboroutingparams_size() const {
  return _internal_smartcomboroutingparams_size();
}
inline void Order::clear_smartcomboroutingparams() {
  _impl_.smartcomboroutingparams_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Order::_internal_smartcomboroutingparams() const {
  return _impl_.smartcomboroutingparams_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Order::smartcomboroutingparams() const {
  // @@protoc_insertion_point(field_map:protobuf.Order.smartComboRoutingParams)
  return _internal_smartcomboroutingparams();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Order::_internal_mutable_smartcomboroutingparams() {
  return _impl_.smartcomboroutingparams_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Order::mutable_smartcomboroutingparams() {
  // @@protoc_insertion_point(field_mutable_map:protobuf.Order.smartComboRoutingParams)
  return _internal_mutable_smartcomboroutingparams();
}

// optional bool whatIf = 65;
inline bool Order::has_whatif() const {
  bool value = (_impl_._has_bits_[2] & 0x00100000u) != 0;
  return value;
}
inline void Order::clear_whatif() {
  _impl_.whatif_ = false;
  _impl_._has_bits_[2] &= ~0x00100000u;
}
inline bool Order::whatif() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.whatIf)
  return _internal_whatif();
}
inline void Order::set_whatif(bool value) {
  _internal_set_whatif(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.whatIf)
}
inline bool Order::_internal_whatif() const {
  return _impl_.whatif_;
}
inline void Order::_internal_set_whatif(bool value) {
  _impl_._has_bits_[2] |= 0x00100000u;
  _impl_.whatif_ = value;
}

// optional bool transmit = 66;
inline bool Order::has_transmit() const {
  bool value = (_impl_._has_bits_[2] & 0x00200000u) != 0;
  return value;
}
inline void Order::clear_transmit() {
  _impl_.transmit_ = false;
  _impl_._has_bits_[2] &= ~0x00200000u;
}
inline bool Order::transmit() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.transmit)
  return _internal_transmit();
}
inline void Order::set_transmit(bool value) {
  _internal_set_transmit(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.transmit)
}
inline bool Order::_internal_transmit() const {
  return _impl_.transmit_;
}
inline void Order::_internal_set_transmit(bool value) {
  _impl_._has_bits_[2] |= 0x00200000u;
  _impl_.transmit_ = value;
}

// optional bool overridePercentageConstraints = 67;
inline bool Order::has_overridepercentageconstraints() const {
  bool value = (_impl_._has_bits_[2] & 0x00400000u) != 0;
  return value;
}
inline void Order::clear_overridepercentageconstraints() {
  _impl_.overridepercentageconstraints_ = false;
  _impl_._has_bits_[2] &= ~0x00400000u;
}
inline bool Order::overridepercentageconstraints() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.overridePercentageConstraints)
  return _internal_overridepercentageconstraints();
}
inline void Order::set_overridepercentageconstraints(bool value) {
  _internal_set_overridepercentageconstraints(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.overridePercentageConstraints)
}
inline bool Order::_internal_overridepercentageconstraints() const {
  return _impl_.overridepercentageconstraints_;
}
inline void Order::_internal_set_overridepercentageconstraints(bool value) {
  _impl_._has_bits_[2] |= 0x00400000u;
  _impl_.overridepercentageconstraints_ = value;
}

// optional string openClose = 68;
inline bool Order::has_openclose() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void Order::clear_openclose() {
  _impl_.openclose_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const std::string& Order::openclose() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.openClose)
  return _internal_openclose();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_openclose(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.openclose_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.openClose)
}
inline std::string* Order::mutable_openclose() {
  std::string* _s = _internal_mutable_openclose();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.openClose)
  return _s;
}
inline const std::string& Order::_internal_openclose() const {
  return _impl_.openclose_.Get();
}
inline void Order::_internal_set_openclose(const std::string& value) {
  _impl_._has_bits_[0] |= 0x04000000u;


  _impl_.openclose_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_openclose() {
  _impl_._has_bits_[0] |= 0x04000000u;
  return _impl_.openclose_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_openclose() {
  // @@protoc_insertion_point(field_release:protobuf.Order.openClose)
  if ((_impl_._has_bits_[0] & 0x04000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x04000000u;
  auto* released = _impl_.openclose_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.openclose_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_openclose(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.openclose_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.openclose_.IsDefault()) {
          _impl_.openclose_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.openClose)
}

// optional int32 origin = 69;
inline bool Order::has_origin() const {
  bool value = (_impl_._has_bits_[2] & 0x00800000u) != 0;
  return value;
}
inline void Order::clear_origin() {
  _impl_.origin_ = 0;
  _impl_._has_bits_[2] &= ~0x00800000u;
}
inline ::int32_t Order::origin() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.origin)
  return _internal_origin();
}
inline void Order::set_origin(::int32_t value) {
  _internal_set_origin(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.origin)
}
inline ::int32_t Order::_internal_origin() const {
  return _impl_.origin_;
}
inline void Order::_internal_set_origin(::int32_t value) {
  _impl_._has_bits_[2] |= 0x00800000u;
  _impl_.origin_ = value;
}

// optional int32 shortSaleSlot = 70;
inline bool Order::has_shortsaleslot() const {
  bool value = (_impl_._has_bits_[2] & 0x01000000u) != 0;
  return value;
}
inline void Order::clear_shortsaleslot() {
  _impl_.shortsaleslot_ = 0;
  _impl_._has_bits_[2] &= ~0x01000000u;
}
inline ::int32_t Order::shortsaleslot() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.shortSaleSlot)
  return _internal_shortsaleslot();
}
inline void Order::set_shortsaleslot(::int32_t value) {
  _internal_set_shortsaleslot(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.shortSaleSlot)
}
inline ::int32_t Order::_internal_shortsaleslot() const {
  return _impl_.shortsaleslot_;
}
inline void Order::_internal_set_shortsaleslot(::int32_t value) {
  _impl_._has_bits_[2] |= 0x01000000u;
  _impl_.shortsaleslot_ = value;
}

// optional string designatedLocation = 71;
inline bool Order::has_designatedlocation() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void Order::clear_designatedlocation() {
  _impl_.designatedlocation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const std::string& Order::designatedlocation() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.designatedLocation)
  return _internal_designatedlocation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_designatedlocation(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.designatedlocation_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.designatedLocation)
}
inline std::string* Order::mutable_designatedlocation() {
  std::string* _s = _internal_mutable_designatedlocation();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.designatedLocation)
  return _s;
}
inline const std::string& Order::_internal_designatedlocation() const {
  return _impl_.designatedlocation_.Get();
}
inline void Order::_internal_set_designatedlocation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x08000000u;


  _impl_.designatedlocation_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_designatedlocation() {
  _impl_._has_bits_[0] |= 0x08000000u;
  return _impl_.designatedlocation_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_designatedlocation() {
  // @@protoc_insertion_point(field_release:protobuf.Order.designatedLocation)
  if ((_impl_._has_bits_[0] & 0x08000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x08000000u;
  auto* released = _impl_.designatedlocation_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.designatedlocation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_designatedlocation(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.designatedlocation_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.designatedlocation_.IsDefault()) {
          _impl_.designatedlocation_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.designatedLocation)
}

// optional int32 exemptCode = 72;
inline bool Order::has_exemptcode() const {
  bool value = (_impl_._has_bits_[2] & 0x02000000u) != 0;
  return value;
}
inline void Order::clear_exemptcode() {
  _impl_.exemptcode_ = 0;
  _impl_._has_bits_[2] &= ~0x02000000u;
}
inline ::int32_t Order::exemptcode() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.exemptCode)
  return _internal_exemptcode();
}
inline void Order::set_exemptcode(::int32_t value) {
  _internal_set_exemptcode(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.exemptCode)
}
inline ::int32_t Order::_internal_exemptcode() const {
  return _impl_.exemptcode_;
}
inline void Order::_internal_set_exemptcode(::int32_t value) {
  _impl_._has_bits_[2] |= 0x02000000u;
  _impl_.exemptcode_ = value;
}

// optional string deltaNeutralSettlingFirm = 73;
inline bool Order::has_deltaneutralsettlingfirm() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void Order::clear_deltaneutralsettlingfirm() {
  _impl_.deltaneutralsettlingfirm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const std::string& Order::deltaneutralsettlingfirm() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralSettlingFirm)
  return _internal_deltaneutralsettlingfirm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_deltaneutralsettlingfirm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.deltaneutralsettlingfirm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralSettlingFirm)
}
inline std::string* Order::mutable_deltaneutralsettlingfirm() {
  std::string* _s = _internal_mutable_deltaneutralsettlingfirm();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.deltaNeutralSettlingFirm)
  return _s;
}
inline const std::string& Order::_internal_deltaneutralsettlingfirm() const {
  return _impl_.deltaneutralsettlingfirm_.Get();
}
inline void Order::_internal_set_deltaneutralsettlingfirm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x10000000u;


  _impl_.deltaneutralsettlingfirm_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_deltaneutralsettlingfirm() {
  _impl_._has_bits_[0] |= 0x10000000u;
  return _impl_.deltaneutralsettlingfirm_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_deltaneutralsettlingfirm() {
  // @@protoc_insertion_point(field_release:protobuf.Order.deltaNeutralSettlingFirm)
  if ((_impl_._has_bits_[0] & 0x10000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x10000000u;
  auto* released = _impl_.deltaneutralsettlingfirm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralsettlingfirm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_deltaneutralsettlingfirm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.deltaneutralsettlingfirm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deltaneutralsettlingfirm_.IsDefault()) {
          _impl_.deltaneutralsettlingfirm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.deltaNeutralSettlingFirm)
}

// optional string deltaNeutralClearingAccount = 74;
inline bool Order::has_deltaneutralclearingaccount() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void Order::clear_deltaneutralclearingaccount() {
  _impl_.deltaneutralclearingaccount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const std::string& Order::deltaneutralclearingaccount() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralClearingAccount)
  return _internal_deltaneutralclearingaccount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_deltaneutralclearingaccount(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.deltaneutralclearingaccount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralClearingAccount)
}
inline std::string* Order::mutable_deltaneutralclearingaccount() {
  std::string* _s = _internal_mutable_deltaneutralclearingaccount();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.deltaNeutralClearingAccount)
  return _s;
}
inline const std::string& Order::_internal_deltaneutralclearingaccount() const {
  return _impl_.deltaneutralclearingaccount_.Get();
}
inline void Order::_internal_set_deltaneutralclearingaccount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x20000000u;


  _impl_.deltaneutralclearingaccount_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_deltaneutralclearingaccount() {
  _impl_._has_bits_[0] |= 0x20000000u;
  return _impl_.deltaneutralclearingaccount_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_deltaneutralclearingaccount() {
  // @@protoc_insertion_point(field_release:protobuf.Order.deltaNeutralClearingAccount)
  if ((_impl_._has_bits_[0] & 0x20000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x20000000u;
  auto* released = _impl_.deltaneutralclearingaccount_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralclearingaccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_deltaneutralclearingaccount(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.deltaneutralclearingaccount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deltaneutralclearingaccount_.IsDefault()) {
          _impl_.deltaneutralclearingaccount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.deltaNeutralClearingAccount)
}

// optional string deltaNeutralClearingIntent = 75;
inline bool Order::has_deltaneutralclearingintent() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void Order::clear_deltaneutralclearingintent() {
  _impl_.deltaneutralclearingintent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const std::string& Order::deltaneutralclearingintent() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.deltaNeutralClearingIntent)
  return _internal_deltaneutralclearingintent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_deltaneutralclearingintent(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.deltaneutralclearingintent_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.deltaNeutralClearingIntent)
}
inline std::string* Order::mutable_deltaneutralclearingintent() {
  std::string* _s = _internal_mutable_deltaneutralclearingintent();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.deltaNeutralClearingIntent)
  return _s;
}
inline const std::string& Order::_internal_deltaneutralclearingintent() const {
  return _impl_.deltaneutralclearingintent_.Get();
}
inline void Order::_internal_set_deltaneutralclearingintent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x40000000u;


  _impl_.deltaneutralclearingintent_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_deltaneutralclearingintent() {
  _impl_._has_bits_[0] |= 0x40000000u;
  return _impl_.deltaneutralclearingintent_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_deltaneutralclearingintent() {
  // @@protoc_insertion_point(field_release:protobuf.Order.deltaNeutralClearingIntent)
  if ((_impl_._has_bits_[0] & 0x40000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x40000000u;
  auto* released = _impl_.deltaneutralclearingintent_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralclearingintent_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_deltaneutralclearingintent(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.deltaneutralclearingintent_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deltaneutralclearingintent_.IsDefault()) {
          _impl_.deltaneutralclearingintent_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.deltaNeutralClearingIntent)
}

// optional double discretionaryAmt = 76;
inline bool Order::has_discretionaryamt() const {
  bool value = (_impl_._has_bits_[2] & 0x04000000u) != 0;
  return value;
}
inline void Order::clear_discretionaryamt() {
  _impl_.discretionaryamt_ = 0;
  _impl_._has_bits_[2] &= ~0x04000000u;
}
inline double Order::discretionaryamt() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.discretionaryAmt)
  return _internal_discretionaryamt();
}
inline void Order::set_discretionaryamt(double value) {
  _internal_set_discretionaryamt(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.discretionaryAmt)
}
inline double Order::_internal_discretionaryamt() const {
  return _impl_.discretionaryamt_;
}
inline void Order::_internal_set_discretionaryamt(double value) {
  _impl_._has_bits_[2] |= 0x04000000u;
  _impl_.discretionaryamt_ = value;
}

// optional bool optOutSmartRouting = 77;
inline bool Order::has_optoutsmartrouting() const {
  bool value = (_impl_._has_bits_[3] & 0x00000001u) != 0;
  return value;
}
inline void Order::clear_optoutsmartrouting() {
  _impl_.optoutsmartrouting_ = false;
  _impl_._has_bits_[3] &= ~0x00000001u;
}
inline bool Order::optoutsmartrouting() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.optOutSmartRouting)
  return _internal_optoutsmartrouting();
}
inline void Order::set_optoutsmartrouting(bool value) {
  _internal_set_optoutsmartrouting(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.optOutSmartRouting)
}
inline bool Order::_internal_optoutsmartrouting() const {
  return _impl_.optoutsmartrouting_;
}
inline void Order::_internal_set_optoutsmartrouting(bool value) {
  _impl_._has_bits_[3] |= 0x00000001u;
  _impl_.optoutsmartrouting_ = value;
}

// optional double startingPrice = 78;
inline bool Order::has_startingprice() const {
  bool value = (_impl_._has_bits_[2] & 0x08000000u) != 0;
  return value;
}
inline void Order::clear_startingprice() {
  _impl_.startingprice_ = 0;
  _impl_._has_bits_[2] &= ~0x08000000u;
}
inline double Order::startingprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.startingPrice)
  return _internal_startingprice();
}
inline void Order::set_startingprice(double value) {
  _internal_set_startingprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.startingPrice)
}
inline double Order::_internal_startingprice() const {
  return _impl_.startingprice_;
}
inline void Order::_internal_set_startingprice(double value) {
  _impl_._has_bits_[2] |= 0x08000000u;
  _impl_.startingprice_ = value;
}

// optional double stockRefPrice = 79;
inline bool Order::has_stockrefprice() const {
  bool value = (_impl_._has_bits_[2] & 0x10000000u) != 0;
  return value;
}
inline void Order::clear_stockrefprice() {
  _impl_.stockrefprice_ = 0;
  _impl_._has_bits_[2] &= ~0x10000000u;
}
inline double Order::stockrefprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.stockRefPrice)
  return _internal_stockrefprice();
}
inline void Order::set_stockrefprice(double value) {
  _internal_set_stockrefprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.stockRefPrice)
}
inline double Order::_internal_stockrefprice() const {
  return _impl_.stockrefprice_;
}
inline void Order::_internal_set_stockrefprice(double value) {
  _impl_._has_bits_[2] |= 0x10000000u;
  _impl_.stockrefprice_ = value;
}

// optional double delta = 80;
inline bool Order::has_delta() const {
  bool value = (_impl_._has_bits_[2] & 0x20000000u) != 0;
  return value;
}
inline void Order::clear_delta() {
  _impl_.delta_ = 0;
  _impl_._has_bits_[2] &= ~0x20000000u;
}
inline double Order::delta() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.delta)
  return _internal_delta();
}
inline void Order::set_delta(double value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.delta)
}
inline double Order::_internal_delta() const {
  return _impl_.delta_;
}
inline void Order::_internal_set_delta(double value) {
  _impl_._has_bits_[2] |= 0x20000000u;
  _impl_.delta_ = value;
}

// optional double stockRangeLower = 81;
inline bool Order::has_stockrangelower() const {
  bool value = (_impl_._has_bits_[2] & 0x40000000u) != 0;
  return value;
}
inline void Order::clear_stockrangelower() {
  _impl_.stockrangelower_ = 0;
  _impl_._has_bits_[2] &= ~0x40000000u;
}
inline double Order::stockrangelower() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.stockRangeLower)
  return _internal_stockrangelower();
}
inline void Order::set_stockrangelower(double value) {
  _internal_set_stockrangelower(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.stockRangeLower)
}
inline double Order::_internal_stockrangelower() const {
  return _impl_.stockrangelower_;
}
inline void Order::_internal_set_stockrangelower(double value) {
  _impl_._has_bits_[2] |= 0x40000000u;
  _impl_.stockrangelower_ = value;
}

// optional double stockRangeUpper = 82;
inline bool Order::has_stockrangeupper() const {
  bool value = (_impl_._has_bits_[2] & 0x80000000u) != 0;
  return value;
}
inline void Order::clear_stockrangeupper() {
  _impl_.stockrangeupper_ = 0;
  _impl_._has_bits_[2] &= ~0x80000000u;
}
inline double Order::stockrangeupper() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.stockRangeUpper)
  return _internal_stockrangeupper();
}
inline void Order::set_stockrangeupper(double value) {
  _internal_set_stockrangeupper(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.stockRangeUpper)
}
inline double Order::_internal_stockrangeupper() const {
  return _impl_.stockrangeupper_;
}
inline void Order::_internal_set_stockrangeupper(double value) {
  _impl_._has_bits_[2] |= 0x80000000u;
  _impl_.stockrangeupper_ = value;
}

// optional bool notHeld = 83;
inline bool Order::has_notheld() const {
  bool value = (_impl_._has_bits_[3] & 0x00000002u) != 0;
  return value;
}
inline void Order::clear_notheld() {
  _impl_.notheld_ = false;
  _impl_._has_bits_[3] &= ~0x00000002u;
}
inline bool Order::notheld() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.notHeld)
  return _internal_notheld();
}
inline void Order::set_notheld(bool value) {
  _internal_set_notheld(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.notHeld)
}
inline bool Order::_internal_notheld() const {
  return _impl_.notheld_;
}
inline void Order::_internal_set_notheld(bool value) {
  _impl_._has_bits_[3] |= 0x00000002u;
  _impl_.notheld_ = value;
}

// map<string, string> orderMiscOptions = 84;
inline int Order::_internal_ordermiscoptions_size() const {
  return _impl_.ordermiscoptions_.size();
}
inline int Order::ordermiscoptions_size() const {
  return _internal_ordermiscoptions_size();
}
inline void Order::clear_ordermiscoptions() {
  _impl_.ordermiscoptions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Order::_internal_ordermiscoptions() const {
  return _impl_.ordermiscoptions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Order::ordermiscoptions() const {
  // @@protoc_insertion_point(field_map:protobuf.Order.orderMiscOptions)
  return _internal_ordermiscoptions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Order::_internal_mutable_ordermiscoptions() {
  return _impl_.ordermiscoptions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Order::mutable_ordermiscoptions() {
  // @@protoc_insertion_point(field_mutable_map:protobuf.Order.orderMiscOptions)
  return _internal_mutable_ordermiscoptions();
}

// optional bool solicited = 85;
inline bool Order::has_solicited() const {
  bool value = (_impl_._has_bits_[3] & 0x00000004u) != 0;
  return value;
}
inline void Order::clear_solicited() {
  _impl_.solicited_ = false;
  _impl_._has_bits_[3] &= ~0x00000004u;
}
inline bool Order::solicited() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.solicited)
  return _internal_solicited();
}
inline void Order::set_solicited(bool value) {
  _internal_set_solicited(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.solicited)
}
inline bool Order::_internal_solicited() const {
  return _impl_.solicited_;
}
inline void Order::_internal_set_solicited(bool value) {
  _impl_._has_bits_[3] |= 0x00000004u;
  _impl_.solicited_ = value;
}

// optional bool randomizeSize = 86;
inline bool Order::has_randomizesize() const {
  bool value = (_impl_._has_bits_[3] & 0x00000008u) != 0;
  return value;
}
inline void Order::clear_randomizesize() {
  _impl_.randomizesize_ = false;
  _impl_._has_bits_[3] &= ~0x00000008u;
}
inline bool Order::randomizesize() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.randomizeSize)
  return _internal_randomizesize();
}
inline void Order::set_randomizesize(bool value) {
  _internal_set_randomizesize(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.randomizeSize)
}
inline bool Order::_internal_randomizesize() const {
  return _impl_.randomizesize_;
}
inline void Order::_internal_set_randomizesize(bool value) {
  _impl_._has_bits_[3] |= 0x00000008u;
  _impl_.randomizesize_ = value;
}

// optional bool randomizePrice = 87;
inline bool Order::has_randomizeprice() const {
  bool value = (_impl_._has_bits_[3] & 0x00000200u) != 0;
  return value;
}
inline void Order::clear_randomizeprice() {
  _impl_.randomizeprice_ = false;
  _impl_._has_bits_[3] &= ~0x00000200u;
}
inline bool Order::randomizeprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.randomizePrice)
  return _internal_randomizeprice();
}
inline void Order::set_randomizeprice(bool value) {
  _internal_set_randomizeprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.randomizePrice)
}
inline bool Order::_internal_randomizeprice() const {
  return _impl_.randomizeprice_;
}
inline void Order::_internal_set_randomizeprice(bool value) {
  _impl_._has_bits_[3] |= 0x00000200u;
  _impl_.randomizeprice_ = value;
}

// optional int32 referenceContractId = 88;
inline bool Order::has_referencecontractid() const {
  bool value = (_impl_._has_bits_[3] & 0x00000010u) != 0;
  return value;
}
inline void Order::clear_referencecontractid() {
  _impl_.referencecontractid_ = 0;
  _impl_._has_bits_[3] &= ~0x00000010u;
}
inline ::int32_t Order::referencecontractid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.referenceContractId)
  return _internal_referencecontractid();
}
inline void Order::set_referencecontractid(::int32_t value) {
  _internal_set_referencecontractid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.referenceContractId)
}
inline ::int32_t Order::_internal_referencecontractid() const {
  return _impl_.referencecontractid_;
}
inline void Order::_internal_set_referencecontractid(::int32_t value) {
  _impl_._has_bits_[3] |= 0x00000010u;
  _impl_.referencecontractid_ = value;
}

// optional double peggedChangeAmount = 89;
inline bool Order::has_peggedchangeamount() const {
  bool value = (_impl_._has_bits_[3] & 0x00000020u) != 0;
  return value;
}
inline void Order::clear_peggedchangeamount() {
  _impl_.peggedchangeamount_ = 0;
  _impl_._has_bits_[3] &= ~0x00000020u;
}
inline double Order::peggedchangeamount() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.peggedChangeAmount)
  return _internal_peggedchangeamount();
}
inline void Order::set_peggedchangeamount(double value) {
  _internal_set_peggedchangeamount(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.peggedChangeAmount)
}
inline double Order::_internal_peggedchangeamount() const {
  return _impl_.peggedchangeamount_;
}
inline void Order::_internal_set_peggedchangeamount(double value) {
  _impl_._has_bits_[3] |= 0x00000020u;
  _impl_.peggedchangeamount_ = value;
}

// optional bool isPeggedChangeAmountDecrease = 90;
inline bool Order::has_ispeggedchangeamountdecrease() const {
  bool value = (_impl_._has_bits_[3] & 0x00000400u) != 0;
  return value;
}
inline void Order::clear_ispeggedchangeamountdecrease() {
  _impl_.ispeggedchangeamountdecrease_ = false;
  _impl_._has_bits_[3] &= ~0x00000400u;
}
inline bool Order::ispeggedchangeamountdecrease() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.isPeggedChangeAmountDecrease)
  return _internal_ispeggedchangeamountdecrease();
}
inline void Order::set_ispeggedchangeamountdecrease(bool value) {
  _internal_set_ispeggedchangeamountdecrease(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.isPeggedChangeAmountDecrease)
}
inline bool Order::_internal_ispeggedchangeamountdecrease() const {
  return _impl_.ispeggedchangeamountdecrease_;
}
inline void Order::_internal_set_ispeggedchangeamountdecrease(bool value) {
  _impl_._has_bits_[3] |= 0x00000400u;
  _impl_.ispeggedchangeamountdecrease_ = value;
}

// optional double referenceChangeAmount = 91;
inline bool Order::has_referencechangeamount() const {
  bool value = (_impl_._has_bits_[3] & 0x00000040u) != 0;
  return value;
}
inline void Order::clear_referencechangeamount() {
  _impl_.referencechangeamount_ = 0;
  _impl_._has_bits_[3] &= ~0x00000040u;
}
inline double Order::referencechangeamount() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.referenceChangeAmount)
  return _internal_referencechangeamount();
}
inline void Order::set_referencechangeamount(double value) {
  _internal_set_referencechangeamount(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.referenceChangeAmount)
}
inline double Order::_internal_referencechangeamount() const {
  return _impl_.referencechangeamount_;
}
inline void Order::_internal_set_referencechangeamount(double value) {
  _impl_._has_bits_[3] |= 0x00000040u;
  _impl_.referencechangeamount_ = value;
}

// optional string referenceExchangeId = 92;
inline bool Order::has_referenceexchangeid() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void Order::clear_referenceexchangeid() {
  _impl_.referenceexchangeid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const std::string& Order::referenceexchangeid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.referenceExchangeId)
  return _internal_referenceexchangeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_referenceexchangeid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.referenceexchangeid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.referenceExchangeId)
}
inline std::string* Order::mutable_referenceexchangeid() {
  std::string* _s = _internal_mutable_referenceexchangeid();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.referenceExchangeId)
  return _s;
}
inline const std::string& Order::_internal_referenceexchangeid() const {
  return _impl_.referenceexchangeid_.Get();
}
inline void Order::_internal_set_referenceexchangeid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x80000000u;


  _impl_.referenceexchangeid_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_referenceexchangeid() {
  _impl_._has_bits_[0] |= 0x80000000u;
  return _impl_.referenceexchangeid_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_referenceexchangeid() {
  // @@protoc_insertion_point(field_release:protobuf.Order.referenceExchangeId)
  if ((_impl_._has_bits_[0] & 0x80000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x80000000u;
  auto* released = _impl_.referenceexchangeid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referenceexchangeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_referenceexchangeid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.referenceexchangeid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.referenceexchangeid_.IsDefault()) {
          _impl_.referenceexchangeid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.referenceExchangeId)
}

// optional string adjustedOrderType = 93;
inline bool Order::has_adjustedordertype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline void Order::clear_adjustedordertype() {
  _impl_.adjustedordertype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const std::string& Order::adjustedordertype() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.adjustedOrderType)
  return _internal_adjustedordertype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_adjustedordertype(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.adjustedordertype_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.adjustedOrderType)
}
inline std::string* Order::mutable_adjustedordertype() {
  std::string* _s = _internal_mutable_adjustedordertype();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.adjustedOrderType)
  return _s;
}
inline const std::string& Order::_internal_adjustedordertype() const {
  return _impl_.adjustedordertype_.Get();
}
inline void Order::_internal_set_adjustedordertype(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000001u;


  _impl_.adjustedordertype_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_adjustedordertype() {
  _impl_._has_bits_[1] |= 0x00000001u;
  return _impl_.adjustedordertype_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_adjustedordertype() {
  // @@protoc_insertion_point(field_release:protobuf.Order.adjustedOrderType)
  if ((_impl_._has_bits_[1] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000001u;
  auto* released = _impl_.adjustedordertype_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.adjustedordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_adjustedordertype(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.adjustedordertype_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.adjustedordertype_.IsDefault()) {
          _impl_.adjustedordertype_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.adjustedOrderType)
}

// optional double triggerPrice = 94;
inline bool Order::has_triggerprice() const {
  bool value = (_impl_._has_bits_[3] & 0x00000080u) != 0;
  return value;
}
inline void Order::clear_triggerprice() {
  _impl_.triggerprice_ = 0;
  _impl_._has_bits_[3] &= ~0x00000080u;
}
inline double Order::triggerprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.triggerPrice)
  return _internal_triggerprice();
}
inline void Order::set_triggerprice(double value) {
  _internal_set_triggerprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.triggerPrice)
}
inline double Order::_internal_triggerprice() const {
  return _impl_.triggerprice_;
}
inline void Order::_internal_set_triggerprice(double value) {
  _impl_._has_bits_[3] |= 0x00000080u;
  _impl_.triggerprice_ = value;
}

// optional double adjustedStopPrice = 95;
inline bool Order::has_adjustedstopprice() const {
  bool value = (_impl_._has_bits_[3] & 0x00000100u) != 0;
  return value;
}
inline void Order::clear_adjustedstopprice() {
  _impl_.adjustedstopprice_ = 0;
  _impl_._has_bits_[3] &= ~0x00000100u;
}
inline double Order::adjustedstopprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.adjustedStopPrice)
  return _internal_adjustedstopprice();
}
inline void Order::set_adjustedstopprice(double value) {
  _internal_set_adjustedstopprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.adjustedStopPrice)
}
inline double Order::_internal_adjustedstopprice() const {
  return _impl_.adjustedstopprice_;
}
inline void Order::_internal_set_adjustedstopprice(double value) {
  _impl_._has_bits_[3] |= 0x00000100u;
  _impl_.adjustedstopprice_ = value;
}

// optional double adjustedStopLimitPrice = 96;
inline bool Order::has_adjustedstoplimitprice() const {
  bool value = (_impl_._has_bits_[3] & 0x00004000u) != 0;
  return value;
}
inline void Order::clear_adjustedstoplimitprice() {
  _impl_.adjustedstoplimitprice_ = 0;
  _impl_._has_bits_[3] &= ~0x00004000u;
}
inline double Order::adjustedstoplimitprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.adjustedStopLimitPrice)
  return _internal_adjustedstoplimitprice();
}
inline void Order::set_adjustedstoplimitprice(double value) {
  _internal_set_adjustedstoplimitprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.adjustedStopLimitPrice)
}
inline double Order::_internal_adjustedstoplimitprice() const {
  return _impl_.adjustedstoplimitprice_;
}
inline void Order::_internal_set_adjustedstoplimitprice(double value) {
  _impl_._has_bits_[3] |= 0x00004000u;
  _impl_.adjustedstoplimitprice_ = value;
}

// optional double adjustedTrailingAmount = 97;
inline bool Order::has_adjustedtrailingamount() const {
  bool value = (_impl_._has_bits_[3] & 0x00008000u) != 0;
  return value;
}
inline void Order::clear_adjustedtrailingamount() {
  _impl_.adjustedtrailingamount_ = 0;
  _impl_._has_bits_[3] &= ~0x00008000u;
}
inline double Order::adjustedtrailingamount() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.adjustedTrailingAmount)
  return _internal_adjustedtrailingamount();
}
inline void Order::set_adjustedtrailingamount(double value) {
  _internal_set_adjustedtrailingamount(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.adjustedTrailingAmount)
}
inline double Order::_internal_adjustedtrailingamount() const {
  return _impl_.adjustedtrailingamount_;
}
inline void Order::_internal_set_adjustedtrailingamount(double value) {
  _impl_._has_bits_[3] |= 0x00008000u;
  _impl_.adjustedtrailingamount_ = value;
}

// optional int32 adjustableTrailingUnit = 98;
inline bool Order::has_adjustabletrailingunit() const {
  bool value = (_impl_._has_bits_[3] & 0x00002000u) != 0;
  return value;
}
inline void Order::clear_adjustabletrailingunit() {
  _impl_.adjustabletrailingunit_ = 0;
  _impl_._has_bits_[3] &= ~0x00002000u;
}
inline ::int32_t Order::adjustabletrailingunit() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.adjustableTrailingUnit)
  return _internal_adjustabletrailingunit();
}
inline void Order::set_adjustabletrailingunit(::int32_t value) {
  _internal_set_adjustabletrailingunit(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.adjustableTrailingUnit)
}
inline ::int32_t Order::_internal_adjustabletrailingunit() const {
  return _impl_.adjustabletrailingunit_;
}
inline void Order::_internal_set_adjustabletrailingunit(::int32_t value) {
  _impl_._has_bits_[3] |= 0x00002000u;
  _impl_.adjustabletrailingunit_ = value;
}

// optional double lmtPriceOffset = 99;
inline bool Order::has_lmtpriceoffset() const {
  bool value = (_impl_._has_bits_[3] & 0x00010000u) != 0;
  return value;
}
inline void Order::clear_lmtpriceoffset() {
  _impl_.lmtpriceoffset_ = 0;
  _impl_._has_bits_[3] &= ~0x00010000u;
}
inline double Order::lmtpriceoffset() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.lmtPriceOffset)
  return _internal_lmtpriceoffset();
}
inline void Order::set_lmtpriceoffset(double value) {
  _internal_set_lmtpriceoffset(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.lmtPriceOffset)
}
inline double Order::_internal_lmtpriceoffset() const {
  return _impl_.lmtpriceoffset_;
}
inline void Order::_internal_set_lmtpriceoffset(double value) {
  _impl_._has_bits_[3] |= 0x00010000u;
  _impl_.lmtpriceoffset_ = value;
}

// repeated .protobuf.OrderCondition conditions = 100;
inline int Order::_internal_conditions_size() const {
  return _impl_.conditions_.size();
}
inline int Order::conditions_size() const {
  return _internal_conditions_size();
}
inline ::protobuf::OrderCondition* Order::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:protobuf.Order.conditions)
  return _internal_mutable_conditions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::OrderCondition >*
Order::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:protobuf.Order.conditions)
  return _internal_mutable_conditions();
}
inline const ::protobuf::OrderCondition& Order::_internal_conditions(int index) const {
  return _internal_conditions().Get(index);
}
inline const ::protobuf::OrderCondition& Order::conditions(int index) const {
  // @@protoc_insertion_point(field_get:protobuf.Order.conditions)
  return _internal_conditions(index);
}
inline ::protobuf::OrderCondition* Order::_internal_add_conditions() {
  return _internal_mutable_conditions()->Add();
}
inline ::protobuf::OrderCondition* Order::add_conditions() {
  ::protobuf::OrderCondition* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:protobuf.Order.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::OrderCondition >&
Order::conditions() const {
  // @@protoc_insertion_point(field_list:protobuf.Order.conditions)
  return _internal_conditions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protobuf::OrderCondition>&
Order::_internal_conditions() const {
  return _impl_.conditions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protobuf::OrderCondition>*
Order::_internal_mutable_conditions() {
  return &_impl_.conditions_;
}

// optional bool conditionsCancelOrder = 101;
inline bool Order::has_conditionscancelorder() const {
  bool value = (_impl_._has_bits_[3] & 0x00000800u) != 0;
  return value;
}
inline void Order::clear_conditionscancelorder() {
  _impl_.conditionscancelorder_ = false;
  _impl_._has_bits_[3] &= ~0x00000800u;
}
inline bool Order::conditionscancelorder() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.conditionsCancelOrder)
  return _internal_conditionscancelorder();
}
inline void Order::set_conditionscancelorder(bool value) {
  _internal_set_conditionscancelorder(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.conditionsCancelOrder)
}
inline bool Order::_internal_conditionscancelorder() const {
  return _impl_.conditionscancelorder_;
}
inline void Order::_internal_set_conditionscancelorder(bool value) {
  _impl_._has_bits_[3] |= 0x00000800u;
  _impl_.conditionscancelorder_ = value;
}

// optional bool conditionsIgnoreRth = 102;
inline bool Order::has_conditionsignorerth() const {
  bool value = (_impl_._has_bits_[3] & 0x00001000u) != 0;
  return value;
}
inline void Order::clear_conditionsignorerth() {
  _impl_.conditionsignorerth_ = false;
  _impl_._has_bits_[3] &= ~0x00001000u;
}
inline bool Order::conditionsignorerth() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.conditionsIgnoreRth)
  return _internal_conditionsignorerth();
}
inline void Order::set_conditionsignorerth(bool value) {
  _internal_set_conditionsignorerth(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.conditionsIgnoreRth)
}
inline bool Order::_internal_conditionsignorerth() const {
  return _impl_.conditionsignorerth_;
}
inline void Order::_internal_set_conditionsignorerth(bool value) {
  _impl_._has_bits_[3] |= 0x00001000u;
  _impl_.conditionsignorerth_ = value;
}

// optional string modelCode = 103;
inline bool Order::has_modelcode() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline void Order::clear_modelcode() {
  _impl_.modelcode_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const std::string& Order::modelcode() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.modelCode)
  return _internal_modelcode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_modelcode(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.modelcode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.modelCode)
}
inline std::string* Order::mutable_modelcode() {
  std::string* _s = _internal_mutable_modelcode();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.modelCode)
  return _s;
}
inline const std::string& Order::_internal_modelcode() const {
  return _impl_.modelcode_.Get();
}
inline void Order::_internal_set_modelcode(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000002u;


  _impl_.modelcode_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_modelcode() {
  _impl_._has_bits_[1] |= 0x00000002u;
  return _impl_.modelcode_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_modelcode() {
  // @@protoc_insertion_point(field_release:protobuf.Order.modelCode)
  if ((_impl_._has_bits_[1] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000002u;
  auto* released = _impl_.modelcode_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelcode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_modelcode(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.modelcode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelcode_.IsDefault()) {
          _impl_.modelcode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.modelCode)
}

// optional string extOperator = 104;
inline bool Order::has_extoperator() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline void Order::clear_extoperator() {
  _impl_.extoperator_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const std::string& Order::extoperator() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.extOperator)
  return _internal_extoperator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_extoperator(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.extoperator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.extOperator)
}
inline std::string* Order::mutable_extoperator() {
  std::string* _s = _internal_mutable_extoperator();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.extOperator)
  return _s;
}
inline const std::string& Order::_internal_extoperator() const {
  return _impl_.extoperator_.Get();
}
inline void Order::_internal_set_extoperator(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000004u;


  _impl_.extoperator_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_extoperator() {
  _impl_._has_bits_[1] |= 0x00000004u;
  return _impl_.extoperator_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_extoperator() {
  // @@protoc_insertion_point(field_release:protobuf.Order.extOperator)
  if ((_impl_._has_bits_[1] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000004u;
  auto* released = _impl_.extoperator_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extoperator_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_extoperator(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.extoperator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extoperator_.IsDefault()) {
          _impl_.extoperator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.extOperator)
}

// optional .protobuf.SoftDollarTier softDollarTier = 105;
inline bool Order::has_softdollartier() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.softdollartier_ != nullptr);
  return value;
}
inline const ::protobuf::SoftDollarTier& Order::_internal_softdollartier() const {
  const ::protobuf::SoftDollarTier* p = _impl_.softdollartier_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::SoftDollarTier&>(
      ::protobuf::_SoftDollarTier_default_instance_);
}
inline const ::protobuf::SoftDollarTier& Order::softdollartier() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.softDollarTier)
  return _internal_softdollartier();
}
inline void Order::unsafe_arena_set_allocated_softdollartier(
    ::protobuf::SoftDollarTier* softdollartier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.softdollartier_);
  }
  _impl_.softdollartier_ = softdollartier;
  if (softdollartier) {
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Order.softDollarTier)
}
inline ::protobuf::SoftDollarTier* Order::release_softdollartier() {
  _impl_._has_bits_[1] &= ~0x00008000u;
  ::protobuf::SoftDollarTier* temp = _impl_.softdollartier_;
  _impl_.softdollartier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuf::SoftDollarTier* Order::unsafe_arena_release_softdollartier() {
  // @@protoc_insertion_point(field_release:protobuf.Order.softDollarTier)
  _impl_._has_bits_[1] &= ~0x00008000u;
  ::protobuf::SoftDollarTier* temp = _impl_.softdollartier_;
  _impl_.softdollartier_ = nullptr;
  return temp;
}
inline ::protobuf::SoftDollarTier* Order::_internal_mutable_softdollartier() {
  _impl_._has_bits_[1] |= 0x00008000u;
  if (_impl_.softdollartier_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::SoftDollarTier>(GetArenaForAllocation());
    _impl_.softdollartier_ = p;
  }
  return _impl_.softdollartier_;
}
inline ::protobuf::SoftDollarTier* Order::mutable_softdollartier() {
  ::protobuf::SoftDollarTier* _msg = _internal_mutable_softdollartier();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.softDollarTier)
  return _msg;
}
inline void Order::set_allocated_softdollartier(::protobuf::SoftDollarTier* softdollartier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.softdollartier_);
  }
  if (softdollartier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(softdollartier));
    if (message_arena != submessage_arena) {
      softdollartier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, softdollartier, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }
  _impl_.softdollartier_ = softdollartier;
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.softDollarTier)
}

// optional double cashQty = 106;
inline bool Order::has_cashqty() const {
  bool value = (_impl_._has_bits_[3] & 0x00020000u) != 0;
  return value;
}
inline void Order::clear_cashqty() {
  _impl_.cashqty_ = 0;
  _impl_._has_bits_[3] &= ~0x00020000u;
}
inline double Order::cashqty() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.cashQty)
  return _internal_cashqty();
}
inline void Order::set_cashqty(double value) {
  _internal_set_cashqty(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.cashQty)
}
inline double Order::_internal_cashqty() const {
  return _impl_.cashqty_;
}
inline void Order::_internal_set_cashqty(double value) {
  _impl_._has_bits_[3] |= 0x00020000u;
  _impl_.cashqty_ = value;
}

// optional string mifid2DecisionMaker = 107;
inline bool Order::has_mifid2decisionmaker() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline void Order::clear_mifid2decisionmaker() {
  _impl_.mifid2decisionmaker_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const std::string& Order::mifid2decisionmaker() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.mifid2DecisionMaker)
  return _internal_mifid2decisionmaker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_mifid2decisionmaker(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.mifid2decisionmaker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.mifid2DecisionMaker)
}
inline std::string* Order::mutable_mifid2decisionmaker() {
  std::string* _s = _internal_mutable_mifid2decisionmaker();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.mifid2DecisionMaker)
  return _s;
}
inline const std::string& Order::_internal_mifid2decisionmaker() const {
  return _impl_.mifid2decisionmaker_.Get();
}
inline void Order::_internal_set_mifid2decisionmaker(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000008u;


  _impl_.mifid2decisionmaker_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_mifid2decisionmaker() {
  _impl_._has_bits_[1] |= 0x00000008u;
  return _impl_.mifid2decisionmaker_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_mifid2decisionmaker() {
  // @@protoc_insertion_point(field_release:protobuf.Order.mifid2DecisionMaker)
  if ((_impl_._has_bits_[1] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000008u;
  auto* released = _impl_.mifid2decisionmaker_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2decisionmaker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_mifid2decisionmaker(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.mifid2decisionmaker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mifid2decisionmaker_.IsDefault()) {
          _impl_.mifid2decisionmaker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.mifid2DecisionMaker)
}

// optional string mifid2DecisionAlgo = 108;
inline bool Order::has_mifid2decisionalgo() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline void Order::clear_mifid2decisionalgo() {
  _impl_.mifid2decisionalgo_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline const std::string& Order::mifid2decisionalgo() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.mifid2DecisionAlgo)
  return _internal_mifid2decisionalgo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_mifid2decisionalgo(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.mifid2decisionalgo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.mifid2DecisionAlgo)
}
inline std::string* Order::mutable_mifid2decisionalgo() {
  std::string* _s = _internal_mutable_mifid2decisionalgo();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.mifid2DecisionAlgo)
  return _s;
}
inline const std::string& Order::_internal_mifid2decisionalgo() const {
  return _impl_.mifid2decisionalgo_.Get();
}
inline void Order::_internal_set_mifid2decisionalgo(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000010u;


  _impl_.mifid2decisionalgo_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_mifid2decisionalgo() {
  _impl_._has_bits_[1] |= 0x00000010u;
  return _impl_.mifid2decisionalgo_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_mifid2decisionalgo() {
  // @@protoc_insertion_point(field_release:protobuf.Order.mifid2DecisionAlgo)
  if ((_impl_._has_bits_[1] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000010u;
  auto* released = _impl_.mifid2decisionalgo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2decisionalgo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_mifid2decisionalgo(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  _impl_.mifid2decisionalgo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mifid2decisionalgo_.IsDefault()) {
          _impl_.mifid2decisionalgo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.mifid2DecisionAlgo)
}

// optional string mifid2ExecutionTrader = 109;
inline bool Order::has_mifid2executiontrader() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline void Order::clear_mifid2executiontrader() {
  _impl_.mifid2executiontrader_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline const std::string& Order::mifid2executiontrader() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.mifid2ExecutionTrader)
  return _internal_mifid2executiontrader();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_mifid2executiontrader(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.mifid2executiontrader_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.mifid2ExecutionTrader)
}
inline std::string* Order::mutable_mifid2executiontrader() {
  std::string* _s = _internal_mutable_mifid2executiontrader();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.mifid2ExecutionTrader)
  return _s;
}
inline const std::string& Order::_internal_mifid2executiontrader() const {
  return _impl_.mifid2executiontrader_.Get();
}
inline void Order::_internal_set_mifid2executiontrader(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000020u;


  _impl_.mifid2executiontrader_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_mifid2executiontrader() {
  _impl_._has_bits_[1] |= 0x00000020u;
  return _impl_.mifid2executiontrader_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_mifid2executiontrader() {
  // @@protoc_insertion_point(field_release:protobuf.Order.mifid2ExecutionTrader)
  if ((_impl_._has_bits_[1] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000020u;
  auto* released = _impl_.mifid2executiontrader_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2executiontrader_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_mifid2executiontrader(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  _impl_.mifid2executiontrader_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mifid2executiontrader_.IsDefault()) {
          _impl_.mifid2executiontrader_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.mifid2ExecutionTrader)
}

// optional string mifid2ExecutionAlgo = 110;
inline bool Order::has_mifid2executionalgo() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline void Order::clear_mifid2executionalgo() {
  _impl_.mifid2executionalgo_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline const std::string& Order::mifid2executionalgo() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.mifid2ExecutionAlgo)
  return _internal_mifid2executionalgo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_mifid2executionalgo(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.mifid2executionalgo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.mifid2ExecutionAlgo)
}
inline std::string* Order::mutable_mifid2executionalgo() {
  std::string* _s = _internal_mutable_mifid2executionalgo();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.mifid2ExecutionAlgo)
  return _s;
}
inline const std::string& Order::_internal_mifid2executionalgo() const {
  return _impl_.mifid2executionalgo_.Get();
}
inline void Order::_internal_set_mifid2executionalgo(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000040u;


  _impl_.mifid2executionalgo_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_mifid2executionalgo() {
  _impl_._has_bits_[1] |= 0x00000040u;
  return _impl_.mifid2executionalgo_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_mifid2executionalgo() {
  // @@protoc_insertion_point(field_release:protobuf.Order.mifid2ExecutionAlgo)
  if ((_impl_._has_bits_[1] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000040u;
  auto* released = _impl_.mifid2executionalgo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2executionalgo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_mifid2executionalgo(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  _impl_.mifid2executionalgo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mifid2executionalgo_.IsDefault()) {
          _impl_.mifid2executionalgo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.mifid2ExecutionAlgo)
}

// optional bool dontUseAutoPriceForHedge = 111;
inline bool Order::has_dontuseautopriceforhedge() const {
  bool value = (_impl_._has_bits_[3] & 0x00040000u) != 0;
  return value;
}
inline void Order::clear_dontuseautopriceforhedge() {
  _impl_.dontuseautopriceforhedge_ = false;
  _impl_._has_bits_[3] &= ~0x00040000u;
}
inline bool Order::dontuseautopriceforhedge() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.dontUseAutoPriceForHedge)
  return _internal_dontuseautopriceforhedge();
}
inline void Order::set_dontuseautopriceforhedge(bool value) {
  _internal_set_dontuseautopriceforhedge(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.dontUseAutoPriceForHedge)
}
inline bool Order::_internal_dontuseautopriceforhedge() const {
  return _impl_.dontuseautopriceforhedge_;
}
inline void Order::_internal_set_dontuseautopriceforhedge(bool value) {
  _impl_._has_bits_[3] |= 0x00040000u;
  _impl_.dontuseautopriceforhedge_ = value;
}

// optional bool isOmsContainer = 112;
inline bool Order::has_isomscontainer() const {
  bool value = (_impl_._has_bits_[3] & 0x00080000u) != 0;
  return value;
}
inline void Order::clear_isomscontainer() {
  _impl_.isomscontainer_ = false;
  _impl_._has_bits_[3] &= ~0x00080000u;
}
inline bool Order::isomscontainer() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.isOmsContainer)
  return _internal_isomscontainer();
}
inline void Order::set_isomscontainer(bool value) {
  _internal_set_isomscontainer(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.isOmsContainer)
}
inline bool Order::_internal_isomscontainer() const {
  return _impl_.isomscontainer_;
}
inline void Order::_internal_set_isomscontainer(bool value) {
  _impl_._has_bits_[3] |= 0x00080000u;
  _impl_.isomscontainer_ = value;
}

// optional bool discretionaryUpToLimitPrice = 113;
inline bool Order::has_discretionaryuptolimitprice() const {
  bool value = (_impl_._has_bits_[3] & 0x00100000u) != 0;
  return value;
}
inline void Order::clear_discretionaryuptolimitprice() {
  _impl_.discretionaryuptolimitprice_ = false;
  _impl_._has_bits_[3] &= ~0x00100000u;
}
inline bool Order::discretionaryuptolimitprice() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.discretionaryUpToLimitPrice)
  return _internal_discretionaryuptolimitprice();
}
inline void Order::set_discretionaryuptolimitprice(bool value) {
  _internal_set_discretionaryuptolimitprice(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.discretionaryUpToLimitPrice)
}
inline bool Order::_internal_discretionaryuptolimitprice() const {
  return _impl_.discretionaryuptolimitprice_;
}
inline void Order::_internal_set_discretionaryuptolimitprice(bool value) {
  _impl_._has_bits_[3] |= 0x00100000u;
  _impl_.discretionaryuptolimitprice_ = value;
}

// optional string autoCancelDate = 114;
inline bool Order::has_autocanceldate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline void Order::clear_autocanceldate() {
  _impl_.autocanceldate_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline const std::string& Order::autocanceldate() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.autoCancelDate)
  return _internal_autocanceldate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_autocanceldate(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.autocanceldate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.autoCancelDate)
}
inline std::string* Order::mutable_autocanceldate() {
  std::string* _s = _internal_mutable_autocanceldate();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.autoCancelDate)
  return _s;
}
inline const std::string& Order::_internal_autocanceldate() const {
  return _impl_.autocanceldate_.Get();
}
inline void Order::_internal_set_autocanceldate(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000080u;


  _impl_.autocanceldate_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_autocanceldate() {
  _impl_._has_bits_[1] |= 0x00000080u;
  return _impl_.autocanceldate_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_autocanceldate() {
  // @@protoc_insertion_point(field_release:protobuf.Order.autoCancelDate)
  if ((_impl_._has_bits_[1] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000080u;
  auto* released = _impl_.autocanceldate_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.autocanceldate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_autocanceldate(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }
  _impl_.autocanceldate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.autocanceldate_.IsDefault()) {
          _impl_.autocanceldate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.autoCancelDate)
}

// optional string filledQuantity = 115;
inline bool Order::has_filledquantity() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline void Order::clear_filledquantity() {
  _impl_.filledquantity_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline const std::string& Order::filledquantity() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.filledQuantity)
  return _internal_filledquantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_filledquantity(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.filledquantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.filledQuantity)
}
inline std::string* Order::mutable_filledquantity() {
  std::string* _s = _internal_mutable_filledquantity();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.filledQuantity)
  return _s;
}
inline const std::string& Order::_internal_filledquantity() const {
  return _impl_.filledquantity_.Get();
}
inline void Order::_internal_set_filledquantity(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000100u;


  _impl_.filledquantity_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_filledquantity() {
  _impl_._has_bits_[1] |= 0x00000100u;
  return _impl_.filledquantity_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_filledquantity() {
  // @@protoc_insertion_point(field_release:protobuf.Order.filledQuantity)
  if ((_impl_._has_bits_[1] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000100u;
  auto* released = _impl_.filledquantity_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filledquantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_filledquantity(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }
  _impl_.filledquantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filledquantity_.IsDefault()) {
          _impl_.filledquantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.filledQuantity)
}

// optional int32 refFuturesConId = 116;
inline bool Order::has_reffuturesconid() const {
  bool value = (_impl_._has_bits_[3] & 0x00400000u) != 0;
  return value;
}
inline void Order::clear_reffuturesconid() {
  _impl_.reffuturesconid_ = 0;
  _impl_._has_bits_[3] &= ~0x00400000u;
}
inline ::int32_t Order::reffuturesconid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.refFuturesConId)
  return _internal_reffuturesconid();
}
inline void Order::set_reffuturesconid(::int32_t value) {
  _internal_set_reffuturesconid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.refFuturesConId)
}
inline ::int32_t Order::_internal_reffuturesconid() const {
  return _impl_.reffuturesconid_;
}
inline void Order::_internal_set_reffuturesconid(::int32_t value) {
  _impl_._has_bits_[3] |= 0x00400000u;
  _impl_.reffuturesconid_ = value;
}

// optional bool autoCancelParent = 117;
inline bool Order::has_autocancelparent() const {
  bool value = (_impl_._has_bits_[3] & 0x00200000u) != 0;
  return value;
}
inline void Order::clear_autocancelparent() {
  _impl_.autocancelparent_ = false;
  _impl_._has_bits_[3] &= ~0x00200000u;
}
inline bool Order::autocancelparent() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.autoCancelParent)
  return _internal_autocancelparent();
}
inline void Order::set_autocancelparent(bool value) {
  _internal_set_autocancelparent(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.autoCancelParent)
}
inline bool Order::_internal_autocancelparent() const {
  return _impl_.autocancelparent_;
}
inline void Order::_internal_set_autocancelparent(bool value) {
  _impl_._has_bits_[3] |= 0x00200000u;
  _impl_.autocancelparent_ = value;
}

// optional string shareholder = 118;
inline bool Order::has_shareholder() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline void Order::clear_shareholder() {
  _impl_.shareholder_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline const std::string& Order::shareholder() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.shareholder)
  return _internal_shareholder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_shareholder(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.shareholder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.shareholder)
}
inline std::string* Order::mutable_shareholder() {
  std::string* _s = _internal_mutable_shareholder();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.shareholder)
  return _s;
}
inline const std::string& Order::_internal_shareholder() const {
  return _impl_.shareholder_.Get();
}
inline void Order::_internal_set_shareholder(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000200u;


  _impl_.shareholder_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_shareholder() {
  _impl_._has_bits_[1] |= 0x00000200u;
  return _impl_.shareholder_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_shareholder() {
  // @@protoc_insertion_point(field_release:protobuf.Order.shareholder)
  if ((_impl_._has_bits_[1] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000200u;
  auto* released = _impl_.shareholder_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.shareholder_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_shareholder(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }
  _impl_.shareholder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shareholder_.IsDefault()) {
          _impl_.shareholder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.shareholder)
}

// optional bool imbalanceOnly = 119;
inline bool Order::has_imbalanceonly() const {
  bool value = (_impl_._has_bits_[3] & 0x08000000u) != 0;
  return value;
}
inline void Order::clear_imbalanceonly() {
  _impl_.imbalanceonly_ = false;
  _impl_._has_bits_[3] &= ~0x08000000u;
}
inline bool Order::imbalanceonly() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.imbalanceOnly)
  return _internal_imbalanceonly();
}
inline void Order::set_imbalanceonly(bool value) {
  _internal_set_imbalanceonly(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.imbalanceOnly)
}
inline bool Order::_internal_imbalanceonly() const {
  return _impl_.imbalanceonly_;
}
inline void Order::_internal_set_imbalanceonly(bool value) {
  _impl_._has_bits_[3] |= 0x08000000u;
  _impl_.imbalanceonly_ = value;
}

// optional bool routeMarketableToBbo = 120;
inline bool Order::has_routemarketabletobbo() const {
  bool value = (_impl_._has_bits_[3] & 0x10000000u) != 0;
  return value;
}
inline void Order::clear_routemarketabletobbo() {
  _impl_.routemarketabletobbo_ = false;
  _impl_._has_bits_[3] &= ~0x10000000u;
}
inline bool Order::routemarketabletobbo() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.routeMarketableToBbo)
  return _internal_routemarketabletobbo();
}
inline void Order::set_routemarketabletobbo(bool value) {
  _internal_set_routemarketabletobbo(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.routeMarketableToBbo)
}
inline bool Order::_internal_routemarketabletobbo() const {
  return _impl_.routemarketabletobbo_;
}
inline void Order::_internal_set_routemarketabletobbo(bool value) {
  _impl_._has_bits_[3] |= 0x10000000u;
  _impl_.routemarketabletobbo_ = value;
}

// optional int64 parentPermId = 121;
inline bool Order::has_parentpermid() const {
  bool value = (_impl_._has_bits_[3] & 0x00800000u) != 0;
  return value;
}
inline void Order::clear_parentpermid() {
  _impl_.parentpermid_ = ::int64_t{0};
  _impl_._has_bits_[3] &= ~0x00800000u;
}
inline ::int64_t Order::parentpermid() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.parentPermId)
  return _internal_parentpermid();
}
inline void Order::set_parentpermid(::int64_t value) {
  _internal_set_parentpermid(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.parentPermId)
}
inline ::int64_t Order::_internal_parentpermid() const {
  return _impl_.parentpermid_;
}
inline void Order::_internal_set_parentpermid(::int64_t value) {
  _impl_._has_bits_[3] |= 0x00800000u;
  _impl_.parentpermid_ = value;
}

// optional int32 usePriceMgmtAlgo = 122;
inline bool Order::has_usepricemgmtalgo() const {
  bool value = (_impl_._has_bits_[3] & 0x01000000u) != 0;
  return value;
}
inline void Order::clear_usepricemgmtalgo() {
  _impl_.usepricemgmtalgo_ = 0;
  _impl_._has_bits_[3] &= ~0x01000000u;
}
inline ::int32_t Order::usepricemgmtalgo() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.usePriceMgmtAlgo)
  return _internal_usepricemgmtalgo();
}
inline void Order::set_usepricemgmtalgo(::int32_t value) {
  _internal_set_usepricemgmtalgo(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.usePriceMgmtAlgo)
}
inline ::int32_t Order::_internal_usepricemgmtalgo() const {
  return _impl_.usepricemgmtalgo_;
}
inline void Order::_internal_set_usepricemgmtalgo(::int32_t value) {
  _impl_._has_bits_[3] |= 0x01000000u;
  _impl_.usepricemgmtalgo_ = value;
}

// optional int32 duration = 123;
inline bool Order::has_duration() const {
  bool value = (_impl_._has_bits_[3] & 0x02000000u) != 0;
  return value;
}
inline void Order::clear_duration() {
  _impl_.duration_ = 0;
  _impl_._has_bits_[3] &= ~0x02000000u;
}
inline ::int32_t Order::duration() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.duration)
  return _internal_duration();
}
inline void Order::set_duration(::int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.duration)
}
inline ::int32_t Order::_internal_duration() const {
  return _impl_.duration_;
}
inline void Order::_internal_set_duration(::int32_t value) {
  _impl_._has_bits_[3] |= 0x02000000u;
  _impl_.duration_ = value;
}

// optional int32 postToAts = 124;
inline bool Order::has_posttoats() const {
  bool value = (_impl_._has_bits_[3] & 0x04000000u) != 0;
  return value;
}
inline void Order::clear_posttoats() {
  _impl_.posttoats_ = 0;
  _impl_._has_bits_[3] &= ~0x04000000u;
}
inline ::int32_t Order::posttoats() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.postToAts)
  return _internal_posttoats();
}
inline void Order::set_posttoats(::int32_t value) {
  _internal_set_posttoats(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.postToAts)
}
inline ::int32_t Order::_internal_posttoats() const {
  return _impl_.posttoats_;
}
inline void Order::_internal_set_posttoats(::int32_t value) {
  _impl_._has_bits_[3] |= 0x04000000u;
  _impl_.posttoats_ = value;
}

// optional string advancedErrorOverride = 125;
inline bool Order::has_advancederroroverride() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline void Order::clear_advancederroroverride() {
  _impl_.advancederroroverride_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline const std::string& Order::advancederroroverride() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.advancedErrorOverride)
  return _internal_advancederroroverride();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_advancederroroverride(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.advancederroroverride_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.advancedErrorOverride)
}
inline std::string* Order::mutable_advancederroroverride() {
  std::string* _s = _internal_mutable_advancederroroverride();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.advancedErrorOverride)
  return _s;
}
inline const std::string& Order::_internal_advancederroroverride() const {
  return _impl_.advancederroroverride_.Get();
}
inline void Order::_internal_set_advancederroroverride(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000400u;


  _impl_.advancederroroverride_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_advancederroroverride() {
  _impl_._has_bits_[1] |= 0x00000400u;
  return _impl_.advancederroroverride_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_advancederroroverride() {
  // @@protoc_insertion_point(field_release:protobuf.Order.advancedErrorOverride)
  if ((_impl_._has_bits_[1] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000400u;
  auto* released = _impl_.advancederroroverride_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.advancederroroverride_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_advancederroroverride(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }
  _impl_.advancederroroverride_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.advancederroroverride_.IsDefault()) {
          _impl_.advancederroroverride_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.advancedErrorOverride)
}

// optional string manualOrderTime = 126;
inline bool Order::has_manualordertime() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline void Order::clear_manualordertime() {
  _impl_.manualordertime_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline const std::string& Order::manualordertime() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.manualOrderTime)
  return _internal_manualordertime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_manualordertime(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.manualordertime_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.manualOrderTime)
}
inline std::string* Order::mutable_manualordertime() {
  std::string* _s = _internal_mutable_manualordertime();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.manualOrderTime)
  return _s;
}
inline const std::string& Order::_internal_manualordertime() const {
  return _impl_.manualordertime_.Get();
}
inline void Order::_internal_set_manualordertime(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000800u;


  _impl_.manualordertime_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_manualordertime() {
  _impl_._has_bits_[1] |= 0x00000800u;
  return _impl_.manualordertime_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_manualordertime() {
  // @@protoc_insertion_point(field_release:protobuf.Order.manualOrderTime)
  if ((_impl_._has_bits_[1] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000800u;
  auto* released = _impl_.manualordertime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manualordertime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_manualordertime(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }
  _impl_.manualordertime_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.manualordertime_.IsDefault()) {
          _impl_.manualordertime_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.manualOrderTime)
}

// optional int32 minTradeQty = 127;
inline bool Order::has_mintradeqty() const {
  bool value = (_impl_._has_bits_[3] & 0x80000000u) != 0;
  return value;
}
inline void Order::clear_mintradeqty() {
  _impl_.mintradeqty_ = 0;
  _impl_._has_bits_[3] &= ~0x80000000u;
}
inline ::int32_t Order::mintradeqty() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.minTradeQty)
  return _internal_mintradeqty();
}
inline void Order::set_mintradeqty(::int32_t value) {
  _internal_set_mintradeqty(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.minTradeQty)
}
inline ::int32_t Order::_internal_mintradeqty() const {
  return _impl_.mintradeqty_;
}
inline void Order::_internal_set_mintradeqty(::int32_t value) {
  _impl_._has_bits_[3] |= 0x80000000u;
  _impl_.mintradeqty_ = value;
}

// optional int32 minCompeteSize = 128;
inline bool Order::has_mincompetesize() const {
  bool value = (_impl_._has_bits_[4] & 0x00000001u) != 0;
  return value;
}
inline void Order::clear_mincompetesize() {
  _impl_.mincompetesize_ = 0;
  _impl_._has_bits_[4] &= ~0x00000001u;
}
inline ::int32_t Order::mincompetesize() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.minCompeteSize)
  return _internal_mincompetesize();
}
inline void Order::set_mincompetesize(::int32_t value) {
  _internal_set_mincompetesize(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.minCompeteSize)
}
inline ::int32_t Order::_internal_mincompetesize() const {
  return _impl_.mincompetesize_;
}
inline void Order::_internal_set_mincompetesize(::int32_t value) {
  _impl_._has_bits_[4] |= 0x00000001u;
  _impl_.mincompetesize_ = value;
}

// optional double competeAgainstBestOffset = 129;
inline bool Order::has_competeagainstbestoffset() const {
  bool value = (_impl_._has_bits_[4] & 0x00000002u) != 0;
  return value;
}
inline void Order::clear_competeagainstbestoffset() {
  _impl_.competeagainstbestoffset_ = 0;
  _impl_._has_bits_[4] &= ~0x00000002u;
}
inline double Order::competeagainstbestoffset() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.competeAgainstBestOffset)
  return _internal_competeagainstbestoffset();
}
inline void Order::set_competeagainstbestoffset(double value) {
  _internal_set_competeagainstbestoffset(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.competeAgainstBestOffset)
}
inline double Order::_internal_competeagainstbestoffset() const {
  return _impl_.competeagainstbestoffset_;
}
inline void Order::_internal_set_competeagainstbestoffset(double value) {
  _impl_._has_bits_[4] |= 0x00000002u;
  _impl_.competeagainstbestoffset_ = value;
}

// optional double midOffsetAtWhole = 130;
inline bool Order::has_midoffsetatwhole() const {
  bool value = (_impl_._has_bits_[4] & 0x00000004u) != 0;
  return value;
}
inline void Order::clear_midoffsetatwhole() {
  _impl_.midoffsetatwhole_ = 0;
  _impl_._has_bits_[4] &= ~0x00000004u;
}
inline double Order::midoffsetatwhole() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.midOffsetAtWhole)
  return _internal_midoffsetatwhole();
}
inline void Order::set_midoffsetatwhole(double value) {
  _internal_set_midoffsetatwhole(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.midOffsetAtWhole)
}
inline double Order::_internal_midoffsetatwhole() const {
  return _impl_.midoffsetatwhole_;
}
inline void Order::_internal_set_midoffsetatwhole(double value) {
  _impl_._has_bits_[4] |= 0x00000004u;
  _impl_.midoffsetatwhole_ = value;
}

// optional double midOffsetAtHalf = 131;
inline bool Order::has_midoffsetathalf() const {
  bool value = (_impl_._has_bits_[4] & 0x00000008u) != 0;
  return value;
}
inline void Order::clear_midoffsetathalf() {
  _impl_.midoffsetathalf_ = 0;
  _impl_._has_bits_[4] &= ~0x00000008u;
}
inline double Order::midoffsetathalf() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.midOffsetAtHalf)
  return _internal_midoffsetathalf();
}
inline void Order::set_midoffsetathalf(double value) {
  _internal_set_midoffsetathalf(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.midOffsetAtHalf)
}
inline double Order::_internal_midoffsetathalf() const {
  return _impl_.midoffsetathalf_;
}
inline void Order::_internal_set_midoffsetathalf(double value) {
  _impl_._has_bits_[4] |= 0x00000008u;
  _impl_.midoffsetathalf_ = value;
}

// optional string customerAccount = 132;
inline bool Order::has_customeraccount() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline void Order::clear_customeraccount() {
  _impl_.customeraccount_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline const std::string& Order::customeraccount() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.customerAccount)
  return _internal_customeraccount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_customeraccount(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.customeraccount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.customerAccount)
}
inline std::string* Order::mutable_customeraccount() {
  std::string* _s = _internal_mutable_customeraccount();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.customerAccount)
  return _s;
}
inline const std::string& Order::_internal_customeraccount() const {
  return _impl_.customeraccount_.Get();
}
inline void Order::_internal_set_customeraccount(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00001000u;


  _impl_.customeraccount_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_customeraccount() {
  _impl_._has_bits_[1] |= 0x00001000u;
  return _impl_.customeraccount_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_customeraccount() {
  // @@protoc_insertion_point(field_release:protobuf.Order.customerAccount)
  if ((_impl_._has_bits_[1] & 0x00001000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00001000u;
  auto* released = _impl_.customeraccount_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.customeraccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_customeraccount(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00001000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00001000u;
  }
  _impl_.customeraccount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.customeraccount_.IsDefault()) {
          _impl_.customeraccount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.customerAccount)
}

// optional bool professionalCustomer = 133;
inline bool Order::has_professionalcustomer() const {
  bool value = (_impl_._has_bits_[3] & 0x20000000u) != 0;
  return value;
}
inline void Order::clear_professionalcustomer() {
  _impl_.professionalcustomer_ = false;
  _impl_._has_bits_[3] &= ~0x20000000u;
}
inline bool Order::professionalcustomer() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.professionalCustomer)
  return _internal_professionalcustomer();
}
inline void Order::set_professionalcustomer(bool value) {
  _internal_set_professionalcustomer(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.professionalCustomer)
}
inline bool Order::_internal_professionalcustomer() const {
  return _impl_.professionalcustomer_;
}
inline void Order::_internal_set_professionalcustomer(bool value) {
  _impl_._has_bits_[3] |= 0x20000000u;
  _impl_.professionalcustomer_ = value;
}

// optional string bondAccruedInterest = 134;
inline bool Order::has_bondaccruedinterest() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline void Order::clear_bondaccruedinterest() {
  _impl_.bondaccruedinterest_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline const std::string& Order::bondaccruedinterest() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.bondAccruedInterest)
  return _internal_bondaccruedinterest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_bondaccruedinterest(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.bondaccruedinterest_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.bondAccruedInterest)
}
inline std::string* Order::mutable_bondaccruedinterest() {
  std::string* _s = _internal_mutable_bondaccruedinterest();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.bondAccruedInterest)
  return _s;
}
inline const std::string& Order::_internal_bondaccruedinterest() const {
  return _impl_.bondaccruedinterest_.Get();
}
inline void Order::_internal_set_bondaccruedinterest(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00002000u;


  _impl_.bondaccruedinterest_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_bondaccruedinterest() {
  _impl_._has_bits_[1] |= 0x00002000u;
  return _impl_.bondaccruedinterest_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_bondaccruedinterest() {
  // @@protoc_insertion_point(field_release:protobuf.Order.bondAccruedInterest)
  if ((_impl_._has_bits_[1] & 0x00002000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00002000u;
  auto* released = _impl_.bondaccruedinterest_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bondaccruedinterest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_bondaccruedinterest(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00002000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00002000u;
  }
  _impl_.bondaccruedinterest_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bondaccruedinterest_.IsDefault()) {
          _impl_.bondaccruedinterest_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.bondAccruedInterest)
}

// optional bool includeOvernight = 135;
inline bool Order::has_includeovernight() const {
  bool value = (_impl_._has_bits_[3] & 0x40000000u) != 0;
  return value;
}
inline void Order::clear_includeovernight() {
  _impl_.includeovernight_ = false;
  _impl_._has_bits_[3] &= ~0x40000000u;
}
inline bool Order::includeovernight() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.includeOvernight)
  return _internal_includeovernight();
}
inline void Order::set_includeovernight(bool value) {
  _internal_set_includeovernight(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.includeOvernight)
}
inline bool Order::_internal_includeovernight() const {
  return _impl_.includeovernight_;
}
inline void Order::_internal_set_includeovernight(bool value) {
  _impl_._has_bits_[3] |= 0x40000000u;
  _impl_.includeovernight_ = value;
}

// optional int32 manualOrderIndicator = 136;
inline bool Order::has_manualorderindicator() const {
  bool value = (_impl_._has_bits_[4] & 0x00000010u) != 0;
  return value;
}
inline void Order::clear_manualorderindicator() {
  _impl_.manualorderindicator_ = 0;
  _impl_._has_bits_[4] &= ~0x00000010u;
}
inline ::int32_t Order::manualorderindicator() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.manualOrderIndicator)
  return _internal_manualorderindicator();
}
inline void Order::set_manualorderindicator(::int32_t value) {
  _internal_set_manualorderindicator(value);
  // @@protoc_insertion_point(field_set:protobuf.Order.manualOrderIndicator)
}
inline ::int32_t Order::_internal_manualorderindicator() const {
  return _impl_.manualorderindicator_;
}
inline void Order::_internal_set_manualorderindicator(::int32_t value) {
  _impl_._has_bits_[4] |= 0x00000010u;
  _impl_.manualorderindicator_ = value;
}

// optional string submitter = 137;
inline bool Order::has_submitter() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline void Order::clear_submitter() {
  _impl_.submitter_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline const std::string& Order::submitter() const {
  // @@protoc_insertion_point(field_get:protobuf.Order.submitter)
  return _internal_submitter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Order::set_submitter(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.submitter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.Order.submitter)
}
inline std::string* Order::mutable_submitter() {
  std::string* _s = _internal_mutable_submitter();
  // @@protoc_insertion_point(field_mutable:protobuf.Order.submitter)
  return _s;
}
inline const std::string& Order::_internal_submitter() const {
  return _impl_.submitter_.Get();
}
inline void Order::_internal_set_submitter(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00004000u;


  _impl_.submitter_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_submitter() {
  _impl_._has_bits_[1] |= 0x00004000u;
  return _impl_.submitter_.Mutable( GetArenaForAllocation());
}
inline std::string* Order::release_submitter() {
  // @@protoc_insertion_point(field_release:protobuf.Order.submitter)
  if ((_impl_._has_bits_[1] & 0x00004000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00004000u;
  auto* released = _impl_.submitter_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.submitter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Order::set_allocated_submitter(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00004000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00004000u;
  }
  _impl_.submitter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.submitter_.IsDefault()) {
          _impl_.submitter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Order.submitter)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protobuf


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_Order_2eproto_2epb_2eh
