// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Order.proto

#include "Order.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace protobuf {
template <typename>
PROTOBUF_CONSTEXPR Order_AlgoParamsEntry_DoNotUse::Order_AlgoParamsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Order_AlgoParamsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Order_AlgoParamsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Order_AlgoParamsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Order_AlgoParamsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Order_AlgoParamsEntry_DoNotUseDefaultTypeInternal _Order_AlgoParamsEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Order_SmartComboRoutingParamsEntry_DoNotUse::Order_SmartComboRoutingParamsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Order_SmartComboRoutingParamsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Order_SmartComboRoutingParamsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Order_SmartComboRoutingParamsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Order_SmartComboRoutingParamsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Order_SmartComboRoutingParamsEntry_DoNotUseDefaultTypeInternal _Order_SmartComboRoutingParamsEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Order_OrderMiscOptionsEntry_DoNotUse::Order_OrderMiscOptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Order_OrderMiscOptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Order_OrderMiscOptionsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Order_OrderMiscOptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Order_OrderMiscOptionsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Order_OrderMiscOptionsEntry_DoNotUseDefaultTypeInternal _Order_OrderMiscOptionsEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Order::Order(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.algoparams_)*/{}
  , /*decltype(_impl_.smartcomboroutingparams_)*/{}
  , /*decltype(_impl_.ordermiscoptions_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.action_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.totalquantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ordertype_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.tif_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.settlingfirm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.clearingaccount_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.clearingintent_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.goodaftertime_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.goodtilldate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ocagroup_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.orderref_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.rule80a_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.activestarttime_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.activestoptime_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fagroup_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.famethod_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fapercentage_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deltaneutralordertype_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deltaneutralopenclose_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deltaneutraldesignatedlocation_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.scaletable_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hedgetype_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hedgeparam_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.algostrategy_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.algoid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.openclose_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.designatedlocation_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deltaneutralsettlingfirm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deltaneutralclearingaccount_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deltaneutralclearingintent_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.referenceexchangeid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.adjustedordertype_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.modelcode_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.extoperator_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.mifid2decisionmaker_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.mifid2decisionalgo_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.mifid2executiontrader_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.mifid2executionalgo_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.autocanceldate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.filledquantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.shareholder_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.advancederroroverride_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.manualordertime_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.customeraccount_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.bondaccruedinterest_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.submitter_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.softdollartier_)*/nullptr
  , /*decltype(_impl_.clientid_)*/ 0

  , /*decltype(_impl_.orderid_)*/ 0

  , /*decltype(_impl_.permid_)*/ ::int64_t{0}

  , /*decltype(_impl_.parentid_)*/ 0

  , /*decltype(_impl_.displaysize_)*/ 0

  , /*decltype(_impl_.lmtprice_)*/ 0

  , /*decltype(_impl_.auxprice_)*/ 0

  , /*decltype(_impl_.allornone_)*/ false

  , /*decltype(_impl_.blockorder_)*/ false

  , /*decltype(_impl_.hidden_)*/ false

  , /*decltype(_impl_.outsiderth_)*/ false

  , /*decltype(_impl_.minqty_)*/ 0

  , /*decltype(_impl_.percentoffset_)*/ 0

  , /*decltype(_impl_.trailingpercent_)*/ 0

  , /*decltype(_impl_.trailstopprice_)*/ 0

  , /*decltype(_impl_.ocatype_)*/ 0

  , /*decltype(_impl_.triggermethod_)*/ 0

  , /*decltype(_impl_.volatility_)*/ 0

  , /*decltype(_impl_.volatilitytype_)*/ 0

  , /*decltype(_impl_.sweeptofill_)*/ false

  , /*decltype(_impl_.continuousupdate_)*/ false

  , /*decltype(_impl_.deltaneutralshortsale_)*/ false

  , /*decltype(_impl_.scaleautoreset_)*/ false

  , /*decltype(_impl_.referencepricetype_)*/ 0

  , /*decltype(_impl_.deltaneutralconid_)*/ 0

  , /*decltype(_impl_.deltaneutralauxprice_)*/ 0

  , /*decltype(_impl_.deltaneutralshortsaleslot_)*/ 0

  , /*decltype(_impl_.scaleinitlevelsize_)*/ 0

  , /*decltype(_impl_.scalepriceincrement_)*/ 0

  , /*decltype(_impl_.scalesubslevelsize_)*/ 0

  , /*decltype(_impl_.scalepriceadjustinterval_)*/ 0

  , /*decltype(_impl_.scalepriceadjustvalue_)*/ 0

  , /*decltype(_impl_.scaleprofitoffset_)*/ 0

  , /*decltype(_impl_.scaleinitposition_)*/ 0

  , /*decltype(_impl_.scaleinitfillqty_)*/ 0

  , /*decltype(_impl_.scalerandompercent_)*/ false

  , /*decltype(_impl_.whatif_)*/ false

  , /*decltype(_impl_.transmit_)*/ false

  , /*decltype(_impl_.overridepercentageconstraints_)*/ false

  , /*decltype(_impl_.origin_)*/ 0

  , /*decltype(_impl_.shortsaleslot_)*/ 0

  , /*decltype(_impl_.exemptcode_)*/ 0

  , /*decltype(_impl_.discretionaryamt_)*/ 0

  , /*decltype(_impl_.startingprice_)*/ 0

  , /*decltype(_impl_.stockrefprice_)*/ 0

  , /*decltype(_impl_.delta_)*/ 0

  , /*decltype(_impl_.stockrangelower_)*/ 0

  , /*decltype(_impl_.stockrangeupper_)*/ 0

  , /*decltype(_impl_.optoutsmartrouting_)*/ false

  , /*decltype(_impl_.notheld_)*/ false

  , /*decltype(_impl_.solicited_)*/ false

  , /*decltype(_impl_.randomizesize_)*/ false

  , /*decltype(_impl_.referencecontractid_)*/ 0

  , /*decltype(_impl_.peggedchangeamount_)*/ 0

  , /*decltype(_impl_.referencechangeamount_)*/ 0

  , /*decltype(_impl_.triggerprice_)*/ 0

  , /*decltype(_impl_.adjustedstopprice_)*/ 0

  , /*decltype(_impl_.randomizeprice_)*/ false

  , /*decltype(_impl_.ispeggedchangeamountdecrease_)*/ false

  , /*decltype(_impl_.conditionscancelorder_)*/ false

  , /*decltype(_impl_.conditionsignorerth_)*/ false

  , /*decltype(_impl_.adjustabletrailingunit_)*/ 0

  , /*decltype(_impl_.adjustedstoplimitprice_)*/ 0

  , /*decltype(_impl_.adjustedtrailingamount_)*/ 0

  , /*decltype(_impl_.lmtpriceoffset_)*/ 0

  , /*decltype(_impl_.cashqty_)*/ 0

  , /*decltype(_impl_.dontuseautopriceforhedge_)*/ false

  , /*decltype(_impl_.isomscontainer_)*/ false

  , /*decltype(_impl_.discretionaryuptolimitprice_)*/ false

  , /*decltype(_impl_.autocancelparent_)*/ false

  , /*decltype(_impl_.reffuturesconid_)*/ 0

  , /*decltype(_impl_.parentpermid_)*/ ::int64_t{0}

  , /*decltype(_impl_.usepricemgmtalgo_)*/ 0

  , /*decltype(_impl_.duration_)*/ 0

  , /*decltype(_impl_.posttoats_)*/ 0

  , /*decltype(_impl_.imbalanceonly_)*/ false

  , /*decltype(_impl_.routemarketabletobbo_)*/ false

  , /*decltype(_impl_.professionalcustomer_)*/ false

  , /*decltype(_impl_.includeovernight_)*/ false

  , /*decltype(_impl_.mintradeqty_)*/ 0

  , /*decltype(_impl_.mincompetesize_)*/ 0

  , /*decltype(_impl_.competeagainstbestoffset_)*/ 0

  , /*decltype(_impl_.midoffsetatwhole_)*/ 0

  , /*decltype(_impl_.midoffsetathalf_)*/ 0

  , /*decltype(_impl_.manualorderindicator_)*/ 0
} {}
struct OrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderDefaultTypeInternal() {}
  union {
    Order _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderDefaultTypeInternal _Order_default_instance_;
}  // namespace protobuf
static ::_pb::Metadata file_level_metadata_Order_2eproto[4];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_Order_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_Order_2eproto = nullptr;
const ::uint32_t TableStruct_Order_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_AlgoParamsEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_AlgoParamsEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_AlgoParamsEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_AlgoParamsEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_OrderMiscOptionsEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_OrderMiscOptionsEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_OrderMiscOptionsEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order_OrderMiscOptionsEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.clientid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.orderid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.permid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.parentid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.action_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.totalquantity_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.displaysize_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.ordertype_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.lmtprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.auxprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.tif_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.settlingfirm_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.clearingaccount_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.clearingintent_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.allornone_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.blockorder_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.hidden_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.outsiderth_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.sweeptofill_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.percentoffset_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.trailingpercent_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.trailstopprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.minqty_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.goodaftertime_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.goodtilldate_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.ocagroup_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.orderref_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.rule80a_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.ocatype_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.triggermethod_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.activestarttime_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.activestoptime_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.fagroup_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.famethod_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.fapercentage_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.volatility_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.volatilitytype_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.continuousupdate_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.referencepricetype_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralordertype_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralauxprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralconid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralopenclose_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralshortsale_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralshortsaleslot_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutraldesignatedlocation_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scaleinitlevelsize_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scalesubslevelsize_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scalepriceincrement_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scalepriceadjustvalue_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scalepriceadjustinterval_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scaleprofitoffset_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scaleautoreset_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scaleinitposition_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scaleinitfillqty_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scalerandompercent_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.scaletable_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.hedgetype_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.hedgeparam_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.algostrategy_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.algoparams_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.algoid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.smartcomboroutingparams_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.whatif_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.transmit_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.overridepercentageconstraints_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.openclose_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.shortsaleslot_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.designatedlocation_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.exemptcode_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralsettlingfirm_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralclearingaccount_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.deltaneutralclearingintent_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.discretionaryamt_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.optoutsmartrouting_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.startingprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.stockrefprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.delta_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.stockrangelower_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.stockrangeupper_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.notheld_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.ordermiscoptions_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.solicited_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.randomizesize_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.randomizeprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.referencecontractid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.peggedchangeamount_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.ispeggedchangeamountdecrease_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.referencechangeamount_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.referenceexchangeid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.adjustedordertype_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.triggerprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.adjustedstopprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.adjustedstoplimitprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.adjustedtrailingamount_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.adjustabletrailingunit_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.lmtpriceoffset_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.conditions_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.conditionscancelorder_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.conditionsignorerth_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.modelcode_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.extoperator_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.softdollartier_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.cashqty_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.mifid2decisionmaker_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.mifid2decisionalgo_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.mifid2executiontrader_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.mifid2executionalgo_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.dontuseautopriceforhedge_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.isomscontainer_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.discretionaryuptolimitprice_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.autocanceldate_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.filledquantity_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.reffuturesconid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.autocancelparent_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.shareholder_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.imbalanceonly_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.routemarketabletobbo_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.parentpermid_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.usepricemgmtalgo_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.duration_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.posttoats_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.advancederroroverride_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.manualordertime_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.mintradeqty_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.mincompetesize_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.competeagainstbestoffset_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.midoffsetatwhole_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.midoffsetathalf_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.customeraccount_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.professionalcustomer_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.bondaccruedinterest_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.includeovernight_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.manualorderindicator_),
    PROTOBUF_FIELD_OFFSET(::protobuf::Order, _impl_.submitter_),
    48,
    49,
    50,
    51,
    0,
    1,
    52,
    2,
    53,
    54,
    3,
    4,
    5,
    6,
    7,
    55,
    56,
    57,
    58,
    67,
    60,
    61,
    62,
    59,
    8,
    9,
    10,
    11,
    12,
    63,
    64,
    13,
    14,
    15,
    16,
    17,
    65,
    66,
    68,
    71,
    18,
    73,
    72,
    19,
    69,
    74,
    20,
    75,
    77,
    76,
    79,
    78,
    80,
    70,
    81,
    82,
    83,
    21,
    22,
    23,
    24,
    ~0u,
    25,
    ~0u,
    84,
    85,
    86,
    26,
    87,
    88,
    27,
    89,
    28,
    29,
    30,
    90,
    96,
    91,
    92,
    93,
    94,
    95,
    97,
    ~0u,
    98,
    99,
    105,
    100,
    101,
    106,
    102,
    31,
    32,
    103,
    104,
    110,
    111,
    109,
    112,
    ~0u,
    107,
    108,
    33,
    34,
    47,
    113,
    35,
    36,
    37,
    38,
    114,
    115,
    116,
    39,
    40,
    118,
    117,
    41,
    123,
    124,
    119,
    120,
    121,
    122,
    42,
    43,
    127,
    128,
    129,
    130,
    131,
    44,
    125,
    45,
    126,
    132,
    46,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 10, -1, sizeof(::protobuf::Order_AlgoParamsEntry_DoNotUse)},
        { 12, 22, -1, sizeof(::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse)},
        { 24, 34, -1, sizeof(::protobuf::Order_OrderMiscOptionsEntry_DoNotUse)},
        { 36, 181, -1, sizeof(::protobuf::Order)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::protobuf::_Order_AlgoParamsEntry_DoNotUse_default_instance_._instance,
    &::protobuf::_Order_SmartComboRoutingParamsEntry_DoNotUse_default_instance_._instance,
    &::protobuf::_Order_OrderMiscOptionsEntry_DoNotUse_default_instance_._instance,
    &::protobuf::_Order_default_instance_._instance,
};
const char descriptor_table_protodef_Order_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\013Order.proto\022\010protobuf\032\024OrderCondition."
    "proto\032\024SoftDollarTier.proto\"\2776\n\005Order\022\025\n"
    "\010clientId\030\001 \001(\005H\000\210\001\001\022\024\n\007orderId\030\002 \001(\005H\001\210"
    "\001\001\022\023\n\006permId\030\003 \001(\003H\002\210\001\001\022\025\n\010parentId\030\004 \001("
    "\005H\003\210\001\001\022\023\n\006action\030\005 \001(\tH\004\210\001\001\022\032\n\rtotalQuan"
    "tity\030\006 \001(\tH\005\210\001\001\022\030\n\013displaySize\030\007 \001(\005H\006\210\001"
    "\001\022\026\n\torderType\030\010 \001(\tH\007\210\001\001\022\025\n\010lmtPrice\030\t "
    "\001(\001H\010\210\001\001\022\025\n\010auxPrice\030\n \001(\001H\t\210\001\001\022\020\n\003tif\030\013"
    " \001(\tH\n\210\001\001\022\024\n\007account\030\014 \001(\tH\013\210\001\001\022\031\n\014settl"
    "ingFirm\030\r \001(\tH\014\210\001\001\022\034\n\017clearingAccount\030\016 "
    "\001(\tH\r\210\001\001\022\033\n\016clearingIntent\030\017 \001(\tH\016\210\001\001\022\026\n"
    "\tallOrNone\030\020 \001(\010H\017\210\001\001\022\027\n\nblockOrder\030\021 \001("
    "\010H\020\210\001\001\022\023\n\006hidden\030\022 \001(\010H\021\210\001\001\022\027\n\noutsideRt"
    "h\030\023 \001(\010H\022\210\001\001\022\030\n\013sweepToFill\030\024 \001(\010H\023\210\001\001\022\032"
    "\n\rpercentOffset\030\025 \001(\001H\024\210\001\001\022\034\n\017trailingPe"
    "rcent\030\026 \001(\001H\025\210\001\001\022\033\n\016trailStopPrice\030\027 \001(\001"
    "H\026\210\001\001\022\023\n\006minQty\030\030 \001(\005H\027\210\001\001\022\032\n\rgoodAfterT"
    "ime\030\031 \001(\tH\030\210\001\001\022\031\n\014goodTillDate\030\032 \001(\tH\031\210\001"
    "\001\022\025\n\010ocaGroup\030\033 \001(\tH\032\210\001\001\022\025\n\010orderRef\030\034 \001"
    "(\tH\033\210\001\001\022\024\n\007rule80A\030\035 \001(\tH\034\210\001\001\022\024\n\007ocaType"
    "\030\036 \001(\005H\035\210\001\001\022\032\n\rtriggerMethod\030\037 \001(\005H\036\210\001\001\022"
    "\034\n\017activeStartTime\030  \001(\tH\037\210\001\001\022\033\n\016activeS"
    "topTime\030! \001(\tH \210\001\001\022\024\n\007faGroup\030\" \001(\tH!\210\001\001"
    "\022\025\n\010faMethod\030# \001(\tH\"\210\001\001\022\031\n\014faPercentage\030"
    "$ \001(\tH#\210\001\001\022\027\n\nvolatility\030% \001(\001H$\210\001\001\022\033\n\016v"
    "olatilityType\030& \001(\005H%\210\001\001\022\035\n\020continuousUp"
    "date\030\' \001(\010H&\210\001\001\022\037\n\022referencePriceType\030( "
    "\001(\005H\'\210\001\001\022\"\n\025deltaNeutralOrderType\030) \001(\tH"
    "(\210\001\001\022!\n\024deltaNeutralAuxPrice\030* \001(\001H)\210\001\001\022"
    "\036\n\021deltaNeutralConId\030+ \001(\005H*\210\001\001\022\"\n\025delta"
    "NeutralOpenClose\030, \001(\tH+\210\001\001\022\"\n\025deltaNeut"
    "ralShortSale\030- \001(\010H,\210\001\001\022&\n\031deltaNeutralS"
    "hortSaleSlot\030. \001(\005H-\210\001\001\022+\n\036deltaNeutralD"
    "esignatedLocation\030/ \001(\tH.\210\001\001\022\037\n\022scaleIni"
    "tLevelSize\0300 \001(\005H/\210\001\001\022\037\n\022scaleSubsLevelS"
    "ize\0301 \001(\005H0\210\001\001\022 \n\023scalePriceIncrement\0302 "
    "\001(\001H1\210\001\001\022\"\n\025scalePriceAdjustValue\0303 \001(\001H"
    "2\210\001\001\022%\n\030scalePriceAdjustInterval\0304 \001(\005H3"
    "\210\001\001\022\036\n\021scaleProfitOffset\0305 \001(\001H4\210\001\001\022\033\n\016s"
    "caleAutoReset\0306 \001(\010H5\210\001\001\022\036\n\021scaleInitPos"
    "ition\0307 \001(\005H6\210\001\001\022\035\n\020scaleInitFillQty\0308 \001"
    "(\005H7\210\001\001\022\037\n\022scaleRandomPercent\0309 \001(\010H8\210\001\001"
    "\022\027\n\nscaleTable\030: \001(\tH9\210\001\001\022\026\n\thedgeType\030;"
    " \001(\tH:\210\001\001\022\027\n\nhedgeParam\030< \001(\tH;\210\001\001\022\031\n\014al"
    "goStrategy\030= \001(\tH<\210\001\001\0223\n\nalgoParams\030> \003("
    "\0132\037.protobuf.Order.AlgoParamsEntry\022\023\n\006al"
    "goId\030\? \001(\tH=\210\001\001\022M\n\027smartComboRoutingPara"
    "ms\030@ \003(\0132,.protobuf.Order.SmartComboRout"
    "ingParamsEntry\022\023\n\006whatIf\030A \001(\010H>\210\001\001\022\025\n\010t"
    "ransmit\030B \001(\010H\?\210\001\001\022*\n\035overridePercentage"
    "Constraints\030C \001(\010H@\210\001\001\022\026\n\topenClose\030D \001("
    "\tHA\210\001\001\022\023\n\006origin\030E \001(\005HB\210\001\001\022\032\n\rshortSale"
    "Slot\030F \001(\005HC\210\001\001\022\037\n\022designatedLocation\030G "
    "\001(\tHD\210\001\001\022\027\n\nexemptCode\030H \001(\005HE\210\001\001\022%\n\030del"
    "taNeutralSettlingFirm\030I \001(\tHF\210\001\001\022(\n\033delt"
    "aNeutralClearingAccount\030J \001(\tHG\210\001\001\022\'\n\032de"
    "ltaNeutralClearingIntent\030K \001(\tHH\210\001\001\022\035\n\020d"
    "iscretionaryAmt\030L \001(\001HI\210\001\001\022\037\n\022optOutSmar"
    "tRouting\030M \001(\010HJ\210\001\001\022\032\n\rstartingPrice\030N \001"
    "(\001HK\210\001\001\022\032\n\rstockRefPrice\030O \001(\001HL\210\001\001\022\022\n\005d"
    "elta\030P \001(\001HM\210\001\001\022\034\n\017stockRangeLower\030Q \001(\001"
    "HN\210\001\001\022\034\n\017stockRangeUpper\030R \001(\001HO\210\001\001\022\024\n\007n"
    "otHeld\030S \001(\010HP\210\001\001\022\?\n\020orderMiscOptions\030T "
    "\003(\0132%.protobuf.Order.OrderMiscOptionsEnt"
    "ry\022\026\n\tsolicited\030U \001(\010HQ\210\001\001\022\032\n\rrandomizeS"
    "ize\030V \001(\010HR\210\001\001\022\033\n\016randomizePrice\030W \001(\010HS"
    "\210\001\001\022 \n\023referenceContractId\030X \001(\005HT\210\001\001\022\037\n"
    "\022peggedChangeAmount\030Y \001(\001HU\210\001\001\022)\n\034isPegg"
    "edChangeAmountDecrease\030Z \001(\010HV\210\001\001\022\"\n\025ref"
    "erenceChangeAmount\030[ \001(\001HW\210\001\001\022 \n\023referen"
    "ceExchangeId\030\\ \001(\tHX\210\001\001\022\036\n\021adjustedOrder"
    "Type\030] \001(\tHY\210\001\001\022\031\n\014triggerPrice\030^ \001(\001HZ\210"
    "\001\001\022\036\n\021adjustedStopPrice\030_ \001(\001H[\210\001\001\022#\n\026ad"
    "justedStopLimitPrice\030` \001(\001H\\\210\001\001\022#\n\026adjus"
    "tedTrailingAmount\030a \001(\001H]\210\001\001\022#\n\026adjustab"
    "leTrailingUnit\030b \001(\005H^\210\001\001\022\033\n\016lmtPriceOff"
    "set\030c \001(\001H_\210\001\001\022,\n\nconditions\030d \003(\0132\030.pro"
    "tobuf.OrderCondition\022\"\n\025conditionsCancel"
    "Order\030e \001(\010H`\210\001\001\022 \n\023conditionsIgnoreRth\030"
    "f \001(\010Ha\210\001\001\022\026\n\tmodelCode\030g \001(\tHb\210\001\001\022\030\n\013ex"
    "tOperator\030h \001(\tHc\210\001\001\0225\n\016softDollarTier\030i"
    " \001(\0132\030.protobuf.SoftDollarTierHd\210\001\001\022\024\n\007c"
    "ashQty\030j \001(\001He\210\001\001\022 \n\023mifid2DecisionMaker"
    "\030k \001(\tHf\210\001\001\022\037\n\022mifid2DecisionAlgo\030l \001(\tH"
    "g\210\001\001\022\"\n\025mifid2ExecutionTrader\030m \001(\tHh\210\001\001"
    "\022 \n\023mifid2ExecutionAlgo\030n \001(\tHi\210\001\001\022%\n\030do"
    "ntUseAutoPriceForHedge\030o \001(\010Hj\210\001\001\022\033\n\016isO"
    "msContainer\030p \001(\010Hk\210\001\001\022(\n\033discretionaryU"
    "pToLimitPrice\030q \001(\010Hl\210\001\001\022\033\n\016autoCancelDa"
    "te\030r \001(\tHm\210\001\001\022\033\n\016filledQuantity\030s \001(\tHn\210"
    "\001\001\022\034\n\017refFuturesConId\030t \001(\005Ho\210\001\001\022\035\n\020auto"
    "CancelParent\030u \001(\010Hp\210\001\001\022\030\n\013shareholder\030v"
    " \001(\tHq\210\001\001\022\032\n\rimbalanceOnly\030w \001(\010Hr\210\001\001\022!\n"
    "\024routeMarketableToBbo\030x \001(\010Hs\210\001\001\022\031\n\014pare"
    "ntPermId\030y \001(\003Ht\210\001\001\022\035\n\020usePriceMgmtAlgo\030"
    "z \001(\005Hu\210\001\001\022\025\n\010duration\030{ \001(\005Hv\210\001\001\022\026\n\tpos"
    "tToAts\030| \001(\005Hw\210\001\001\022\"\n\025advancedErrorOverri"
    "de\030} \001(\tHx\210\001\001\022\034\n\017manualOrderTime\030~ \001(\tHy"
    "\210\001\001\022\030\n\013minTradeQty\030\177 \001(\005Hz\210\001\001\022\034\n\016minComp"
    "eteSize\030\200\001 \001(\005H{\210\001\001\022&\n\030competeAgainstBes"
    "tOffset\030\201\001 \001(\001H|\210\001\001\022\036\n\020midOffsetAtWhole\030"
    "\202\001 \001(\001H}\210\001\001\022\035\n\017midOffsetAtHalf\030\203\001 \001(\001H~\210"
    "\001\001\022\035\n\017customerAccount\030\204\001 \001(\tH\177\210\001\001\022#\n\024pro"
    "fessionalCustomer\030\205\001 \001(\010H\200\001\210\001\001\022\"\n\023bondAc"
    "cruedInterest\030\206\001 \001(\tH\201\001\210\001\001\022\037\n\020includeOve"
    "rnight\030\207\001 \001(\010H\202\001\210\001\001\022#\n\024manualOrderIndica"
    "tor\030\210\001 \001(\005H\203\001\210\001\001\022\030\n\tsubmitter\030\211\001 \001(\tH\204\001\210"
    "\001\001\0321\n\017AlgoParamsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005va"
    "lue\030\002 \001(\t:\0028\001\032>\n\034SmartComboRoutingParams"
    "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0327\n"
    "\025OrderMiscOptionsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005v"
    "alue\030\002 \001(\t:\0028\001B\013\n\t_clientIdB\n\n\010_orderIdB"
    "\t\n\007_permIdB\013\n\t_parentIdB\t\n\007_actionB\020\n\016_t"
    "otalQuantityB\016\n\014_displaySizeB\014\n\n_orderTy"
    "peB\013\n\t_lmtPriceB\013\n\t_auxPriceB\006\n\004_tifB\n\n\010"
    "_accountB\017\n\r_settlingFirmB\022\n\020_clearingAc"
    "countB\021\n\017_clearingIntentB\014\n\n_allOrNoneB\r"
    "\n\013_blockOrderB\t\n\007_hiddenB\r\n\013_outsideRthB"
    "\016\n\014_sweepToFillB\020\n\016_percentOffsetB\022\n\020_tr"
    "ailingPercentB\021\n\017_trailStopPriceB\t\n\007_min"
    "QtyB\020\n\016_goodAfterTimeB\017\n\r_goodTillDateB\013"
    "\n\t_ocaGroupB\013\n\t_orderRefB\n\n\010_rule80AB\n\n\010"
    "_ocaTypeB\020\n\016_triggerMethodB\022\n\020_activeSta"
    "rtTimeB\021\n\017_activeStopTimeB\n\n\010_faGroupB\013\n"
    "\t_faMethodB\017\n\r_faPercentageB\r\n\013_volatili"
    "tyB\021\n\017_volatilityTypeB\023\n\021_continuousUpda"
    "teB\025\n\023_referencePriceTypeB\030\n\026_deltaNeutr"
    "alOrderTypeB\027\n\025_deltaNeutralAuxPriceB\024\n\022"
    "_deltaNeutralConIdB\030\n\026_deltaNeutralOpenC"
    "loseB\030\n\026_deltaNeutralShortSaleB\034\n\032_delta"
    "NeutralShortSaleSlotB!\n\037_deltaNeutralDes"
    "ignatedLocationB\025\n\023_scaleInitLevelSizeB\025"
    "\n\023_scaleSubsLevelSizeB\026\n\024_scalePriceIncr"
    "ementB\030\n\026_scalePriceAdjustValueB\033\n\031_scal"
    "ePriceAdjustIntervalB\024\n\022_scaleProfitOffs"
    "etB\021\n\017_scaleAutoResetB\024\n\022_scaleInitPosit"
    "ionB\023\n\021_scaleInitFillQtyB\025\n\023_scaleRandom"
    "PercentB\r\n\013_scaleTableB\014\n\n_hedgeTypeB\r\n\013"
    "_hedgeParamB\017\n\r_algoStrategyB\t\n\007_algoIdB"
    "\t\n\007_whatIfB\013\n\t_transmitB \n\036_overridePerc"
    "entageConstraintsB\014\n\n_openCloseB\t\n\007_orig"
    "inB\020\n\016_shortSaleSlotB\025\n\023_designatedLocat"
    "ionB\r\n\013_exemptCodeB\033\n\031_deltaNeutralSettl"
    "ingFirmB\036\n\034_deltaNeutralClearingAccountB"
    "\035\n\033_deltaNeutralClearingIntentB\023\n\021_discr"
    "etionaryAmtB\025\n\023_optOutSmartRoutingB\020\n\016_s"
    "tartingPriceB\020\n\016_stockRefPriceB\010\n\006_delta"
    "B\022\n\020_stockRangeLowerB\022\n\020_stockRangeUpper"
    "B\n\n\010_notHeldB\014\n\n_solicitedB\020\n\016_randomize"
    "SizeB\021\n\017_randomizePriceB\026\n\024_referenceCon"
    "tractIdB\025\n\023_peggedChangeAmountB\037\n\035_isPeg"
    "gedChangeAmountDecreaseB\030\n\026_referenceCha"
    "ngeAmountB\026\n\024_referenceExchangeIdB\024\n\022_ad"
    "justedOrderTypeB\017\n\r_triggerPriceB\024\n\022_adj"
    "ustedStopPriceB\031\n\027_adjustedStopLimitPric"
    "eB\031\n\027_adjustedTrailingAmountB\031\n\027_adjusta"
    "bleTrailingUnitB\021\n\017_lmtPriceOffsetB\030\n\026_c"
    "onditionsCancelOrderB\026\n\024_conditionsIgnor"
    "eRthB\014\n\n_modelCodeB\016\n\014_extOperatorB\021\n\017_s"
    "oftDollarTierB\n\n\010_cashQtyB\026\n\024_mifid2Deci"
    "sionMakerB\025\n\023_mifid2DecisionAlgoB\030\n\026_mif"
    "id2ExecutionTraderB\026\n\024_mifid2ExecutionAl"
    "goB\033\n\031_dontUseAutoPriceForHedgeB\021\n\017_isOm"
    "sContainerB\036\n\034_discretionaryUpToLimitPri"
    "ceB\021\n\017_autoCancelDateB\021\n\017_filledQuantity"
    "B\022\n\020_refFuturesConIdB\023\n\021_autoCancelParen"
    "tB\016\n\014_shareholderB\020\n\016_imbalanceOnlyB\027\n\025_"
    "routeMarketableToBboB\017\n\r_parentPermIdB\023\n"
    "\021_usePriceMgmtAlgoB\013\n\t_durationB\014\n\n_post"
    "ToAtsB\030\n\026_advancedErrorOverrideB\022\n\020_manu"
    "alOrderTimeB\016\n\014_minTradeQtyB\021\n\017_minCompe"
    "teSizeB\033\n\031_competeAgainstBestOffsetB\023\n\021_"
    "midOffsetAtWholeB\022\n\020_midOffsetAtHalfB\022\n\020"
    "_customerAccountB\027\n\025_professionalCustome"
    "rB\026\n\024_bondAccruedInterestB\023\n\021_includeOve"
    "rnightB\027\n\025_manualOrderIndicatorB\014\n\n_subm"
    "itterb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_Order_2eproto_deps[2] =
    {
        &::descriptor_table_OrderCondition_2eproto,
        &::descriptor_table_SoftDollarTier_2eproto,
};
static ::absl::once_flag descriptor_table_Order_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_Order_2eproto = {
    false,
    false,
    7053,
    descriptor_table_protodef_Order_2eproto,
    "Order.proto",
    &descriptor_table_Order_2eproto_once,
    descriptor_table_Order_2eproto_deps,
    2,
    4,
    schemas,
    file_default_instances,
    TableStruct_Order_2eproto::offsets,
    file_level_metadata_Order_2eproto,
    file_level_enum_descriptors_Order_2eproto,
    file_level_service_descriptors_Order_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Order_2eproto_getter() {
  return &descriptor_table_Order_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Order_2eproto(&descriptor_table_Order_2eproto);
namespace protobuf {
// ===================================================================

Order_AlgoParamsEntry_DoNotUse::Order_AlgoParamsEntry_DoNotUse() {}
Order_AlgoParamsEntry_DoNotUse::Order_AlgoParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Order_AlgoParamsEntry_DoNotUse::MergeFrom(const Order_AlgoParamsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Order_AlgoParamsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Order_2eproto_getter, &descriptor_table_Order_2eproto_once,
      file_level_metadata_Order_2eproto[0]);
}
// ===================================================================

Order_SmartComboRoutingParamsEntry_DoNotUse::Order_SmartComboRoutingParamsEntry_DoNotUse() {}
Order_SmartComboRoutingParamsEntry_DoNotUse::Order_SmartComboRoutingParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Order_SmartComboRoutingParamsEntry_DoNotUse::MergeFrom(const Order_SmartComboRoutingParamsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Order_SmartComboRoutingParamsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Order_2eproto_getter, &descriptor_table_Order_2eproto_once,
      file_level_metadata_Order_2eproto[1]);
}
// ===================================================================

Order_OrderMiscOptionsEntry_DoNotUse::Order_OrderMiscOptionsEntry_DoNotUse() {}
Order_OrderMiscOptionsEntry_DoNotUse::Order_OrderMiscOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Order_OrderMiscOptionsEntry_DoNotUse::MergeFrom(const Order_OrderMiscOptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Order_OrderMiscOptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Order_2eproto_getter, &descriptor_table_Order_2eproto_once,
      file_level_metadata_Order_2eproto[2]);
}
// ===================================================================

class Order::_Internal {
 public:
  using HasBits = decltype(std::declval<Order>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Order, _impl_._has_bits_);
  static void set_has_clientid(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_orderid(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_permid(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_parentid(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_totalquantity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_displaysize(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_ordertype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lmtprice(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_auxprice(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_tif(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_account(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_settlingfirm(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_clearingaccount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_clearingintent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_allornone(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_blockorder(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static void set_has_outsiderth(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_sweeptofill(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static void set_has_percentoffset(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static void set_has_trailingpercent(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static void set_has_trailstopprice(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static void set_has_minqty(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static void set_has_goodaftertime(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_goodtilldate(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ocagroup(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_orderref(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_rule80a(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_ocatype(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static void set_has_triggermethod(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static void set_has_activestarttime(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_activestoptime(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_fagroup(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_famethod(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_fapercentage(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_volatility(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static void set_has_volatilitytype(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static void set_has_continuousupdate(HasBits* has_bits) {
    (*has_bits)[2] |= 16u;
  }
  static void set_has_referencepricetype(HasBits* has_bits) {
    (*has_bits)[2] |= 128u;
  }
  static void set_has_deltaneutralordertype(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_deltaneutralauxprice(HasBits* has_bits) {
    (*has_bits)[2] |= 512u;
  }
  static void set_has_deltaneutralconid(HasBits* has_bits) {
    (*has_bits)[2] |= 256u;
  }
  static void set_has_deltaneutralopenclose(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_deltaneutralshortsale(HasBits* has_bits) {
    (*has_bits)[2] |= 32u;
  }
  static void set_has_deltaneutralshortsaleslot(HasBits* has_bits) {
    (*has_bits)[2] |= 1024u;
  }
  static void set_has_deltaneutraldesignatedlocation(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_scaleinitlevelsize(HasBits* has_bits) {
    (*has_bits)[2] |= 2048u;
  }
  static void set_has_scalesubslevelsize(HasBits* has_bits) {
    (*has_bits)[2] |= 8192u;
  }
  static void set_has_scalepriceincrement(HasBits* has_bits) {
    (*has_bits)[2] |= 4096u;
  }
  static void set_has_scalepriceadjustvalue(HasBits* has_bits) {
    (*has_bits)[2] |= 32768u;
  }
  static void set_has_scalepriceadjustinterval(HasBits* has_bits) {
    (*has_bits)[2] |= 16384u;
  }
  static void set_has_scaleprofitoffset(HasBits* has_bits) {
    (*has_bits)[2] |= 65536u;
  }
  static void set_has_scaleautoreset(HasBits* has_bits) {
    (*has_bits)[2] |= 64u;
  }
  static void set_has_scaleinitposition(HasBits* has_bits) {
    (*has_bits)[2] |= 131072u;
  }
  static void set_has_scaleinitfillqty(HasBits* has_bits) {
    (*has_bits)[2] |= 262144u;
  }
  static void set_has_scalerandompercent(HasBits* has_bits) {
    (*has_bits)[2] |= 524288u;
  }
  static void set_has_scaletable(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_hedgetype(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_hedgeparam(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_algostrategy(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_algoid(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_whatif(HasBits* has_bits) {
    (*has_bits)[2] |= 1048576u;
  }
  static void set_has_transmit(HasBits* has_bits) {
    (*has_bits)[2] |= 2097152u;
  }
  static void set_has_overridepercentageconstraints(HasBits* has_bits) {
    (*has_bits)[2] |= 4194304u;
  }
  static void set_has_openclose(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[2] |= 8388608u;
  }
  static void set_has_shortsaleslot(HasBits* has_bits) {
    (*has_bits)[2] |= 16777216u;
  }
  static void set_has_designatedlocation(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_exemptcode(HasBits* has_bits) {
    (*has_bits)[2] |= 33554432u;
  }
  static void set_has_deltaneutralsettlingfirm(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_deltaneutralclearingaccount(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_deltaneutralclearingintent(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_discretionaryamt(HasBits* has_bits) {
    (*has_bits)[2] |= 67108864u;
  }
  static void set_has_optoutsmartrouting(HasBits* has_bits) {
    (*has_bits)[3] |= 1u;
  }
  static void set_has_startingprice(HasBits* has_bits) {
    (*has_bits)[2] |= 134217728u;
  }
  static void set_has_stockrefprice(HasBits* has_bits) {
    (*has_bits)[2] |= 268435456u;
  }
  static void set_has_delta(HasBits* has_bits) {
    (*has_bits)[2] |= 536870912u;
  }
  static void set_has_stockrangelower(HasBits* has_bits) {
    (*has_bits)[2] |= 1073741824u;
  }
  static void set_has_stockrangeupper(HasBits* has_bits) {
    (*has_bits)[2] |= 2147483648u;
  }
  static void set_has_notheld(HasBits* has_bits) {
    (*has_bits)[3] |= 2u;
  }
  static void set_has_solicited(HasBits* has_bits) {
    (*has_bits)[3] |= 4u;
  }
  static void set_has_randomizesize(HasBits* has_bits) {
    (*has_bits)[3] |= 8u;
  }
  static void set_has_randomizeprice(HasBits* has_bits) {
    (*has_bits)[3] |= 512u;
  }
  static void set_has_referencecontractid(HasBits* has_bits) {
    (*has_bits)[3] |= 16u;
  }
  static void set_has_peggedchangeamount(HasBits* has_bits) {
    (*has_bits)[3] |= 32u;
  }
  static void set_has_ispeggedchangeamountdecrease(HasBits* has_bits) {
    (*has_bits)[3] |= 1024u;
  }
  static void set_has_referencechangeamount(HasBits* has_bits) {
    (*has_bits)[3] |= 64u;
  }
  static void set_has_referenceexchangeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_adjustedordertype(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_triggerprice(HasBits* has_bits) {
    (*has_bits)[3] |= 128u;
  }
  static void set_has_adjustedstopprice(HasBits* has_bits) {
    (*has_bits)[3] |= 256u;
  }
  static void set_has_adjustedstoplimitprice(HasBits* has_bits) {
    (*has_bits)[3] |= 16384u;
  }
  static void set_has_adjustedtrailingamount(HasBits* has_bits) {
    (*has_bits)[3] |= 32768u;
  }
  static void set_has_adjustabletrailingunit(HasBits* has_bits) {
    (*has_bits)[3] |= 8192u;
  }
  static void set_has_lmtpriceoffset(HasBits* has_bits) {
    (*has_bits)[3] |= 65536u;
  }
  static void set_has_conditionscancelorder(HasBits* has_bits) {
    (*has_bits)[3] |= 2048u;
  }
  static void set_has_conditionsignorerth(HasBits* has_bits) {
    (*has_bits)[3] |= 4096u;
  }
  static void set_has_modelcode(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_extoperator(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::protobuf::SoftDollarTier& softdollartier(const Order* msg);
  static void set_has_softdollartier(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_cashqty(HasBits* has_bits) {
    (*has_bits)[3] |= 131072u;
  }
  static void set_has_mifid2decisionmaker(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_mifid2decisionalgo(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_mifid2executiontrader(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_mifid2executionalgo(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_dontuseautopriceforhedge(HasBits* has_bits) {
    (*has_bits)[3] |= 262144u;
  }
  static void set_has_isomscontainer(HasBits* has_bits) {
    (*has_bits)[3] |= 524288u;
  }
  static void set_has_discretionaryuptolimitprice(HasBits* has_bits) {
    (*has_bits)[3] |= 1048576u;
  }
  static void set_has_autocanceldate(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_filledquantity(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_reffuturesconid(HasBits* has_bits) {
    (*has_bits)[3] |= 4194304u;
  }
  static void set_has_autocancelparent(HasBits* has_bits) {
    (*has_bits)[3] |= 2097152u;
  }
  static void set_has_shareholder(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_imbalanceonly(HasBits* has_bits) {
    (*has_bits)[3] |= 134217728u;
  }
  static void set_has_routemarketabletobbo(HasBits* has_bits) {
    (*has_bits)[3] |= 268435456u;
  }
  static void set_has_parentpermid(HasBits* has_bits) {
    (*has_bits)[3] |= 8388608u;
  }
  static void set_has_usepricemgmtalgo(HasBits* has_bits) {
    (*has_bits)[3] |= 16777216u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[3] |= 33554432u;
  }
  static void set_has_posttoats(HasBits* has_bits) {
    (*has_bits)[3] |= 67108864u;
  }
  static void set_has_advancederroroverride(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_manualordertime(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_mintradeqty(HasBits* has_bits) {
    (*has_bits)[3] |= 2147483648u;
  }
  static void set_has_mincompetesize(HasBits* has_bits) {
    (*has_bits)[4] |= 1u;
  }
  static void set_has_competeagainstbestoffset(HasBits* has_bits) {
    (*has_bits)[4] |= 2u;
  }
  static void set_has_midoffsetatwhole(HasBits* has_bits) {
    (*has_bits)[4] |= 4u;
  }
  static void set_has_midoffsetathalf(HasBits* has_bits) {
    (*has_bits)[4] |= 8u;
  }
  static void set_has_customeraccount(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_professionalcustomer(HasBits* has_bits) {
    (*has_bits)[3] |= 536870912u;
  }
  static void set_has_bondaccruedinterest(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_includeovernight(HasBits* has_bits) {
    (*has_bits)[3] |= 1073741824u;
  }
  static void set_has_manualorderindicator(HasBits* has_bits) {
    (*has_bits)[4] |= 16u;
  }
  static void set_has_submitter(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
};

const ::protobuf::SoftDollarTier&
Order::_Internal::softdollartier(const Order* msg) {
  return *msg->_impl_.softdollartier_;
}
void Order::clear_conditions() {
  _internal_mutable_conditions()->Clear();
}
void Order::clear_softdollartier() {
  if (_impl_.softdollartier_ != nullptr) _impl_.softdollartier_->Clear();
  _impl_._has_bits_[1] &= ~0x00008000u;
}
Order::Order(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protobuf.Order)
}
Order::Order(const Order& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Order* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.algoparams_)*/{}
    , /*decltype(_impl_.smartcomboroutingparams_)*/{}
    , /*decltype(_impl_.ordermiscoptions_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.action_) {}

    , decltype(_impl_.totalquantity_) {}

    , decltype(_impl_.ordertype_) {}

    , decltype(_impl_.tif_) {}

    , decltype(_impl_.account_) {}

    , decltype(_impl_.settlingfirm_) {}

    , decltype(_impl_.clearingaccount_) {}

    , decltype(_impl_.clearingintent_) {}

    , decltype(_impl_.goodaftertime_) {}

    , decltype(_impl_.goodtilldate_) {}

    , decltype(_impl_.ocagroup_) {}

    , decltype(_impl_.orderref_) {}

    , decltype(_impl_.rule80a_) {}

    , decltype(_impl_.activestarttime_) {}

    , decltype(_impl_.activestoptime_) {}

    , decltype(_impl_.fagroup_) {}

    , decltype(_impl_.famethod_) {}

    , decltype(_impl_.fapercentage_) {}

    , decltype(_impl_.deltaneutralordertype_) {}

    , decltype(_impl_.deltaneutralopenclose_) {}

    , decltype(_impl_.deltaneutraldesignatedlocation_) {}

    , decltype(_impl_.scaletable_) {}

    , decltype(_impl_.hedgetype_) {}

    , decltype(_impl_.hedgeparam_) {}

    , decltype(_impl_.algostrategy_) {}

    , decltype(_impl_.algoid_) {}

    , decltype(_impl_.openclose_) {}

    , decltype(_impl_.designatedlocation_) {}

    , decltype(_impl_.deltaneutralsettlingfirm_) {}

    , decltype(_impl_.deltaneutralclearingaccount_) {}

    , decltype(_impl_.deltaneutralclearingintent_) {}

    , decltype(_impl_.referenceexchangeid_) {}

    , decltype(_impl_.adjustedordertype_) {}

    , decltype(_impl_.modelcode_) {}

    , decltype(_impl_.extoperator_) {}

    , decltype(_impl_.mifid2decisionmaker_) {}

    , decltype(_impl_.mifid2decisionalgo_) {}

    , decltype(_impl_.mifid2executiontrader_) {}

    , decltype(_impl_.mifid2executionalgo_) {}

    , decltype(_impl_.autocanceldate_) {}

    , decltype(_impl_.filledquantity_) {}

    , decltype(_impl_.shareholder_) {}

    , decltype(_impl_.advancederroroverride_) {}

    , decltype(_impl_.manualordertime_) {}

    , decltype(_impl_.customeraccount_) {}

    , decltype(_impl_.bondaccruedinterest_) {}

    , decltype(_impl_.submitter_) {}

    , decltype(_impl_.softdollartier_){nullptr}
    , decltype(_impl_.clientid_) {}

    , decltype(_impl_.orderid_) {}

    , decltype(_impl_.permid_) {}

    , decltype(_impl_.parentid_) {}

    , decltype(_impl_.displaysize_) {}

    , decltype(_impl_.lmtprice_) {}

    , decltype(_impl_.auxprice_) {}

    , decltype(_impl_.allornone_) {}

    , decltype(_impl_.blockorder_) {}

    , decltype(_impl_.hidden_) {}

    , decltype(_impl_.outsiderth_) {}

    , decltype(_impl_.minqty_) {}

    , decltype(_impl_.percentoffset_) {}

    , decltype(_impl_.trailingpercent_) {}

    , decltype(_impl_.trailstopprice_) {}

    , decltype(_impl_.ocatype_) {}

    , decltype(_impl_.triggermethod_) {}

    , decltype(_impl_.volatility_) {}

    , decltype(_impl_.volatilitytype_) {}

    , decltype(_impl_.sweeptofill_) {}

    , decltype(_impl_.continuousupdate_) {}

    , decltype(_impl_.deltaneutralshortsale_) {}

    , decltype(_impl_.scaleautoreset_) {}

    , decltype(_impl_.referencepricetype_) {}

    , decltype(_impl_.deltaneutralconid_) {}

    , decltype(_impl_.deltaneutralauxprice_) {}

    , decltype(_impl_.deltaneutralshortsaleslot_) {}

    , decltype(_impl_.scaleinitlevelsize_) {}

    , decltype(_impl_.scalepriceincrement_) {}

    , decltype(_impl_.scalesubslevelsize_) {}

    , decltype(_impl_.scalepriceadjustinterval_) {}

    , decltype(_impl_.scalepriceadjustvalue_) {}

    , decltype(_impl_.scaleprofitoffset_) {}

    , decltype(_impl_.scaleinitposition_) {}

    , decltype(_impl_.scaleinitfillqty_) {}

    , decltype(_impl_.scalerandompercent_) {}

    , decltype(_impl_.whatif_) {}

    , decltype(_impl_.transmit_) {}

    , decltype(_impl_.overridepercentageconstraints_) {}

    , decltype(_impl_.origin_) {}

    , decltype(_impl_.shortsaleslot_) {}

    , decltype(_impl_.exemptcode_) {}

    , decltype(_impl_.discretionaryamt_) {}

    , decltype(_impl_.startingprice_) {}

    , decltype(_impl_.stockrefprice_) {}

    , decltype(_impl_.delta_) {}

    , decltype(_impl_.stockrangelower_) {}

    , decltype(_impl_.stockrangeupper_) {}

    , decltype(_impl_.optoutsmartrouting_) {}

    , decltype(_impl_.notheld_) {}

    , decltype(_impl_.solicited_) {}

    , decltype(_impl_.randomizesize_) {}

    , decltype(_impl_.referencecontractid_) {}

    , decltype(_impl_.peggedchangeamount_) {}

    , decltype(_impl_.referencechangeamount_) {}

    , decltype(_impl_.triggerprice_) {}

    , decltype(_impl_.adjustedstopprice_) {}

    , decltype(_impl_.randomizeprice_) {}

    , decltype(_impl_.ispeggedchangeamountdecrease_) {}

    , decltype(_impl_.conditionscancelorder_) {}

    , decltype(_impl_.conditionsignorerth_) {}

    , decltype(_impl_.adjustabletrailingunit_) {}

    , decltype(_impl_.adjustedstoplimitprice_) {}

    , decltype(_impl_.adjustedtrailingamount_) {}

    , decltype(_impl_.lmtpriceoffset_) {}

    , decltype(_impl_.cashqty_) {}

    , decltype(_impl_.dontuseautopriceforhedge_) {}

    , decltype(_impl_.isomscontainer_) {}

    , decltype(_impl_.discretionaryuptolimitprice_) {}

    , decltype(_impl_.autocancelparent_) {}

    , decltype(_impl_.reffuturesconid_) {}

    , decltype(_impl_.parentpermid_) {}

    , decltype(_impl_.usepricemgmtalgo_) {}

    , decltype(_impl_.duration_) {}

    , decltype(_impl_.posttoats_) {}

    , decltype(_impl_.imbalanceonly_) {}

    , decltype(_impl_.routemarketabletobbo_) {}

    , decltype(_impl_.professionalcustomer_) {}

    , decltype(_impl_.includeovernight_) {}

    , decltype(_impl_.mintradeqty_) {}

    , decltype(_impl_.mincompetesize_) {}

    , decltype(_impl_.competeagainstbestoffset_) {}

    , decltype(_impl_.midoffsetatwhole_) {}

    , decltype(_impl_.midoffsetathalf_) {}

    , decltype(_impl_.manualorderindicator_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.algoparams_.MergeFrom(from._impl_.algoparams_);
  _this->_impl_.smartcomboroutingparams_.MergeFrom(from._impl_.smartcomboroutingparams_);
  _this->_impl_.ordermiscoptions_.MergeFrom(from._impl_.ordermiscoptions_);
  _impl_.action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.action_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.action_.Set(from._internal_action(), _this->GetArenaForAllocation());
  }
  _impl_.totalquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.totalquantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.totalquantity_.Set(from._internal_totalquantity(), _this->GetArenaForAllocation());
  }
  _impl_.ordertype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.ordertype_.Set(from._internal_ordertype(), _this->GetArenaForAllocation());
  }
  _impl_.tif_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.tif_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.tif_.Set(from._internal_tif(), _this->GetArenaForAllocation());
  }
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  _impl_.settlingfirm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlingfirm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.settlingfirm_.Set(from._internal_settlingfirm(), _this->GetArenaForAllocation());
  }
  _impl_.clearingaccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.clearingaccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.clearingaccount_.Set(from._internal_clearingaccount(), _this->GetArenaForAllocation());
  }
  _impl_.clearingintent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.clearingintent_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000080u) != 0) {
    _this->_impl_.clearingintent_.Set(from._internal_clearingintent(), _this->GetArenaForAllocation());
  }
  _impl_.goodaftertime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.goodaftertime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000100u) != 0) {
    _this->_impl_.goodaftertime_.Set(from._internal_goodaftertime(), _this->GetArenaForAllocation());
  }
  _impl_.goodtilldate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.goodtilldate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000200u) != 0) {
    _this->_impl_.goodtilldate_.Set(from._internal_goodtilldate(), _this->GetArenaForAllocation());
  }
  _impl_.ocagroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ocagroup_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000400u) != 0) {
    _this->_impl_.ocagroup_.Set(from._internal_ocagroup(), _this->GetArenaForAllocation());
  }
  _impl_.orderref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.orderref_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000800u) != 0) {
    _this->_impl_.orderref_.Set(from._internal_orderref(), _this->GetArenaForAllocation());
  }
  _impl_.rule80a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.rule80a_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00001000u) != 0) {
    _this->_impl_.rule80a_.Set(from._internal_rule80a(), _this->GetArenaForAllocation());
  }
  _impl_.activestarttime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.activestarttime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00002000u) != 0) {
    _this->_impl_.activestarttime_.Set(from._internal_activestarttime(), _this->GetArenaForAllocation());
  }
  _impl_.activestoptime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.activestoptime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00004000u) != 0) {
    _this->_impl_.activestoptime_.Set(from._internal_activestoptime(), _this->GetArenaForAllocation());
  }
  _impl_.fagroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fagroup_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00008000u) != 0) {
    _this->_impl_.fagroup_.Set(from._internal_fagroup(), _this->GetArenaForAllocation());
  }
  _impl_.famethod_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.famethod_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00010000u) != 0) {
    _this->_impl_.famethod_.Set(from._internal_famethod(), _this->GetArenaForAllocation());
  }
  _impl_.fapercentage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fapercentage_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00020000u) != 0) {
    _this->_impl_.fapercentage_.Set(from._internal_fapercentage(), _this->GetArenaForAllocation());
  }
  _impl_.deltaneutralordertype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00040000u) != 0) {
    _this->_impl_.deltaneutralordertype_.Set(from._internal_deltaneutralordertype(), _this->GetArenaForAllocation());
  }
  _impl_.deltaneutralopenclose_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralopenclose_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00080000u) != 0) {
    _this->_impl_.deltaneutralopenclose_.Set(from._internal_deltaneutralopenclose(), _this->GetArenaForAllocation());
  }
  _impl_.deltaneutraldesignatedlocation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutraldesignatedlocation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00100000u) != 0) {
    _this->_impl_.deltaneutraldesignatedlocation_.Set(from._internal_deltaneutraldesignatedlocation(), _this->GetArenaForAllocation());
  }
  _impl_.scaletable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.scaletable_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00200000u) != 0) {
    _this->_impl_.scaletable_.Set(from._internal_scaletable(), _this->GetArenaForAllocation());
  }
  _impl_.hedgetype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hedgetype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00400000u) != 0) {
    _this->_impl_.hedgetype_.Set(from._internal_hedgetype(), _this->GetArenaForAllocation());
  }
  _impl_.hedgeparam_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hedgeparam_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00800000u) != 0) {
    _this->_impl_.hedgeparam_.Set(from._internal_hedgeparam(), _this->GetArenaForAllocation());
  }
  _impl_.algostrategy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.algostrategy_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x01000000u) != 0) {
    _this->_impl_.algostrategy_.Set(from._internal_algostrategy(), _this->GetArenaForAllocation());
  }
  _impl_.algoid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.algoid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x02000000u) != 0) {
    _this->_impl_.algoid_.Set(from._internal_algoid(), _this->GetArenaForAllocation());
  }
  _impl_.openclose_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.openclose_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x04000000u) != 0) {
    _this->_impl_.openclose_.Set(from._internal_openclose(), _this->GetArenaForAllocation());
  }
  _impl_.designatedlocation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.designatedlocation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x08000000u) != 0) {
    _this->_impl_.designatedlocation_.Set(from._internal_designatedlocation(), _this->GetArenaForAllocation());
  }
  _impl_.deltaneutralsettlingfirm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralsettlingfirm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x10000000u) != 0) {
    _this->_impl_.deltaneutralsettlingfirm_.Set(from._internal_deltaneutralsettlingfirm(), _this->GetArenaForAllocation());
  }
  _impl_.deltaneutralclearingaccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralclearingaccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x20000000u) != 0) {
    _this->_impl_.deltaneutralclearingaccount_.Set(from._internal_deltaneutralclearingaccount(), _this->GetArenaForAllocation());
  }
  _impl_.deltaneutralclearingintent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralclearingintent_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x40000000u) != 0) {
    _this->_impl_.deltaneutralclearingintent_.Set(from._internal_deltaneutralclearingintent(), _this->GetArenaForAllocation());
  }
  _impl_.referenceexchangeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.referenceexchangeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x80000000u) != 0) {
    _this->_impl_.referenceexchangeid_.Set(from._internal_referenceexchangeid(), _this->GetArenaForAllocation());
  }
  _impl_.adjustedordertype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.adjustedordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000001u) != 0) {
    _this->_impl_.adjustedordertype_.Set(from._internal_adjustedordertype(), _this->GetArenaForAllocation());
  }
  _impl_.modelcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.modelcode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000002u) != 0) {
    _this->_impl_.modelcode_.Set(from._internal_modelcode(), _this->GetArenaForAllocation());
  }
  _impl_.extoperator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.extoperator_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000004u) != 0) {
    _this->_impl_.extoperator_.Set(from._internal_extoperator(), _this->GetArenaForAllocation());
  }
  _impl_.mifid2decisionmaker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2decisionmaker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000008u) != 0) {
    _this->_impl_.mifid2decisionmaker_.Set(from._internal_mifid2decisionmaker(), _this->GetArenaForAllocation());
  }
  _impl_.mifid2decisionalgo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2decisionalgo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000010u) != 0) {
    _this->_impl_.mifid2decisionalgo_.Set(from._internal_mifid2decisionalgo(), _this->GetArenaForAllocation());
  }
  _impl_.mifid2executiontrader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2executiontrader_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000020u) != 0) {
    _this->_impl_.mifid2executiontrader_.Set(from._internal_mifid2executiontrader(), _this->GetArenaForAllocation());
  }
  _impl_.mifid2executionalgo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2executionalgo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000040u) != 0) {
    _this->_impl_.mifid2executionalgo_.Set(from._internal_mifid2executionalgo(), _this->GetArenaForAllocation());
  }
  _impl_.autocanceldate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.autocanceldate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000080u) != 0) {
    _this->_impl_.autocanceldate_.Set(from._internal_autocanceldate(), _this->GetArenaForAllocation());
  }
  _impl_.filledquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.filledquantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000100u) != 0) {
    _this->_impl_.filledquantity_.Set(from._internal_filledquantity(), _this->GetArenaForAllocation());
  }
  _impl_.shareholder_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shareholder_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000200u) != 0) {
    _this->_impl_.shareholder_.Set(from._internal_shareholder(), _this->GetArenaForAllocation());
  }
  _impl_.advancederroroverride_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.advancederroroverride_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000400u) != 0) {
    _this->_impl_.advancederroroverride_.Set(from._internal_advancederroroverride(), _this->GetArenaForAllocation());
  }
  _impl_.manualordertime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.manualordertime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00000800u) != 0) {
    _this->_impl_.manualordertime_.Set(from._internal_manualordertime(), _this->GetArenaForAllocation());
  }
  _impl_.customeraccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.customeraccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00001000u) != 0) {
    _this->_impl_.customeraccount_.Set(from._internal_customeraccount(), _this->GetArenaForAllocation());
  }
  _impl_.bondaccruedinterest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.bondaccruedinterest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00002000u) != 0) {
    _this->_impl_.bondaccruedinterest_.Set(from._internal_bondaccruedinterest(), _this->GetArenaForAllocation());
  }
  _impl_.submitter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.submitter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[1] & 0x00004000u) != 0) {
    _this->_impl_.submitter_.Set(from._internal_submitter(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[1] & 0x00008000u) != 0) {
    _this->_impl_.softdollartier_ = new ::protobuf::SoftDollarTier(*from._impl_.softdollartier_);
  }
  ::memcpy(&_impl_.clientid_, &from._impl_.clientid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.manualorderindicator_) -
    reinterpret_cast<char*>(&_impl_.clientid_)) + sizeof(_impl_.manualorderindicator_));
  // @@protoc_insertion_point(copy_constructor:protobuf.Order)
}

inline void Order::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.algoparams_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.smartcomboroutingparams_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.ordermiscoptions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.action_) {}

    , decltype(_impl_.totalquantity_) {}

    , decltype(_impl_.ordertype_) {}

    , decltype(_impl_.tif_) {}

    , decltype(_impl_.account_) {}

    , decltype(_impl_.settlingfirm_) {}

    , decltype(_impl_.clearingaccount_) {}

    , decltype(_impl_.clearingintent_) {}

    , decltype(_impl_.goodaftertime_) {}

    , decltype(_impl_.goodtilldate_) {}

    , decltype(_impl_.ocagroup_) {}

    , decltype(_impl_.orderref_) {}

    , decltype(_impl_.rule80a_) {}

    , decltype(_impl_.activestarttime_) {}

    , decltype(_impl_.activestoptime_) {}

    , decltype(_impl_.fagroup_) {}

    , decltype(_impl_.famethod_) {}

    , decltype(_impl_.fapercentage_) {}

    , decltype(_impl_.deltaneutralordertype_) {}

    , decltype(_impl_.deltaneutralopenclose_) {}

    , decltype(_impl_.deltaneutraldesignatedlocation_) {}

    , decltype(_impl_.scaletable_) {}

    , decltype(_impl_.hedgetype_) {}

    , decltype(_impl_.hedgeparam_) {}

    , decltype(_impl_.algostrategy_) {}

    , decltype(_impl_.algoid_) {}

    , decltype(_impl_.openclose_) {}

    , decltype(_impl_.designatedlocation_) {}

    , decltype(_impl_.deltaneutralsettlingfirm_) {}

    , decltype(_impl_.deltaneutralclearingaccount_) {}

    , decltype(_impl_.deltaneutralclearingintent_) {}

    , decltype(_impl_.referenceexchangeid_) {}

    , decltype(_impl_.adjustedordertype_) {}

    , decltype(_impl_.modelcode_) {}

    , decltype(_impl_.extoperator_) {}

    , decltype(_impl_.mifid2decisionmaker_) {}

    , decltype(_impl_.mifid2decisionalgo_) {}

    , decltype(_impl_.mifid2executiontrader_) {}

    , decltype(_impl_.mifid2executionalgo_) {}

    , decltype(_impl_.autocanceldate_) {}

    , decltype(_impl_.filledquantity_) {}

    , decltype(_impl_.shareholder_) {}

    , decltype(_impl_.advancederroroverride_) {}

    , decltype(_impl_.manualordertime_) {}

    , decltype(_impl_.customeraccount_) {}

    , decltype(_impl_.bondaccruedinterest_) {}

    , decltype(_impl_.submitter_) {}

    , decltype(_impl_.softdollartier_){nullptr}
    , decltype(_impl_.clientid_) { 0 }

    , decltype(_impl_.orderid_) { 0 }

    , decltype(_impl_.permid_) { ::int64_t{0} }

    , decltype(_impl_.parentid_) { 0 }

    , decltype(_impl_.displaysize_) { 0 }

    , decltype(_impl_.lmtprice_) { 0 }

    , decltype(_impl_.auxprice_) { 0 }

    , decltype(_impl_.allornone_) { false }

    , decltype(_impl_.blockorder_) { false }

    , decltype(_impl_.hidden_) { false }

    , decltype(_impl_.outsiderth_) { false }

    , decltype(_impl_.minqty_) { 0 }

    , decltype(_impl_.percentoffset_) { 0 }

    , decltype(_impl_.trailingpercent_) { 0 }

    , decltype(_impl_.trailstopprice_) { 0 }

    , decltype(_impl_.ocatype_) { 0 }

    , decltype(_impl_.triggermethod_) { 0 }

    , decltype(_impl_.volatility_) { 0 }

    , decltype(_impl_.volatilitytype_) { 0 }

    , decltype(_impl_.sweeptofill_) { false }

    , decltype(_impl_.continuousupdate_) { false }

    , decltype(_impl_.deltaneutralshortsale_) { false }

    , decltype(_impl_.scaleautoreset_) { false }

    , decltype(_impl_.referencepricetype_) { 0 }

    , decltype(_impl_.deltaneutralconid_) { 0 }

    , decltype(_impl_.deltaneutralauxprice_) { 0 }

    , decltype(_impl_.deltaneutralshortsaleslot_) { 0 }

    , decltype(_impl_.scaleinitlevelsize_) { 0 }

    , decltype(_impl_.scalepriceincrement_) { 0 }

    , decltype(_impl_.scalesubslevelsize_) { 0 }

    , decltype(_impl_.scalepriceadjustinterval_) { 0 }

    , decltype(_impl_.scalepriceadjustvalue_) { 0 }

    , decltype(_impl_.scaleprofitoffset_) { 0 }

    , decltype(_impl_.scaleinitposition_) { 0 }

    , decltype(_impl_.scaleinitfillqty_) { 0 }

    , decltype(_impl_.scalerandompercent_) { false }

    , decltype(_impl_.whatif_) { false }

    , decltype(_impl_.transmit_) { false }

    , decltype(_impl_.overridepercentageconstraints_) { false }

    , decltype(_impl_.origin_) { 0 }

    , decltype(_impl_.shortsaleslot_) { 0 }

    , decltype(_impl_.exemptcode_) { 0 }

    , decltype(_impl_.discretionaryamt_) { 0 }

    , decltype(_impl_.startingprice_) { 0 }

    , decltype(_impl_.stockrefprice_) { 0 }

    , decltype(_impl_.delta_) { 0 }

    , decltype(_impl_.stockrangelower_) { 0 }

    , decltype(_impl_.stockrangeupper_) { 0 }

    , decltype(_impl_.optoutsmartrouting_) { false }

    , decltype(_impl_.notheld_) { false }

    , decltype(_impl_.solicited_) { false }

    , decltype(_impl_.randomizesize_) { false }

    , decltype(_impl_.referencecontractid_) { 0 }

    , decltype(_impl_.peggedchangeamount_) { 0 }

    , decltype(_impl_.referencechangeamount_) { 0 }

    , decltype(_impl_.triggerprice_) { 0 }

    , decltype(_impl_.adjustedstopprice_) { 0 }

    , decltype(_impl_.randomizeprice_) { false }

    , decltype(_impl_.ispeggedchangeamountdecrease_) { false }

    , decltype(_impl_.conditionscancelorder_) { false }

    , decltype(_impl_.conditionsignorerth_) { false }

    , decltype(_impl_.adjustabletrailingunit_) { 0 }

    , decltype(_impl_.adjustedstoplimitprice_) { 0 }

    , decltype(_impl_.adjustedtrailingamount_) { 0 }

    , decltype(_impl_.lmtpriceoffset_) { 0 }

    , decltype(_impl_.cashqty_) { 0 }

    , decltype(_impl_.dontuseautopriceforhedge_) { false }

    , decltype(_impl_.isomscontainer_) { false }

    , decltype(_impl_.discretionaryuptolimitprice_) { false }

    , decltype(_impl_.autocancelparent_) { false }

    , decltype(_impl_.reffuturesconid_) { 0 }

    , decltype(_impl_.parentpermid_) { ::int64_t{0} }

    , decltype(_impl_.usepricemgmtalgo_) { 0 }

    , decltype(_impl_.duration_) { 0 }

    , decltype(_impl_.posttoats_) { 0 }

    , decltype(_impl_.imbalanceonly_) { false }

    , decltype(_impl_.routemarketabletobbo_) { false }

    , decltype(_impl_.professionalcustomer_) { false }

    , decltype(_impl_.includeovernight_) { false }

    , decltype(_impl_.mintradeqty_) { 0 }

    , decltype(_impl_.mincompetesize_) { 0 }

    , decltype(_impl_.competeagainstbestoffset_) { 0 }

    , decltype(_impl_.midoffsetatwhole_) { 0 }

    , decltype(_impl_.midoffsetathalf_) { 0 }

    , decltype(_impl_.manualorderindicator_) { 0 }

  };
  _impl_.action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.action_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.totalquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.totalquantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ordertype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tif_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.tif_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settlingfirm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlingfirm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.clearingaccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.clearingaccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.clearingintent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.clearingintent_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.goodaftertime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.goodaftertime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.goodtilldate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.goodtilldate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ocagroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ocagroup_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.orderref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.orderref_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rule80a_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.rule80a_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.activestarttime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.activestarttime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.activestoptime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.activestoptime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fagroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fagroup_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.famethod_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.famethod_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fapercentage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fapercentage_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralordertype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralopenclose_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralopenclose_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutraldesignatedlocation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutraldesignatedlocation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scaletable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.scaletable_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hedgetype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hedgetype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hedgeparam_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hedgeparam_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.algostrategy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.algostrategy_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.algoid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.algoid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.openclose_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.openclose_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.designatedlocation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.designatedlocation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralsettlingfirm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralsettlingfirm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralclearingaccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralclearingaccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deltaneutralclearingintent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.deltaneutralclearingintent_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referenceexchangeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.referenceexchangeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.adjustedordertype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.adjustedordertype_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.modelcode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extoperator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.extoperator_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2decisionmaker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2decisionmaker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2decisionalgo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2decisionalgo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2executiontrader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2executiontrader_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mifid2executionalgo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mifid2executionalgo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.autocanceldate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.autocanceldate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filledquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.filledquantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.shareholder_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shareholder_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.advancederroroverride_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.advancederroroverride_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manualordertime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.manualordertime_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.customeraccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.customeraccount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bondaccruedinterest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.bondaccruedinterest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.submitter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.submitter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:protobuf.Order)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Order::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.algoparams_.~MapField();
  _impl_.smartcomboroutingparams_.~MapField();
  _impl_.ordermiscoptions_.~MapField();
  _internal_mutable_conditions()->~RepeatedPtrField();
  _impl_.action_.Destroy();
  _impl_.totalquantity_.Destroy();
  _impl_.ordertype_.Destroy();
  _impl_.tif_.Destroy();
  _impl_.account_.Destroy();
  _impl_.settlingfirm_.Destroy();
  _impl_.clearingaccount_.Destroy();
  _impl_.clearingintent_.Destroy();
  _impl_.goodaftertime_.Destroy();
  _impl_.goodtilldate_.Destroy();
  _impl_.ocagroup_.Destroy();
  _impl_.orderref_.Destroy();
  _impl_.rule80a_.Destroy();
  _impl_.activestarttime_.Destroy();
  _impl_.activestoptime_.Destroy();
  _impl_.fagroup_.Destroy();
  _impl_.famethod_.Destroy();
  _impl_.fapercentage_.Destroy();
  _impl_.deltaneutralordertype_.Destroy();
  _impl_.deltaneutralopenclose_.Destroy();
  _impl_.deltaneutraldesignatedlocation_.Destroy();
  _impl_.scaletable_.Destroy();
  _impl_.hedgetype_.Destroy();
  _impl_.hedgeparam_.Destroy();
  _impl_.algostrategy_.Destroy();
  _impl_.algoid_.Destroy();
  _impl_.openclose_.Destroy();
  _impl_.designatedlocation_.Destroy();
  _impl_.deltaneutralsettlingfirm_.Destroy();
  _impl_.deltaneutralclearingaccount_.Destroy();
  _impl_.deltaneutralclearingintent_.Destroy();
  _impl_.referenceexchangeid_.Destroy();
  _impl_.adjustedordertype_.Destroy();
  _impl_.modelcode_.Destroy();
  _impl_.extoperator_.Destroy();
  _impl_.mifid2decisionmaker_.Destroy();
  _impl_.mifid2decisionalgo_.Destroy();
  _impl_.mifid2executiontrader_.Destroy();
  _impl_.mifid2executionalgo_.Destroy();
  _impl_.autocanceldate_.Destroy();
  _impl_.filledquantity_.Destroy();
  _impl_.shareholder_.Destroy();
  _impl_.advancederroroverride_.Destroy();
  _impl_.manualordertime_.Destroy();
  _impl_.customeraccount_.Destroy();
  _impl_.bondaccruedinterest_.Destroy();
  _impl_.submitter_.Destroy();
  if (this != internal_default_instance()) delete _impl_.softdollartier_;
}

void Order::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Order::Clear() {
// @@protoc_insertion_point(message_clear_start:protobuf.Order)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.algoparams_.Clear();
  _impl_.smartcomboroutingparams_.Clear();
  _impl_.ordermiscoptions_.Clear();
  _internal_mutable_conditions()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.action_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.totalquantity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.ordertype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.tif_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.account_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.settlingfirm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.clearingaccount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.clearingintent_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.goodaftertime_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.goodtilldate_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.ocagroup_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.orderref_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      _impl_.rule80a_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      _impl_.activestarttime_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      _impl_.activestoptime_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      _impl_.fagroup_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _impl_.famethod_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00020000u) {
      _impl_.fapercentage_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00040000u) {
      _impl_.deltaneutralordertype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00080000u) {
      _impl_.deltaneutralopenclose_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00100000u) {
      _impl_.deltaneutraldesignatedlocation_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00200000u) {
      _impl_.scaletable_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00400000u) {
      _impl_.hedgetype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00800000u) {
      _impl_.hedgeparam_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _impl_.algostrategy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x02000000u) {
      _impl_.algoid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x04000000u) {
      _impl_.openclose_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x08000000u) {
      _impl_.designatedlocation_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x10000000u) {
      _impl_.deltaneutralsettlingfirm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x20000000u) {
      _impl_.deltaneutralclearingaccount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x40000000u) {
      _impl_.deltaneutralclearingintent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x80000000u) {
      _impl_.referenceexchangeid_.ClearNonDefaultToEmpty();
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.adjustedordertype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.modelcode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.extoperator_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.mifid2decisionmaker_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.mifid2decisionalgo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.mifid2executiontrader_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.mifid2executionalgo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.autocanceldate_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.filledquantity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.shareholder_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.advancederroroverride_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.manualordertime_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      _impl_.customeraccount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      _impl_.bondaccruedinterest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      _impl_.submitter_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      ABSL_DCHECK(_impl_.softdollartier_ != nullptr);
      _impl_.softdollartier_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.clientid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.allornone_) -
        reinterpret_cast<char*>(&_impl_.clientid_)) + sizeof(_impl_.allornone_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.blockorder_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ocatype_) -
        reinterpret_cast<char*>(&_impl_.blockorder_)) + sizeof(_impl_.ocatype_));
  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.triggermethod_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.referencepricetype_) -
        reinterpret_cast<char*>(&_impl_.triggermethod_)) + sizeof(_impl_.referencepricetype_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.deltaneutralconid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.scalepriceadjustvalue_) -
        reinterpret_cast<char*>(&_impl_.deltaneutralconid_)) + sizeof(_impl_.scalepriceadjustvalue_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.scaleprofitoffset_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.origin_) -
        reinterpret_cast<char*>(&_impl_.scaleprofitoffset_)) + sizeof(_impl_.origin_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.shortsaleslot_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.stockrangeupper_) -
        reinterpret_cast<char*>(&_impl_.shortsaleslot_)) + sizeof(_impl_.stockrangeupper_));
  }
  cached_has_bits = _impl_._has_bits_[3];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.optoutsmartrouting_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.triggerprice_) -
        reinterpret_cast<char*>(&_impl_.optoutsmartrouting_)) + sizeof(_impl_.triggerprice_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.adjustedstopprice_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.adjustedtrailingamount_) -
        reinterpret_cast<char*>(&_impl_.adjustedstopprice_)) + sizeof(_impl_.adjustedtrailingamount_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.lmtpriceoffset_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.parentpermid_) -
        reinterpret_cast<char*>(&_impl_.lmtpriceoffset_)) + sizeof(_impl_.parentpermid_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.usepricemgmtalgo_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mintradeqty_) -
        reinterpret_cast<char*>(&_impl_.usepricemgmtalgo_)) + sizeof(_impl_.mintradeqty_));
  }
  cached_has_bits = _impl_._has_bits_[4];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.mincompetesize_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.manualorderindicator_) -
        reinterpret_cast<char*>(&_impl_.mincompetesize_)) + sizeof(_impl_.manualorderindicator_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Order::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 clientId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_clientid(&_impl_._has_bits_);
          _impl_.clientid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 orderId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_orderid(&_impl_._has_bits_);
          _impl_.orderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 permId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_permid(&_impl_._has_bits_);
          _impl_.permid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 parentId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_parentid(&_impl_._has_bits_);
          _impl_.parentid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string action = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_action();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.action"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string totalQuantity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_totalquantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.totalQuantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 displaySize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_displaysize(&_impl_._has_bits_);
          _impl_.displaysize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string orderType = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_ordertype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.orderType"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double lmtPrice = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 73)) {
          _Internal::set_has_lmtprice(&_impl_._has_bits_);
          _impl_.lmtprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double auxPrice = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _Internal::set_has_auxprice(&_impl_._has_bits_);
          _impl_.auxprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string tif = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_tif();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.tif"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string account = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string settlingFirm = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_settlingfirm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.settlingFirm"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string clearingAccount = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_clearingaccount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.clearingAccount"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string clearingIntent = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_clearingintent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.clearingIntent"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool allOrNone = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _Internal::set_has_allornone(&_impl_._has_bits_);
          _impl_.allornone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool blockOrder = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _Internal::set_has_blockorder(&_impl_._has_bits_);
          _impl_.blockorder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool hidden = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _Internal::set_has_hidden(&_impl_._has_bits_);
          _impl_.hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool outsideRth = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          _Internal::set_has_outsiderth(&_impl_._has_bits_);
          _impl_.outsiderth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool sweepToFill = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _Internal::set_has_sweeptofill(&_impl_._has_bits_);
          _impl_.sweeptofill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double percentOffset = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 169)) {
          _Internal::set_has_percentoffset(&_impl_._has_bits_);
          _impl_.percentoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double trailingPercent = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 177)) {
          _Internal::set_has_trailingpercent(&_impl_._has_bits_);
          _impl_.trailingpercent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double trailStopPrice = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 185)) {
          _Internal::set_has_trailstopprice(&_impl_._has_bits_);
          _impl_.trailstopprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 minQty = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _Internal::set_has_minqty(&_impl_._has_bits_);
          _impl_.minqty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string goodAfterTime = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_goodaftertime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.goodAfterTime"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string goodTillDate = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_goodtilldate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.goodTillDate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string ocaGroup = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_ocagroup();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.ocaGroup"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string orderRef = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_orderref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.orderRef"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string rule80A = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_rule80a();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.rule80A"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ocaType = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _Internal::set_has_ocatype(&_impl_._has_bits_);
          _impl_.ocatype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 triggerMethod = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 248)) {
          _Internal::set_has_triggermethod(&_impl_._has_bits_);
          _impl_.triggermethod_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string activeStartTime = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_activestarttime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.activeStartTime"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string activeStopTime = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_activestoptime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.activeStopTime"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string faGroup = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fagroup();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.faGroup"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string faMethod = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_famethod();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.faMethod"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string faPercentage = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fapercentage();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.faPercentage"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double volatility = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          _Internal::set_has_volatility(&_impl_._has_bits_);
          _impl_.volatility_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 volatilityType = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_volatilitytype(&_impl_._has_bits_);
          _impl_.volatilitytype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool continuousUpdate = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_continuousupdate(&_impl_._has_bits_);
          _impl_.continuousupdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 referencePriceType = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_referencepricetype(&_impl_._has_bits_);
          _impl_.referencepricetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string deltaNeutralOrderType = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_deltaneutralordertype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.deltaNeutralOrderType"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double deltaNeutralAuxPrice = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _Internal::set_has_deltaneutralauxprice(&_impl_._has_bits_);
          _impl_.deltaneutralauxprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 deltaNeutralConId = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_deltaneutralconid(&_impl_._has_bits_);
          _impl_.deltaneutralconid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string deltaNeutralOpenClose = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_deltaneutralopenclose();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.deltaNeutralOpenClose"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool deltaNeutralShortSale = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _Internal::set_has_deltaneutralshortsale(&_impl_._has_bits_);
          _impl_.deltaneutralshortsale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 deltaNeutralShortSaleSlot = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _Internal::set_has_deltaneutralshortsaleslot(&_impl_._has_bits_);
          _impl_.deltaneutralshortsaleslot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string deltaNeutralDesignatedLocation = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_deltaneutraldesignatedlocation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.deltaNeutralDesignatedLocation"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 scaleInitLevelSize = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _Internal::set_has_scaleinitlevelsize(&_impl_._has_bits_);
          _impl_.scaleinitlevelsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 scaleSubsLevelSize = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _Internal::set_has_scalesubslevelsize(&_impl_._has_bits_);
          _impl_.scalesubslevelsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double scalePriceIncrement = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 145)) {
          _Internal::set_has_scalepriceincrement(&_impl_._has_bits_);
          _impl_.scalepriceincrement_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double scalePriceAdjustValue = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 153)) {
          _Internal::set_has_scalepriceadjustvalue(&_impl_._has_bits_);
          _impl_.scalepriceadjustvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 scalePriceAdjustInterval = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _Internal::set_has_scalepriceadjustinterval(&_impl_._has_bits_);
          _impl_.scalepriceadjustinterval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double scaleProfitOffset = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 169)) {
          _Internal::set_has_scaleprofitoffset(&_impl_._has_bits_);
          _impl_.scaleprofitoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool scaleAutoReset = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _Internal::set_has_scaleautoreset(&_impl_._has_bits_);
          _impl_.scaleautoreset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 scaleInitPosition = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _Internal::set_has_scaleinitposition(&_impl_._has_bits_);
          _impl_.scaleinitposition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 scaleInitFillQty = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _Internal::set_has_scaleinitfillqty(&_impl_._has_bits_);
          _impl_.scaleinitfillqty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool scaleRandomPercent = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _Internal::set_has_scalerandompercent(&_impl_._has_bits_);
          _impl_.scalerandompercent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string scaleTable = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_scaletable();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.scaleTable"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string hedgeType = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_hedgetype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.hedgeType"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string hedgeParam = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_hedgeparam();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.hedgeParam"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string algoStrategy = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_algostrategy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.algoStrategy"));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, string> algoParams = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&_impl_.algoparams_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<498>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string algoId = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          auto str = _internal_mutable_algoid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.algoId"));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, string> smartComboRoutingParams = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&_impl_.smartcomboroutingparams_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<514>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool whatIf = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_whatif(&_impl_._has_bits_);
          _impl_.whatif_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool transmit = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_transmit(&_impl_._has_bits_);
          _impl_.transmit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool overridePercentageConstraints = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_overridepercentageconstraints(&_impl_._has_bits_);
          _impl_.overridepercentageconstraints_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string openClose = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_openclose();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.openClose"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 origin = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_origin(&_impl_._has_bits_);
          _impl_.origin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 shortSaleSlot = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_shortsaleslot(&_impl_._has_bits_);
          _impl_.shortsaleslot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string designatedLocation = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_designatedlocation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.designatedLocation"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 exemptCode = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_exemptcode(&_impl_._has_bits_);
          _impl_.exemptcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string deltaNeutralSettlingFirm = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_deltaneutralsettlingfirm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.deltaNeutralSettlingFirm"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string deltaNeutralClearingAccount = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_deltaneutralclearingaccount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.deltaNeutralClearingAccount"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string deltaNeutralClearingIntent = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_deltaneutralclearingintent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.deltaNeutralClearingIntent"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double discretionaryAmt = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 97)) {
          _Internal::set_has_discretionaryamt(&_impl_._has_bits_);
          _impl_.discretionaryamt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool optOutSmartRouting = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _Internal::set_has_optoutsmartrouting(&_impl_._has_bits_);
          _impl_.optoutsmartrouting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double startingPrice = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 113)) {
          _Internal::set_has_startingprice(&_impl_._has_bits_);
          _impl_.startingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double stockRefPrice = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 121)) {
          _Internal::set_has_stockrefprice(&_impl_._has_bits_);
          _impl_.stockrefprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double delta = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 129)) {
          _Internal::set_has_delta(&_impl_._has_bits_);
          _impl_.delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double stockRangeLower = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 137)) {
          _Internal::set_has_stockrangelower(&_impl_._has_bits_);
          _impl_.stockrangelower_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double stockRangeUpper = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 145)) {
          _Internal::set_has_stockrangeupper(&_impl_._has_bits_);
          _impl_.stockrangeupper_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool notHeld = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          _Internal::set_has_notheld(&_impl_._has_bits_);
          _impl_.notheld_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, string> orderMiscOptions = 84;
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&_impl_.ordermiscoptions_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<674>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool solicited = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _Internal::set_has_solicited(&_impl_._has_bits_);
          _impl_.solicited_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool randomizeSize = 86;
      case 86:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _Internal::set_has_randomizesize(&_impl_._has_bits_);
          _impl_.randomizesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool randomizePrice = 87;
      case 87:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _Internal::set_has_randomizeprice(&_impl_._has_bits_);
          _impl_.randomizeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 referenceContractId = 88;
      case 88:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _Internal::set_has_referencecontractid(&_impl_._has_bits_);
          _impl_.referencecontractid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double peggedChangeAmount = 89;
      case 89:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 201)) {
          _Internal::set_has_peggedchangeamount(&_impl_._has_bits_);
          _impl_.peggedchangeamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool isPeggedChangeAmountDecrease = 90;
      case 90:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _Internal::set_has_ispeggedchangeamountdecrease(&_impl_._has_bits_);
          _impl_.ispeggedchangeamountdecrease_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double referenceChangeAmount = 91;
      case 91:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 217)) {
          _Internal::set_has_referencechangeamount(&_impl_._has_bits_);
          _impl_.referencechangeamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string referenceExchangeId = 92;
      case 92:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_referenceexchangeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.referenceExchangeId"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string adjustedOrderType = 93;
      case 93:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_adjustedordertype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.adjustedOrderType"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double triggerPrice = 94;
      case 94:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 241)) {
          _Internal::set_has_triggerprice(&_impl_._has_bits_);
          _impl_.triggerprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double adjustedStopPrice = 95;
      case 95:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 249)) {
          _Internal::set_has_adjustedstopprice(&_impl_._has_bits_);
          _impl_.adjustedstopprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double adjustedStopLimitPrice = 96;
      case 96:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 1)) {
          _Internal::set_has_adjustedstoplimitprice(&_impl_._has_bits_);
          _impl_.adjustedstoplimitprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double adjustedTrailingAmount = 97;
      case 97:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_adjustedtrailingamount(&_impl_._has_bits_);
          _impl_.adjustedtrailingamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 adjustableTrailingUnit = 98;
      case 98:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_adjustabletrailingunit(&_impl_._has_bits_);
          _impl_.adjustabletrailingunit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double lmtPriceOffset = 99;
      case 99:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_lmtpriceoffset(&_impl_._has_bits_);
          _impl_.lmtpriceoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protobuf.OrderCondition conditions = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<802>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool conditionsCancelOrder = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_conditionscancelorder(&_impl_._has_bits_);
          _impl_.conditionscancelorder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool conditionsIgnoreRth = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_conditionsignorerth(&_impl_._has_bits_);
          _impl_.conditionsignorerth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string modelCode = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_modelcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.modelCode"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string extOperator = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_extoperator();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.extOperator"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .protobuf.SoftDollarTier softDollarTier = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_softdollartier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double cashQty = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _Internal::set_has_cashqty(&_impl_._has_bits_);
          _impl_.cashqty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string mifid2DecisionMaker = 107;
      case 107:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_mifid2decisionmaker();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.mifid2DecisionMaker"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string mifid2DecisionAlgo = 108;
      case 108:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_mifid2decisionalgo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.mifid2DecisionAlgo"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string mifid2ExecutionTrader = 109;
      case 109:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_mifid2executiontrader();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.mifid2ExecutionTrader"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string mifid2ExecutionAlgo = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_mifid2executionalgo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.mifid2ExecutionAlgo"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool dontUseAutoPriceForHedge = 111;
      case 111:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _Internal::set_has_dontuseautopriceforhedge(&_impl_._has_bits_);
          _impl_.dontuseautopriceforhedge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool isOmsContainer = 112;
      case 112:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _Internal::set_has_isomscontainer(&_impl_._has_bits_);
          _impl_.isomscontainer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool discretionaryUpToLimitPrice = 113;
      case 113:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _Internal::set_has_discretionaryuptolimitprice(&_impl_._has_bits_);
          _impl_.discretionaryuptolimitprice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string autoCancelDate = 114;
      case 114:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_autocanceldate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.autoCancelDate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string filledQuantity = 115;
      case 115:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_filledquantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.filledQuantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 refFuturesConId = 116;
      case 116:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _Internal::set_has_reffuturesconid(&_impl_._has_bits_);
          _impl_.reffuturesconid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool autoCancelParent = 117;
      case 117:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _Internal::set_has_autocancelparent(&_impl_._has_bits_);
          _impl_.autocancelparent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string shareholder = 118;
      case 118:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_shareholder();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.shareholder"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool imbalanceOnly = 119;
      case 119:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _Internal::set_has_imbalanceonly(&_impl_._has_bits_);
          _impl_.imbalanceonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool routeMarketableToBbo = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _Internal::set_has_routemarketabletobbo(&_impl_._has_bits_);
          _impl_.routemarketabletobbo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 parentPermId = 121;
      case 121:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _Internal::set_has_parentpermid(&_impl_._has_bits_);
          _impl_.parentpermid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 usePriceMgmtAlgo = 122;
      case 122:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _Internal::set_has_usepricemgmtalgo(&_impl_._has_bits_);
          _impl_.usepricemgmtalgo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 duration = 123;
      case 123:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _Internal::set_has_duration(&_impl_._has_bits_);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 postToAts = 124;
      case 124:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _Internal::set_has_posttoats(&_impl_._has_bits_);
          _impl_.posttoats_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string advancedErrorOverride = 125;
      case 125:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_advancederroroverride();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.advancedErrorOverride"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string manualOrderTime = 126;
      case 126:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 242)) {
          auto str = _internal_mutable_manualordertime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.manualOrderTime"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 minTradeQty = 127;
      case 127:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 248)) {
          _Internal::set_has_mintradeqty(&_impl_._has_bits_);
          _impl_.mintradeqty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 minCompeteSize = 128;
      case 128:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 0)) {
          _Internal::set_has_mincompetesize(&_impl_._has_bits_);
          _impl_.mincompetesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double competeAgainstBestOffset = 129;
      case 129:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_competeagainstbestoffset(&_impl_._has_bits_);
          _impl_.competeagainstbestoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double midOffsetAtWhole = 130;
      case 130:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_midoffsetatwhole(&_impl_._has_bits_);
          _impl_.midoffsetatwhole_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double midOffsetAtHalf = 131;
      case 131:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_midoffsetathalf(&_impl_._has_bits_);
          _impl_.midoffsetathalf_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string customerAccount = 132;
      case 132:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_customeraccount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.customerAccount"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool professionalCustomer = 133;
      case 133:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_professionalcustomer(&_impl_._has_bits_);
          _impl_.professionalcustomer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string bondAccruedInterest = 134;
      case 134:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_bondaccruedinterest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.bondAccruedInterest"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool includeOvernight = 135;
      case 135:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_includeovernight(&_impl_._has_bits_);
          _impl_.includeovernight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 manualOrderIndicator = 136;
      case 136:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_manualorderindicator(&_impl_._has_bits_);
          _impl_.manualorderindicator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string submitter = 137;
      case 137:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_submitter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protobuf.Order.submitter"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Order::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protobuf.Order)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 clientId = 1;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_clientid(), target);
  }

  // optional int32 orderId = 2;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_orderid(), target);
  }

  // optional int64 permId = 3;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_permid(), target);
  }

  // optional int32 parentId = 4;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_parentid(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string action = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_action();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.action");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string totalQuantity = 6;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_totalquantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.totalQuantity");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 displaySize = 7;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_displaysize(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string orderType = 8;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_ordertype();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.orderType");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double lmtPrice = 9;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_lmtprice(), target);
  }

  // optional double auxPrice = 10;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_auxprice(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string tif = 11;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_tif();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.tif");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // optional string account = 12;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.account");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // optional string settlingFirm = 13;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_settlingfirm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.settlingFirm");
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // optional string clearingAccount = 14;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_clearingaccount();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.clearingAccount");
    target = stream->WriteStringMaybeAliased(14, _s, target);
  }

  // optional string clearingIntent = 15;
  if (cached_has_bits & 0x00000080u) {
    const std::string& _s = this->_internal_clearingintent();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.clearingIntent");
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool allOrNone = 16;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this->_internal_allornone(), target);
  }

  // optional bool blockOrder = 17;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        17, this->_internal_blockorder(), target);
  }

  // optional bool hidden = 18;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this->_internal_hidden(), target);
  }

  // optional bool outsideRth = 19;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        19, this->_internal_outsiderth(), target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional bool sweepToFill = 20;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        20, this->_internal_sweeptofill(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double percentOffset = 21;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        21, this->_internal_percentoffset(), target);
  }

  // optional double trailingPercent = 22;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        22, this->_internal_trailingpercent(), target);
  }

  // optional double trailStopPrice = 23;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        23, this->_internal_trailstopprice(), target);
  }

  // optional int32 minQty = 24;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_minqty(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string goodAfterTime = 25;
  if (cached_has_bits & 0x00000100u) {
    const std::string& _s = this->_internal_goodaftertime();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.goodAfterTime");
    target = stream->WriteStringMaybeAliased(25, _s, target);
  }

  // optional string goodTillDate = 26;
  if (cached_has_bits & 0x00000200u) {
    const std::string& _s = this->_internal_goodtilldate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.goodTillDate");
    target = stream->WriteStringMaybeAliased(26, _s, target);
  }

  // optional string ocaGroup = 27;
  if (cached_has_bits & 0x00000400u) {
    const std::string& _s = this->_internal_ocagroup();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.ocaGroup");
    target = stream->WriteStringMaybeAliased(27, _s, target);
  }

  // optional string orderRef = 28;
  if (cached_has_bits & 0x00000800u) {
    const std::string& _s = this->_internal_orderref();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.orderRef");
    target = stream->WriteStringMaybeAliased(28, _s, target);
  }

  // optional string rule80A = 29;
  if (cached_has_bits & 0x00001000u) {
    const std::string& _s = this->_internal_rule80a();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.rule80A");
    target = stream->WriteStringMaybeAliased(29, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 ocaType = 30;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        30, this->_internal_ocatype(), target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional int32 triggerMethod = 31;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        31, this->_internal_triggermethod(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string activeStartTime = 32;
  if (cached_has_bits & 0x00002000u) {
    const std::string& _s = this->_internal_activestarttime();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.activeStartTime");
    target = stream->WriteStringMaybeAliased(32, _s, target);
  }

  // optional string activeStopTime = 33;
  if (cached_has_bits & 0x00004000u) {
    const std::string& _s = this->_internal_activestoptime();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.activeStopTime");
    target = stream->WriteStringMaybeAliased(33, _s, target);
  }

  // optional string faGroup = 34;
  if (cached_has_bits & 0x00008000u) {
    const std::string& _s = this->_internal_fagroup();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.faGroup");
    target = stream->WriteStringMaybeAliased(34, _s, target);
  }

  // optional string faMethod = 35;
  if (cached_has_bits & 0x00010000u) {
    const std::string& _s = this->_internal_famethod();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.faMethod");
    target = stream->WriteStringMaybeAliased(35, _s, target);
  }

  // optional string faPercentage = 36;
  if (cached_has_bits & 0x00020000u) {
    const std::string& _s = this->_internal_fapercentage();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.faPercentage");
    target = stream->WriteStringMaybeAliased(36, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional double volatility = 37;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        37, this->_internal_volatility(), target);
  }

  // optional int32 volatilityType = 38;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        38, this->_internal_volatilitytype(), target);
  }

  // optional bool continuousUpdate = 39;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        39, this->_internal_continuousupdate(), target);
  }

  // optional int32 referencePriceType = 40;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        40, this->_internal_referencepricetype(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string deltaNeutralOrderType = 41;
  if (cached_has_bits & 0x00040000u) {
    const std::string& _s = this->_internal_deltaneutralordertype();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.deltaNeutralOrderType");
    target = stream->WriteStringMaybeAliased(41, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional double deltaNeutralAuxPrice = 42;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        42, this->_internal_deltaneutralauxprice(), target);
  }

  // optional int32 deltaNeutralConId = 43;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        43, this->_internal_deltaneutralconid(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string deltaNeutralOpenClose = 44;
  if (cached_has_bits & 0x00080000u) {
    const std::string& _s = this->_internal_deltaneutralopenclose();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.deltaNeutralOpenClose");
    target = stream->WriteStringMaybeAliased(44, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional bool deltaNeutralShortSale = 45;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        45, this->_internal_deltaneutralshortsale(), target);
  }

  // optional int32 deltaNeutralShortSaleSlot = 46;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        46, this->_internal_deltaneutralshortsaleslot(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string deltaNeutralDesignatedLocation = 47;
  if (cached_has_bits & 0x00100000u) {
    const std::string& _s = this->_internal_deltaneutraldesignatedlocation();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.deltaNeutralDesignatedLocation");
    target = stream->WriteStringMaybeAliased(47, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional int32 scaleInitLevelSize = 48;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        48, this->_internal_scaleinitlevelsize(), target);
  }

  // optional int32 scaleSubsLevelSize = 49;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        49, this->_internal_scalesubslevelsize(), target);
  }

  // optional double scalePriceIncrement = 50;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        50, this->_internal_scalepriceincrement(), target);
  }

  // optional double scalePriceAdjustValue = 51;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        51, this->_internal_scalepriceadjustvalue(), target);
  }

  // optional int32 scalePriceAdjustInterval = 52;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        52, this->_internal_scalepriceadjustinterval(), target);
  }

  // optional double scaleProfitOffset = 53;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        53, this->_internal_scaleprofitoffset(), target);
  }

  // optional bool scaleAutoReset = 54;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        54, this->_internal_scaleautoreset(), target);
  }

  // optional int32 scaleInitPosition = 55;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        55, this->_internal_scaleinitposition(), target);
  }

  // optional int32 scaleInitFillQty = 56;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        56, this->_internal_scaleinitfillqty(), target);
  }

  // optional bool scaleRandomPercent = 57;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        57, this->_internal_scalerandompercent(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string scaleTable = 58;
  if (cached_has_bits & 0x00200000u) {
    const std::string& _s = this->_internal_scaletable();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.scaleTable");
    target = stream->WriteStringMaybeAliased(58, _s, target);
  }

  // optional string hedgeType = 59;
  if (cached_has_bits & 0x00400000u) {
    const std::string& _s = this->_internal_hedgetype();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.hedgeType");
    target = stream->WriteStringMaybeAliased(59, _s, target);
  }

  // optional string hedgeParam = 60;
  if (cached_has_bits & 0x00800000u) {
    const std::string& _s = this->_internal_hedgeparam();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.hedgeParam");
    target = stream->WriteStringMaybeAliased(60, _s, target);
  }

  // optional string algoStrategy = 61;
  if (cached_has_bits & 0x01000000u) {
    const std::string& _s = this->_internal_algostrategy();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.algoStrategy");
    target = stream->WriteStringMaybeAliased(61, _s, target);
  }

  // map<string, string> algoParams = 62;
  if (!this->_internal_algoparams().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Order_AlgoParamsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_algoparams();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.algoParams");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          entry.second.data(), static_cast<int>(entry.second.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.algoParams");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(62, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(62, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional string algoId = 63;
  if (cached_has_bits & 0x02000000u) {
    const std::string& _s = this->_internal_algoid();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.algoId");
    target = stream->WriteStringMaybeAliased(63, _s, target);
  }

  // map<string, string> smartComboRoutingParams = 64;
  if (!this->_internal_smartcomboroutingparams().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Order_SmartComboRoutingParamsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_smartcomboroutingparams();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.smartComboRoutingParams");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          entry.second.data(), static_cast<int>(entry.second.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.smartComboRoutingParams");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(64, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(64, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional bool whatIf = 65;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        65, this->_internal_whatif(), target);
  }

  // optional bool transmit = 66;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        66, this->_internal_transmit(), target);
  }

  // optional bool overridePercentageConstraints = 67;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        67, this->_internal_overridepercentageconstraints(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string openClose = 68;
  if (cached_has_bits & 0x04000000u) {
    const std::string& _s = this->_internal_openclose();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.openClose");
    target = stream->WriteStringMaybeAliased(68, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional int32 origin = 69;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        69, this->_internal_origin(), target);
  }

  // optional int32 shortSaleSlot = 70;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        70, this->_internal_shortsaleslot(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string designatedLocation = 71;
  if (cached_has_bits & 0x08000000u) {
    const std::string& _s = this->_internal_designatedlocation();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.designatedLocation");
    target = stream->WriteStringMaybeAliased(71, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional int32 exemptCode = 72;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        72, this->_internal_exemptcode(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string deltaNeutralSettlingFirm = 73;
  if (cached_has_bits & 0x10000000u) {
    const std::string& _s = this->_internal_deltaneutralsettlingfirm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.deltaNeutralSettlingFirm");
    target = stream->WriteStringMaybeAliased(73, _s, target);
  }

  // optional string deltaNeutralClearingAccount = 74;
  if (cached_has_bits & 0x20000000u) {
    const std::string& _s = this->_internal_deltaneutralclearingaccount();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.deltaNeutralClearingAccount");
    target = stream->WriteStringMaybeAliased(74, _s, target);
  }

  // optional string deltaNeutralClearingIntent = 75;
  if (cached_has_bits & 0x40000000u) {
    const std::string& _s = this->_internal_deltaneutralclearingintent();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.deltaNeutralClearingIntent");
    target = stream->WriteStringMaybeAliased(75, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional double discretionaryAmt = 76;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        76, this->_internal_discretionaryamt(), target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional bool optOutSmartRouting = 77;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        77, this->_internal_optoutsmartrouting(), target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional double startingPrice = 78;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        78, this->_internal_startingprice(), target);
  }

  // optional double stockRefPrice = 79;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        79, this->_internal_stockrefprice(), target);
  }

  // optional double delta = 80;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        80, this->_internal_delta(), target);
  }

  // optional double stockRangeLower = 81;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        81, this->_internal_stockrangelower(), target);
  }

  // optional double stockRangeUpper = 82;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        82, this->_internal_stockrangeupper(), target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional bool notHeld = 83;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        83, this->_internal_notheld(), target);
  }

  // map<string, string> orderMiscOptions = 84;
  if (!this->_internal_ordermiscoptions().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Order_OrderMiscOptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_ordermiscoptions();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.orderMiscOptions");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          entry.second.data(), static_cast<int>(entry.second.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.orderMiscOptions");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(84, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(84, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional bool solicited = 85;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        85, this->_internal_solicited(), target);
  }

  // optional bool randomizeSize = 86;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        86, this->_internal_randomizesize(), target);
  }

  // optional bool randomizePrice = 87;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        87, this->_internal_randomizeprice(), target);
  }

  // optional int32 referenceContractId = 88;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        88, this->_internal_referencecontractid(), target);
  }

  // optional double peggedChangeAmount = 89;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        89, this->_internal_peggedchangeamount(), target);
  }

  // optional bool isPeggedChangeAmountDecrease = 90;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        90, this->_internal_ispeggedchangeamountdecrease(), target);
  }

  // optional double referenceChangeAmount = 91;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        91, this->_internal_referencechangeamount(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string referenceExchangeId = 92;
  if (cached_has_bits & 0x80000000u) {
    const std::string& _s = this->_internal_referenceexchangeid();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.referenceExchangeId");
    target = stream->WriteStringMaybeAliased(92, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string adjustedOrderType = 93;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_adjustedordertype();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.adjustedOrderType");
    target = stream->WriteStringMaybeAliased(93, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional double triggerPrice = 94;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        94, this->_internal_triggerprice(), target);
  }

  // optional double adjustedStopPrice = 95;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        95, this->_internal_adjustedstopprice(), target);
  }

  // optional double adjustedStopLimitPrice = 96;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        96, this->_internal_adjustedstoplimitprice(), target);
  }

  // optional double adjustedTrailingAmount = 97;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        97, this->_internal_adjustedtrailingamount(), target);
  }

  // optional int32 adjustableTrailingUnit = 98;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        98, this->_internal_adjustabletrailingunit(), target);
  }

  // optional double lmtPriceOffset = 99;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        99, this->_internal_lmtpriceoffset(), target);
  }

  // repeated .protobuf.OrderCondition conditions = 100;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(100, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool conditionsCancelOrder = 101;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        101, this->_internal_conditionscancelorder(), target);
  }

  // optional bool conditionsIgnoreRth = 102;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        102, this->_internal_conditionsignorerth(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string modelCode = 103;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_modelcode();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.modelCode");
    target = stream->WriteStringMaybeAliased(103, _s, target);
  }

  // optional string extOperator = 104;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_extoperator();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.extOperator");
    target = stream->WriteStringMaybeAliased(104, _s, target);
  }

  // optional .protobuf.SoftDollarTier softDollarTier = 105;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(105, _Internal::softdollartier(this),
        _Internal::softdollartier(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional double cashQty = 106;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        106, this->_internal_cashqty(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string mifid2DecisionMaker = 107;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_mifid2decisionmaker();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.mifid2DecisionMaker");
    target = stream->WriteStringMaybeAliased(107, _s, target);
  }

  // optional string mifid2DecisionAlgo = 108;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_mifid2decisionalgo();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.mifid2DecisionAlgo");
    target = stream->WriteStringMaybeAliased(108, _s, target);
  }

  // optional string mifid2ExecutionTrader = 109;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_mifid2executiontrader();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.mifid2ExecutionTrader");
    target = stream->WriteStringMaybeAliased(109, _s, target);
  }

  // optional string mifid2ExecutionAlgo = 110;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_mifid2executionalgo();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.mifid2ExecutionAlgo");
    target = stream->WriteStringMaybeAliased(110, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional bool dontUseAutoPriceForHedge = 111;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        111, this->_internal_dontuseautopriceforhedge(), target);
  }

  // optional bool isOmsContainer = 112;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        112, this->_internal_isomscontainer(), target);
  }

  // optional bool discretionaryUpToLimitPrice = 113;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        113, this->_internal_discretionaryuptolimitprice(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string autoCancelDate = 114;
  if (cached_has_bits & 0x00000080u) {
    const std::string& _s = this->_internal_autocanceldate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.autoCancelDate");
    target = stream->WriteStringMaybeAliased(114, _s, target);
  }

  // optional string filledQuantity = 115;
  if (cached_has_bits & 0x00000100u) {
    const std::string& _s = this->_internal_filledquantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.filledQuantity");
    target = stream->WriteStringMaybeAliased(115, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional int32 refFuturesConId = 116;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        116, this->_internal_reffuturesconid(), target);
  }

  // optional bool autoCancelParent = 117;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        117, this->_internal_autocancelparent(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string shareholder = 118;
  if (cached_has_bits & 0x00000200u) {
    const std::string& _s = this->_internal_shareholder();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.shareholder");
    target = stream->WriteStringMaybeAliased(118, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional bool imbalanceOnly = 119;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        119, this->_internal_imbalanceonly(), target);
  }

  // optional bool routeMarketableToBbo = 120;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        120, this->_internal_routemarketabletobbo(), target);
  }

  // optional int64 parentPermId = 121;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        121, this->_internal_parentpermid(), target);
  }

  // optional int32 usePriceMgmtAlgo = 122;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        122, this->_internal_usepricemgmtalgo(), target);
  }

  // optional int32 duration = 123;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        123, this->_internal_duration(), target);
  }

  // optional int32 postToAts = 124;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        124, this->_internal_posttoats(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string advancedErrorOverride = 125;
  if (cached_has_bits & 0x00000400u) {
    const std::string& _s = this->_internal_advancederroroverride();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.advancedErrorOverride");
    target = stream->WriteStringMaybeAliased(125, _s, target);
  }

  // optional string manualOrderTime = 126;
  if (cached_has_bits & 0x00000800u) {
    const std::string& _s = this->_internal_manualordertime();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.manualOrderTime");
    target = stream->WriteStringMaybeAliased(126, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional int32 minTradeQty = 127;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        127, this->_internal_mintradeqty(), target);
  }

  cached_has_bits = _impl_._has_bits_[4];
  // optional int32 minCompeteSize = 128;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        128, this->_internal_mincompetesize(), target);
  }

  // optional double competeAgainstBestOffset = 129;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        129, this->_internal_competeagainstbestoffset(), target);
  }

  // optional double midOffsetAtWhole = 130;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        130, this->_internal_midoffsetatwhole(), target);
  }

  // optional double midOffsetAtHalf = 131;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        131, this->_internal_midoffsetathalf(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string customerAccount = 132;
  if (cached_has_bits & 0x00001000u) {
    const std::string& _s = this->_internal_customeraccount();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.customerAccount");
    target = stream->WriteStringMaybeAliased(132, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional bool professionalCustomer = 133;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        133, this->_internal_professionalcustomer(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string bondAccruedInterest = 134;
  if (cached_has_bits & 0x00002000u) {
    const std::string& _s = this->_internal_bondaccruedinterest();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.bondAccruedInterest");
    target = stream->WriteStringMaybeAliased(134, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional bool includeOvernight = 135;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        135, this->_internal_includeovernight(), target);
  }

  cached_has_bits = _impl_._has_bits_[4];
  // optional int32 manualOrderIndicator = 136;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        136, this->_internal_manualorderindicator(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional string submitter = 137;
  if (cached_has_bits & 0x00004000u) {
    const std::string& _s = this->_internal_submitter();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protobuf.Order.submitter");
    target = stream->WriteStringMaybeAliased(137, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protobuf.Order)
  return target;
}

::size_t Order::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protobuf.Order)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> algoParams = 62;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_algoparams_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_algoparams().begin();
      it != this->_internal_algoparams().end(); ++it) {
    total_size += Order_AlgoParamsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> smartComboRoutingParams = 64;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_smartcomboroutingparams_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_smartcomboroutingparams().begin();
      it != this->_internal_smartcomboroutingparams().end(); ++it) {
    total_size += Order_SmartComboRoutingParamsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> orderMiscOptions = 84;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ordermiscoptions_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_ordermiscoptions().begin();
      it != this->_internal_ordermiscoptions().end(); ++it) {
    total_size += Order_OrderMiscOptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .protobuf.OrderCondition conditions = 100;
  total_size += 2UL * this->_internal_conditions_size();
  for (const auto& msg : this->_internal_conditions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string action = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_action());
    }

    // optional string totalQuantity = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_totalquantity());
    }

    // optional string orderType = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_ordertype());
    }

    // optional string tif = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_tif());
    }

    // optional string account = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_account());
    }

    // optional string settlingFirm = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_settlingfirm());
    }

    // optional string clearingAccount = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_clearingaccount());
    }

    // optional string clearingIntent = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_clearingintent());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string goodAfterTime = 25;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_goodaftertime());
    }

    // optional string goodTillDate = 26;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_goodtilldate());
    }

    // optional string ocaGroup = 27;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_ocagroup());
    }

    // optional string orderRef = 28;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_orderref());
    }

    // optional string rule80A = 29;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_rule80a());
    }

    // optional string activeStartTime = 32;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_activestarttime());
    }

    // optional string activeStopTime = 33;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_activestoptime());
    }

    // optional string faGroup = 34;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_fagroup());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional string faMethod = 35;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_famethod());
    }

    // optional string faPercentage = 36;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_fapercentage());
    }

    // optional string deltaNeutralOrderType = 41;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_deltaneutralordertype());
    }

    // optional string deltaNeutralOpenClose = 44;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_deltaneutralopenclose());
    }

    // optional string deltaNeutralDesignatedLocation = 47;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_deltaneutraldesignatedlocation());
    }

    // optional string scaleTable = 58;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_scaletable());
    }

    // optional string hedgeType = 59;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_hedgetype());
    }

    // optional string hedgeParam = 60;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_hedgeparam());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional string algoStrategy = 61;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_algostrategy());
    }

    // optional string algoId = 63;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_algoid());
    }

    // optional string openClose = 68;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_openclose());
    }

    // optional string designatedLocation = 71;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_designatedlocation());
    }

    // optional string deltaNeutralSettlingFirm = 73;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_deltaneutralsettlingfirm());
    }

    // optional string deltaNeutralClearingAccount = 74;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_deltaneutralclearingaccount());
    }

    // optional string deltaNeutralClearingIntent = 75;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_deltaneutralclearingintent());
    }

    // optional string referenceExchangeId = 92;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_referenceexchangeid());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional string adjustedOrderType = 93;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_adjustedordertype());
    }

    // optional string modelCode = 103;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_modelcode());
    }

    // optional string extOperator = 104;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_extoperator());
    }

    // optional string mifid2DecisionMaker = 107;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_mifid2decisionmaker());
    }

    // optional string mifid2DecisionAlgo = 108;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_mifid2decisionalgo());
    }

    // optional string mifid2ExecutionTrader = 109;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_mifid2executiontrader());
    }

    // optional string mifid2ExecutionAlgo = 110;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_mifid2executionalgo());
    }

    // optional string autoCancelDate = 114;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_autocanceldate());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string filledQuantity = 115;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_filledquantity());
    }

    // optional string shareholder = 118;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_shareholder());
    }

    // optional string advancedErrorOverride = 125;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_advancederroroverride());
    }

    // optional string manualOrderTime = 126;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_manualordertime());
    }

    // optional string customerAccount = 132;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_customeraccount());
    }

    // optional string bondAccruedInterest = 134;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_bondaccruedinterest());
    }

    // optional string submitter = 137;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_submitter());
    }

    // optional .protobuf.SoftDollarTier softDollarTier = 105;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.softdollartier_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 clientId = 1;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_clientid());
    }

    // optional int32 orderId = 2;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_orderid());
    }

    // optional int64 permId = 3;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_permid());
    }

    // optional int32 parentId = 4;
    if (cached_has_bits & 0x00080000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_parentid());
    }

    // optional int32 displaySize = 7;
    if (cached_has_bits & 0x00100000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_displaysize());
    }

    // optional double lmtPrice = 9;
    if (cached_has_bits & 0x00200000u) {
      total_size += 9;
    }

    // optional double auxPrice = 10;
    if (cached_has_bits & 0x00400000u) {
      total_size += 9;
    }

    // optional bool allOrNone = 16;
    if (cached_has_bits & 0x00800000u) {
      total_size += 3;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool blockOrder = 17;
    if (cached_has_bits & 0x01000000u) {
      total_size += 3;
    }

    // optional bool hidden = 18;
    if (cached_has_bits & 0x02000000u) {
      total_size += 3;
    }

    // optional bool outsideRth = 19;
    if (cached_has_bits & 0x04000000u) {
      total_size += 3;
    }

    // optional int32 minQty = 24;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_minqty());
    }

    // optional double percentOffset = 21;
    if (cached_has_bits & 0x10000000u) {
      total_size += 10;
    }

    // optional double trailingPercent = 22;
    if (cached_has_bits & 0x20000000u) {
      total_size += 10;
    }

    // optional double trailStopPrice = 23;
    if (cached_has_bits & 0x40000000u) {
      total_size += 10;
    }

    // optional int32 ocaType = 30;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_ocatype());
    }

  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 triggerMethod = 31;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_triggermethod());
    }

    // optional double volatility = 37;
    if (cached_has_bits & 0x00000002u) {
      total_size += 10;
    }

    // optional int32 volatilityType = 38;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_volatilitytype());
    }

    // optional bool sweepToFill = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 3;
    }

    // optional bool continuousUpdate = 39;
    if (cached_has_bits & 0x00000010u) {
      total_size += 3;
    }

    // optional bool deltaNeutralShortSale = 45;
    if (cached_has_bits & 0x00000020u) {
      total_size += 3;
    }

    // optional bool scaleAutoReset = 54;
    if (cached_has_bits & 0x00000040u) {
      total_size += 3;
    }

    // optional int32 referencePriceType = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_referencepricetype());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 deltaNeutralConId = 43;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_deltaneutralconid());
    }

    // optional double deltaNeutralAuxPrice = 42;
    if (cached_has_bits & 0x00000200u) {
      total_size += 10;
    }

    // optional int32 deltaNeutralShortSaleSlot = 46;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_deltaneutralshortsaleslot());
    }

    // optional int32 scaleInitLevelSize = 48;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_scaleinitlevelsize());
    }

    // optional double scalePriceIncrement = 50;
    if (cached_has_bits & 0x00001000u) {
      total_size += 10;
    }

    // optional int32 scaleSubsLevelSize = 49;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_scalesubslevelsize());
    }

    // optional int32 scalePriceAdjustInterval = 52;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_scalepriceadjustinterval());
    }

    // optional double scalePriceAdjustValue = 51;
    if (cached_has_bits & 0x00008000u) {
      total_size += 10;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double scaleProfitOffset = 53;
    if (cached_has_bits & 0x00010000u) {
      total_size += 10;
    }

    // optional int32 scaleInitPosition = 55;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_scaleinitposition());
    }

    // optional int32 scaleInitFillQty = 56;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_scaleinitfillqty());
    }

    // optional bool scaleRandomPercent = 57;
    if (cached_has_bits & 0x00080000u) {
      total_size += 3;
    }

    // optional bool whatIf = 65;
    if (cached_has_bits & 0x00100000u) {
      total_size += 3;
    }

    // optional bool transmit = 66;
    if (cached_has_bits & 0x00200000u) {
      total_size += 3;
    }

    // optional bool overridePercentageConstraints = 67;
    if (cached_has_bits & 0x00400000u) {
      total_size += 3;
    }

    // optional int32 origin = 69;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_origin());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 shortSaleSlot = 70;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_shortsaleslot());
    }

    // optional int32 exemptCode = 72;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_exemptcode());
    }

    // optional double discretionaryAmt = 76;
    if (cached_has_bits & 0x04000000u) {
      total_size += 10;
    }

    // optional double startingPrice = 78;
    if (cached_has_bits & 0x08000000u) {
      total_size += 10;
    }

    // optional double stockRefPrice = 79;
    if (cached_has_bits & 0x10000000u) {
      total_size += 10;
    }

    // optional double delta = 80;
    if (cached_has_bits & 0x20000000u) {
      total_size += 10;
    }

    // optional double stockRangeLower = 81;
    if (cached_has_bits & 0x40000000u) {
      total_size += 10;
    }

    // optional double stockRangeUpper = 82;
    if (cached_has_bits & 0x80000000u) {
      total_size += 10;
    }

  }
  cached_has_bits = _impl_._has_bits_[3];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool optOutSmartRouting = 77;
    if (cached_has_bits & 0x00000001u) {
      total_size += 3;
    }

    // optional bool notHeld = 83;
    if (cached_has_bits & 0x00000002u) {
      total_size += 3;
    }

    // optional bool solicited = 85;
    if (cached_has_bits & 0x00000004u) {
      total_size += 3;
    }

    // optional bool randomizeSize = 86;
    if (cached_has_bits & 0x00000008u) {
      total_size += 3;
    }

    // optional int32 referenceContractId = 88;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_referencecontractid());
    }

    // optional double peggedChangeAmount = 89;
    if (cached_has_bits & 0x00000020u) {
      total_size += 10;
    }

    // optional double referenceChangeAmount = 91;
    if (cached_has_bits & 0x00000040u) {
      total_size += 10;
    }

    // optional double triggerPrice = 94;
    if (cached_has_bits & 0x00000080u) {
      total_size += 10;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double adjustedStopPrice = 95;
    if (cached_has_bits & 0x00000100u) {
      total_size += 10;
    }

    // optional bool randomizePrice = 87;
    if (cached_has_bits & 0x00000200u) {
      total_size += 3;
    }

    // optional bool isPeggedChangeAmountDecrease = 90;
    if (cached_has_bits & 0x00000400u) {
      total_size += 3;
    }

    // optional bool conditionsCancelOrder = 101;
    if (cached_has_bits & 0x00000800u) {
      total_size += 3;
    }

    // optional bool conditionsIgnoreRth = 102;
    if (cached_has_bits & 0x00001000u) {
      total_size += 3;
    }

    // optional int32 adjustableTrailingUnit = 98;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_adjustabletrailingunit());
    }

    // optional double adjustedStopLimitPrice = 96;
    if (cached_has_bits & 0x00004000u) {
      total_size += 10;
    }

    // optional double adjustedTrailingAmount = 97;
    if (cached_has_bits & 0x00008000u) {
      total_size += 10;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double lmtPriceOffset = 99;
    if (cached_has_bits & 0x00010000u) {
      total_size += 10;
    }

    // optional double cashQty = 106;
    if (cached_has_bits & 0x00020000u) {
      total_size += 10;
    }

    // optional bool dontUseAutoPriceForHedge = 111;
    if (cached_has_bits & 0x00040000u) {
      total_size += 3;
    }

    // optional bool isOmsContainer = 112;
    if (cached_has_bits & 0x00080000u) {
      total_size += 3;
    }

    // optional bool discretionaryUpToLimitPrice = 113;
    if (cached_has_bits & 0x00100000u) {
      total_size += 3;
    }

    // optional bool autoCancelParent = 117;
    if (cached_has_bits & 0x00200000u) {
      total_size += 3;
    }

    // optional int32 refFuturesConId = 116;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_reffuturesconid());
    }

    // optional int64 parentPermId = 121;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                      this->_internal_parentpermid());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 usePriceMgmtAlgo = 122;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_usepricemgmtalgo());
    }

    // optional int32 duration = 123;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_duration());
    }

    // optional int32 postToAts = 124;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_posttoats());
    }

    // optional bool imbalanceOnly = 119;
    if (cached_has_bits & 0x08000000u) {
      total_size += 3;
    }

    // optional bool routeMarketableToBbo = 120;
    if (cached_has_bits & 0x10000000u) {
      total_size += 3;
    }

    // optional bool professionalCustomer = 133;
    if (cached_has_bits & 0x20000000u) {
      total_size += 3;
    }

    // optional bool includeOvernight = 135;
    if (cached_has_bits & 0x40000000u) {
      total_size += 3;
    }

    // optional int32 minTradeQty = 127;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_mintradeqty());
    }

  }
  cached_has_bits = _impl_._has_bits_[4];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 minCompeteSize = 128;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_mincompetesize());
    }

    // optional double competeAgainstBestOffset = 129;
    if (cached_has_bits & 0x00000002u) {
      total_size += 10;
    }

    // optional double midOffsetAtWhole = 130;
    if (cached_has_bits & 0x00000004u) {
      total_size += 10;
    }

    // optional double midOffsetAtHalf = 131;
    if (cached_has_bits & 0x00000008u) {
      total_size += 10;
    }

    // optional int32 manualOrderIndicator = 136;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_manualorderindicator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Order::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Order::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Order::GetClassData() const { return &_class_data_; }


void Order::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Order*>(&to_msg);
  auto& from = static_cast<const Order&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protobuf.Order)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.algoparams_.MergeFrom(from._impl_.algoparams_);
  _this->_impl_.smartcomboroutingparams_.MergeFrom(from._impl_.smartcomboroutingparams_);
  _this->_impl_.ordermiscoptions_.MergeFrom(from._impl_.ordermiscoptions_);
  _this->_internal_mutable_conditions()->MergeFrom(from._internal_conditions());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_action(from._internal_action());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_totalquantity(from._internal_totalquantity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_ordertype(from._internal_ordertype());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_tif(from._internal_tif());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_account(from._internal_account());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_settlingfirm(from._internal_settlingfirm());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_clearingaccount(from._internal_clearingaccount());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_clearingintent(from._internal_clearingintent());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_goodaftertime(from._internal_goodaftertime());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_goodtilldate(from._internal_goodtilldate());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_ocagroup(from._internal_ocagroup());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_set_orderref(from._internal_orderref());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_set_rule80a(from._internal_rule80a());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_set_activestarttime(from._internal_activestarttime());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_set_activestoptime(from._internal_activestoptime());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_set_fagroup(from._internal_fagroup());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_set_famethod(from._internal_famethod());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_set_fapercentage(from._internal_fapercentage());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_set_deltaneutralordertype(from._internal_deltaneutralordertype());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_set_deltaneutralopenclose(from._internal_deltaneutralopenclose());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_set_deltaneutraldesignatedlocation(from._internal_deltaneutraldesignatedlocation());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_set_scaletable(from._internal_scaletable());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_set_hedgetype(from._internal_hedgetype());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_set_hedgeparam(from._internal_hedgeparam());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_set_algostrategy(from._internal_algostrategy());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_set_algoid(from._internal_algoid());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_set_openclose(from._internal_openclose());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_set_designatedlocation(from._internal_designatedlocation());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_set_deltaneutralsettlingfirm(from._internal_deltaneutralsettlingfirm());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_set_deltaneutralclearingaccount(from._internal_deltaneutralclearingaccount());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_set_deltaneutralclearingintent(from._internal_deltaneutralclearingintent());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_set_referenceexchangeid(from._internal_referenceexchangeid());
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_adjustedordertype(from._internal_adjustedordertype());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_modelcode(from._internal_modelcode());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_extoperator(from._internal_extoperator());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_mifid2decisionmaker(from._internal_mifid2decisionmaker());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_mifid2decisionalgo(from._internal_mifid2decisionalgo());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_mifid2executiontrader(from._internal_mifid2executiontrader());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_mifid2executionalgo(from._internal_mifid2executionalgo());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_autocanceldate(from._internal_autocanceldate());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_filledquantity(from._internal_filledquantity());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_shareholder(from._internal_shareholder());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_advancederroroverride(from._internal_advancederroroverride());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_set_manualordertime(from._internal_manualordertime());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_set_customeraccount(from._internal_customeraccount());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_set_bondaccruedinterest(from._internal_bondaccruedinterest());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_set_submitter(from._internal_submitter());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_softdollartier()->::protobuf::SoftDollarTier::MergeFrom(
          from._internal_softdollartier());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.clientid_ = from._impl_.clientid_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.orderid_ = from._impl_.orderid_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.permid_ = from._impl_.permid_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.parentid_ = from._impl_.parentid_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.displaysize_ = from._impl_.displaysize_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.lmtprice_ = from._impl_.lmtprice_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.auxprice_ = from._impl_.auxprice_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.allornone_ = from._impl_.allornone_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.blockorder_ = from._impl_.blockorder_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.hidden_ = from._impl_.hidden_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.outsiderth_ = from._impl_.outsiderth_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.minqty_ = from._impl_.minqty_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.percentoffset_ = from._impl_.percentoffset_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.trailingpercent_ = from._impl_.trailingpercent_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.trailstopprice_ = from._impl_.trailstopprice_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.ocatype_ = from._impl_.ocatype_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.triggermethod_ = from._impl_.triggermethod_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.volatility_ = from._impl_.volatility_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.volatilitytype_ = from._impl_.volatilitytype_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sweeptofill_ = from._impl_.sweeptofill_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.continuousupdate_ = from._impl_.continuousupdate_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.deltaneutralshortsale_ = from._impl_.deltaneutralshortsale_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.scaleautoreset_ = from._impl_.scaleautoreset_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.referencepricetype_ = from._impl_.referencepricetype_;
    }
    _this->_impl_._has_bits_[2] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.deltaneutralconid_ = from._impl_.deltaneutralconid_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.deltaneutralauxprice_ = from._impl_.deltaneutralauxprice_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.deltaneutralshortsaleslot_ = from._impl_.deltaneutralshortsaleslot_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.scaleinitlevelsize_ = from._impl_.scaleinitlevelsize_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.scalepriceincrement_ = from._impl_.scalepriceincrement_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.scalesubslevelsize_ = from._impl_.scalesubslevelsize_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.scalepriceadjustinterval_ = from._impl_.scalepriceadjustinterval_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.scalepriceadjustvalue_ = from._impl_.scalepriceadjustvalue_;
    }
    _this->_impl_._has_bits_[2] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.scaleprofitoffset_ = from._impl_.scaleprofitoffset_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.scaleinitposition_ = from._impl_.scaleinitposition_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.scaleinitfillqty_ = from._impl_.scaleinitfillqty_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.scalerandompercent_ = from._impl_.scalerandompercent_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.whatif_ = from._impl_.whatif_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.transmit_ = from._impl_.transmit_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.overridepercentageconstraints_ = from._impl_.overridepercentageconstraints_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.origin_ = from._impl_.origin_;
    }
    _this->_impl_._has_bits_[2] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.shortsaleslot_ = from._impl_.shortsaleslot_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.exemptcode_ = from._impl_.exemptcode_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.discretionaryamt_ = from._impl_.discretionaryamt_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.startingprice_ = from._impl_.startingprice_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.stockrefprice_ = from._impl_.stockrefprice_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.delta_ = from._impl_.delta_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.stockrangelower_ = from._impl_.stockrangelower_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.stockrangeupper_ = from._impl_.stockrangeupper_;
    }
    _this->_impl_._has_bits_[2] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[3];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.optoutsmartrouting_ = from._impl_.optoutsmartrouting_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.notheld_ = from._impl_.notheld_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.solicited_ = from._impl_.solicited_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.randomizesize_ = from._impl_.randomizesize_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.referencecontractid_ = from._impl_.referencecontractid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.peggedchangeamount_ = from._impl_.peggedchangeamount_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.referencechangeamount_ = from._impl_.referencechangeamount_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.triggerprice_ = from._impl_.triggerprice_;
    }
    _this->_impl_._has_bits_[3] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.adjustedstopprice_ = from._impl_.adjustedstopprice_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.randomizeprice_ = from._impl_.randomizeprice_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.ispeggedchangeamountdecrease_ = from._impl_.ispeggedchangeamountdecrease_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.conditionscancelorder_ = from._impl_.conditionscancelorder_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.conditionsignorerth_ = from._impl_.conditionsignorerth_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.adjustabletrailingunit_ = from._impl_.adjustabletrailingunit_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.adjustedstoplimitprice_ = from._impl_.adjustedstoplimitprice_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.adjustedtrailingamount_ = from._impl_.adjustedtrailingamount_;
    }
    _this->_impl_._has_bits_[3] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.lmtpriceoffset_ = from._impl_.lmtpriceoffset_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.cashqty_ = from._impl_.cashqty_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.dontuseautopriceforhedge_ = from._impl_.dontuseautopriceforhedge_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.isomscontainer_ = from._impl_.isomscontainer_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.discretionaryuptolimitprice_ = from._impl_.discretionaryuptolimitprice_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.autocancelparent_ = from._impl_.autocancelparent_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.reffuturesconid_ = from._impl_.reffuturesconid_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.parentpermid_ = from._impl_.parentpermid_;
    }
    _this->_impl_._has_bits_[3] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.usepricemgmtalgo_ = from._impl_.usepricemgmtalgo_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.posttoats_ = from._impl_.posttoats_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.imbalanceonly_ = from._impl_.imbalanceonly_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.routemarketabletobbo_ = from._impl_.routemarketabletobbo_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.professionalcustomer_ = from._impl_.professionalcustomer_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.includeovernight_ = from._impl_.includeovernight_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.mintradeqty_ = from._impl_.mintradeqty_;
    }
    _this->_impl_._has_bits_[3] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[4];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.mincompetesize_ = from._impl_.mincompetesize_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.competeagainstbestoffset_ = from._impl_.competeagainstbestoffset_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.midoffsetatwhole_ = from._impl_.midoffsetatwhole_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.midoffsetathalf_ = from._impl_.midoffsetathalf_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.manualorderindicator_ = from._impl_.manualorderindicator_;
    }
    _this->_impl_._has_bits_[4] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Order::CopyFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protobuf.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  return true;
}

void Order::InternalSwap(Order* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  swap(_impl_._has_bits_[2], other->_impl_._has_bits_[2]);
  swap(_impl_._has_bits_[3], other->_impl_._has_bits_[3]);
  swap(_impl_._has_bits_[4], other->_impl_._has_bits_[4]);
  _impl_.algoparams_.InternalSwap(&other->_impl_.algoparams_);
  _impl_.smartcomboroutingparams_.InternalSwap(&other->_impl_.smartcomboroutingparams_);
  _impl_.ordermiscoptions_.InternalSwap(&other->_impl_.ordermiscoptions_);
  _internal_mutable_conditions()->InternalSwap(other->_internal_mutable_conditions());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_, lhs_arena,
                                       &other->_impl_.action_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.totalquantity_, lhs_arena,
                                       &other->_impl_.totalquantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ordertype_, lhs_arena,
                                       &other->_impl_.ordertype_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.tif_, lhs_arena,
                                       &other->_impl_.tif_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.settlingfirm_, lhs_arena,
                                       &other->_impl_.settlingfirm_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.clearingaccount_, lhs_arena,
                                       &other->_impl_.clearingaccount_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.clearingintent_, lhs_arena,
                                       &other->_impl_.clearingintent_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.goodaftertime_, lhs_arena,
                                       &other->_impl_.goodaftertime_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.goodtilldate_, lhs_arena,
                                       &other->_impl_.goodtilldate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ocagroup_, lhs_arena,
                                       &other->_impl_.ocagroup_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.orderref_, lhs_arena,
                                       &other->_impl_.orderref_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.rule80a_, lhs_arena,
                                       &other->_impl_.rule80a_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.activestarttime_, lhs_arena,
                                       &other->_impl_.activestarttime_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.activestoptime_, lhs_arena,
                                       &other->_impl_.activestoptime_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fagroup_, lhs_arena,
                                       &other->_impl_.fagroup_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.famethod_, lhs_arena,
                                       &other->_impl_.famethod_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fapercentage_, lhs_arena,
                                       &other->_impl_.fapercentage_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.deltaneutralordertype_, lhs_arena,
                                       &other->_impl_.deltaneutralordertype_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.deltaneutralopenclose_, lhs_arena,
                                       &other->_impl_.deltaneutralopenclose_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.deltaneutraldesignatedlocation_, lhs_arena,
                                       &other->_impl_.deltaneutraldesignatedlocation_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.scaletable_, lhs_arena,
                                       &other->_impl_.scaletable_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hedgetype_, lhs_arena,
                                       &other->_impl_.hedgetype_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hedgeparam_, lhs_arena,
                                       &other->_impl_.hedgeparam_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.algostrategy_, lhs_arena,
                                       &other->_impl_.algostrategy_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.algoid_, lhs_arena,
                                       &other->_impl_.algoid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.openclose_, lhs_arena,
                                       &other->_impl_.openclose_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.designatedlocation_, lhs_arena,
                                       &other->_impl_.designatedlocation_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.deltaneutralsettlingfirm_, lhs_arena,
                                       &other->_impl_.deltaneutralsettlingfirm_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.deltaneutralclearingaccount_, lhs_arena,
                                       &other->_impl_.deltaneutralclearingaccount_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.deltaneutralclearingintent_, lhs_arena,
                                       &other->_impl_.deltaneutralclearingintent_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.referenceexchangeid_, lhs_arena,
                                       &other->_impl_.referenceexchangeid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.adjustedordertype_, lhs_arena,
                                       &other->_impl_.adjustedordertype_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.modelcode_, lhs_arena,
                                       &other->_impl_.modelcode_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.extoperator_, lhs_arena,
                                       &other->_impl_.extoperator_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mifid2decisionmaker_, lhs_arena,
                                       &other->_impl_.mifid2decisionmaker_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mifid2decisionalgo_, lhs_arena,
                                       &other->_impl_.mifid2decisionalgo_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mifid2executiontrader_, lhs_arena,
                                       &other->_impl_.mifid2executiontrader_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mifid2executionalgo_, lhs_arena,
                                       &other->_impl_.mifid2executionalgo_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.autocanceldate_, lhs_arena,
                                       &other->_impl_.autocanceldate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.filledquantity_, lhs_arena,
                                       &other->_impl_.filledquantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.shareholder_, lhs_arena,
                                       &other->_impl_.shareholder_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.advancederroroverride_, lhs_arena,
                                       &other->_impl_.advancederroroverride_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.manualordertime_, lhs_arena,
                                       &other->_impl_.manualordertime_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.customeraccount_, lhs_arena,
                                       &other->_impl_.customeraccount_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.bondaccruedinterest_, lhs_arena,
                                       &other->_impl_.bondaccruedinterest_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.submitter_, lhs_arena,
                                       &other->_impl_.submitter_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Order, _impl_.manualorderindicator_)
      + sizeof(Order::_impl_.manualorderindicator_)
      - PROTOBUF_FIELD_OFFSET(Order, _impl_.softdollartier_)>(
          reinterpret_cast<char*>(&_impl_.softdollartier_),
          reinterpret_cast<char*>(&other->_impl_.softdollartier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Order::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Order_2eproto_getter, &descriptor_table_Order_2eproto_once,
      file_level_metadata_Order_2eproto[3]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protobuf
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protobuf::Order_AlgoParamsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protobuf::Order_AlgoParamsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protobuf::Order_AlgoParamsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protobuf::Order_SmartComboRoutingParamsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protobuf::Order_OrderMiscOptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protobuf::Order_OrderMiscOptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protobuf::Order_OrderMiscOptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protobuf::Order*
Arena::CreateMaybeMessage< ::protobuf::Order >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protobuf::Order >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
